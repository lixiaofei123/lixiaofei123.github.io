<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display a map</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/v1.11.0/mapbox-gl.js"></script>
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v1.11.0/mapbox-gl.css"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
       class iMap extends mapboxgl.Map {
        constructor(options) {
            super(options);
        }

        off(type, arg1, arg2) {
            let listener = typeof arg1 === "function" ? arg1 : arg2;
            if (this.listenerMap[type]) {
            let index = this.listenerMap[type].findIndex(
                (l) => l.listener === listener
            );
            if (index != -1) {
                this.listenerMap[type].splice(index, 1);
            }
            }
        }

        /**
         *支持两种调用形式
            * on(type, layerId, listener, priority, forceCall)
            * on(type, listener, priority, forceCall)
            * priority为优先级，值越大在调用链中越靠前
            * forceCall为强制调用，如果为true,则即使前面的事件屏蔽了事件的传播，仍然会被调用
            * 由于priority和forceCall为可选属性，因此，新的on接口完全兼容原来的接口
            */

        on(type, arg1, arg2, arg3, arg4) {
            this.listenerMap = this.listenerMap || {};
            let listener = undefined;
            let priority = 0;
            let forceCall = false;
            let layerId;
            if (typeof arg1 === "function") {
                // arg1 为listener  arg2为优先级, arg3为是否强制调用
                if (arg2 && typeof arg2 === "number") {
                    priority = arg2;
                }
                if (arg3 && typeof arg3 === "boolean") {
                    forceCall = arg1;
                }
                listener = arg1;
            } else {
                // arg1 为图层ID，arg2为listener, arg3为优先级，arg4为是否强制调用
                layerId = arg1;
                if (arg3 && typeof arg3 === "number") {
                    priority = arg3;
                }
                if (arg4 && typeof arg4 === "boolean") {
                    forceCall = arg4;
                }
                listener = arg2;
            }

            if (listener) {
            if (this.listenerMap[type] === undefined) {
                //注册事件
                this.listenerMap[type] = [];
                super.on(type, (event) => {
                let eventNotStop = true;
                let sortListeners = this.listenerMap[type].sort(
                    (a, b) => b.priority - a.priority
                );
                let filterLayers;
                if (event.point) {
                    //如果事件包含点事件的话需要进行过滤出哪些图层包含了这些点。如果事件是绑定在图层上的话，需要这个来判断是否需要被调用
                    filterLayers = this._whichLayerContainsGeometry(
                    event.point,
                    sortListeners
                        .map((l) => l.layerId)
                        .filter((item) => item !== undefined)
                    );
                }
                for (let listener of sortListeners) {
                    if (
                    !filterLayers ||
                    !listener.layerId ||
                    filterLayers.findIndex((l) => l === listener.layerId) !== -1
                    ) {
                        if (eventNotStop) {
                            let executeResult = listener.listener(event);
                            eventNotStop =
                            executeResult === undefined ? true : executeResult;
                        } else {
                            //事件已经被终止，只允许forceCall的lisnten被调用
                            if (listener.forceCall) {
                            listener.listener(event);
                            }
                        }
                    }
                    }
                });
            }
            this.listenerMap[type].push({
                    priority: priority,
                    layerId: layerId,
                    forceCall: forceCall,
                    listener: listener,
                });
            }
        }

        _whichLayerContainsGeometry(geometry, layers) {
            let newlayers = [];
            for (let layer of layers) {
                if (this.getLayer(layer)) {
                    newlayers.push(layer);
                }
            }
            let features = this.queryRenderedFeatures(geometry, {
                layers: newlayers,
            });
            let targetLayers = features.map((f) => f.layer.id);
            return targetLayers;
        }
    }

      mapboxgl.accessToken =
        "<your access token>";
      var map = new iMap({
        container: "map",
        style: "mapbox://styles/mapbox/streets-v11",
        center: [-74.5, 40],
        zoom: 9, 
      });

      map.on("load", () => {
        map.on("click", (e) => {
          console.log("虽然我排在第一个，但是由于我的优先级低(默认为0)，而且前面的调用返回了false，所以我不会被调用");
        });
        map.on("click", (e) => {
            console.log("虽然前面的调用返回了false，但是我的forceCall被设置为了true，所以仍然会被调用");
        },1,true);
        map.on("click", (e) => {
          console.log("我的优先级排第二，我要阻止事件的继续向下传播");
          return false;
        },7);
        map.on("click", (e) => {
          console.log("虽然我排在最后，但是由于我的优先级最高，会被第一个调用");
        },9);
      });
    </script>
  </body>
</html>
