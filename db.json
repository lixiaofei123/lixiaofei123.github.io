{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style-dark.styl","path":"css/style-dark.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/mywidget.js","path":"js/mywidget.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.eot","path":"iconfont/icofont/icofont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.svg","path":"iconfont/icofont/icofont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.ttf","path":"iconfont/icofont/icofont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.woff","path":"iconfont/icofont/icofont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.woff2","path":"iconfont/icofont/icofont.woff2","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","path":"img/bg-dark.jpg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/css/share.styl","path":"share/css/share.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","path":"share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","path":"share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","path":"share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","path":"share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/js/qrcode.js","path":"share/js/qrcode.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/js/social-share.js","path":"share/js/social-share.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"0eef4184c552dfe787cc854dfd78d9f2c042b89f","modified":1557280328000},{"_id":"themes/BlueLake/LICENSE","hash":"3e191ca3f51efc111863c4941051291a696ef43e","modified":1557228823000},{"_id":"themes/BlueLake/README.en.md","hash":"4fd8231fe6eb7774dae4e17871b6f8a795be3c96","modified":1557228823000},{"_id":"themes/BlueLake/README.md","hash":"086ddf7bca540a22f2b7aeaeb5aafb869d5dfe7f","modified":1557228823000},{"_id":"themes/BlueLake/_config.yml","hash":"fa1c594abb4719ed516aad5646ff0daec8d64f94","modified":1588920442788},{"_id":"themes/BlueLake/package.json","hash":"e06eea20c64b2821631a49e8902e645bad2c5102","modified":1557228823000},{"_id":"source/_posts/Expand-the-function-of-ocdownloader.md","hash":"3414cb60faa610b067ae0d1039543fbc2cab7067","modified":1588901686267},{"_id":"source/_posts/My-personal-bookmarks.md","hash":"84c97e798a52f8bfdd8e82437bd16860beaa502a","modified":1565934388695},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures.md","hash":"64f5deb7b06bcd6e94d990cde8a8b8228c6780bc","modified":1588924032656},{"_id":"source/_posts/The-Go-Memory-Model.md","hash":"b4f117ea593eb2a753ac0ceacbb23b48aa4427a0","modified":1568976236749},{"_id":"source/_posts/create-native-app-from-web-url.md","hash":"c230e94167cad53acaac3046340a75af4743cba4","modified":1588901686267},{"_id":"source/_posts/docker-pull-remote-error-tls-handshake-failure.md","hash":"86666b403201728a41ce2c756c97d7ac805644a5","modified":1560477283393},{"_id":"source/_posts/k8s-docker-images-mirrors.md","hash":"a2549d384dde021a2fd420868e3e0844b402d4e8","modified":1586935115481},{"_id":"source/_posts/mysql-create-user.md","hash":"8b041de378fb999fff71aec90676ddb7627fbf46","modified":1557972574000},{"_id":"source/_posts/nextcloud-in-docker.md","hash":"668ea43815601c055cf25713d6ccd835e0978737","modified":1588901686267},{"_id":"source/_posts/textarea.md","hash":"70dd27e45eefec331ace2f21ed947c6454424f32","modified":1560761975271},{"_id":"source/_posts/ubuntu-create-desktop-icon.md","hash":"4ab66265c0a503782cb5454570793bb40dd381f1","modified":1588901686267},{"_id":"source/_posts/welcome-my-blog.md","hash":"b3ce2d849171330090835c6441c834b98a3abc78","modified":1588901686267},{"_id":"source/about/index.md","hash":"22fb72022d1acca804f24a54bae83ebea0f17667","modified":1557232050000},{"_id":"themes/BlueLake/layout/archive.jade","hash":"0497469c869f0ac28f150295dbddf6920e6582c1","modified":1557228823000},{"_id":"themes/BlueLake/layout/base.jade","hash":"6a91558b5593719bbe0fe7142db579294bfcc68b","modified":1588918957182},{"_id":"themes/BlueLake/layout/category.jade","hash":"384e2e2588ecab3f518f03f11f2b052d3827fad8","modified":1557228823000},{"_id":"themes/BlueLake/layout/page.jade","hash":"194218fb27d6155a09e7abcee16e151e47da3435","modified":1588823180300},{"_id":"themes/BlueLake/layout/index.jade","hash":"b9f411e7b66da6b50411fcd72b436d87dd62bd56","modified":1588823158931},{"_id":"themes/BlueLake/layout/post.jade","hash":"a87c1391e730fc2924d789879e221b87ba0d22de","modified":1588915386264},{"_id":"themes/BlueLake/layout/tag.jade","hash":"835da21846c730f0e3e344dc7e2e59154030b4f7","modified":1557228823000},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"9a6f8a63f5cdd7f579bf8310398301a759c2a6d2","modified":1557228823000},{"_id":"themes/BlueLake/languages/en.yml","hash":"a0f828574b5e90b83eeca4c5a80958459113f2b4","modified":1557228823000},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"bb4b241b45840234922ad4a170d42c9582c0c2ce","modified":1557228823000},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"420566a5a200394e45841a2e2223b3fb9625680d","modified":1557228823000},{"_id":"themes/BlueLake/languages/ko.yml","hash":"27bac975b25998012fe7317b2cf3e6c253bc2ab2","modified":1557228823000},{"_id":"themes/BlueLake/languages/tr.yml","hash":"89a834a6b6616ac7289968cace76e2fbf0335787","modified":1557228823000},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"ab546d6013b88e2a6c03d0de78087bc7ef9b05dd","modified":1557371052000},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"f0ce05b7f99d7e8a37ce899b4875e5b03133cf2c","modified":1557228823000},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1557228823000},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1557228823000},{"_id":"source/_posts/Expand-the-function-of-ocdownloader/downloadpage.png","hash":"5e4b83d91ebc2d2775a03f85bdf91501514cf3be","modified":1588901686267},{"_id":"source/_posts/Expand-the-function-of-ocdownloader/tool-example.png","hash":"2bcdf9071830b67e98bfbec3e96d535502f50173","modified":1588755308089},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png","hash":"9305442f7271f148c4f4e53828bd068e895e4917","modified":1588901686267},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png","hash":"228a051f8c33862d2998fbfbfa3017a851641371","modified":1588901686267},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png","hash":"d505f5e5f9cf681b6420e85a4bf3a0fab7938b45","modified":1588901686267},{"_id":"source/_posts/nextcloud-in-docker/downloader.png","hash":"d4fb9d8ca8466c26754060d1f51f8996922210c6","modified":1588147441992},{"_id":"source/_posts/nextcloud-in-docker/main.png","hash":"95f18d1421b29658d1fbb334e2b01c0b15624605","modified":1588147380916},{"_id":"source/_posts/nextcloud-in-docker/屏幕截图.png","hash":"c21583608f7bda34014eee984c275020be71695d","modified":1588752259685},{"_id":"source/_posts/welcome-my-blog/shamo.jpg","hash":"457cb458300ec2200506d9bf6515fb0aae94e5bc","modified":1557289547000},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"40e196388f23110239201393b5e0d10b295ffebd","modified":1588823399297},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"52e4cacd58d5e0061924189ad75e0c3bf622aa7f","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"6c1ffdf69272d1610a746614938f5638d21d2f21","modified":1588821745276},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"14ce126c573ba57b10a8c384bacbe7d2fa0de1c7","modified":1588829331094},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"7736811d57583aa792f966ed260fb1e9b5a8e505","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"1c988c7e1f716036e428ee16b8005a7b1bfb33c7","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"db5b44e3124558ca9468faea4bc9d27839c951e8","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1557228823000},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"530edfd58c2c821f35142e13049b02b7d33194cb","modified":1588823233956},{"_id":"themes/BlueLake/layout/_widget/aboutme.jade","hash":"bbfc74e143ce51b27cbd3fab2e21c421de7663f3","modified":1588920308009},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"48b59fdc5f353ce2a6df04b4be7b32a88469de9d","modified":1557296248000},{"_id":"themes/BlueLake/layout/_widget/attachments.jade","hash":"d3f3e5a33fff9109cf539d6d15029407cca38206","modified":1588920292645},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"232077a3a6ccf366f5a132014fb4791235a507fa","modified":1588831793043},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"317bb85d7639e03032a631cdac3a29878c2ce657","modified":1557374730000},{"_id":"themes/BlueLake/layout/_widget/qrcode.jade","hash":"3f7f2d64744edb3b66fc8206f992e8aecd70cdcf","modified":1588920297325},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"f8ae55d5514fe493651ec04fbe73cb5fc482f7cd","modified":1557228823000},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"0bcf69e93cc49191007d4cdd2086d1b9d42e291c","modified":1557296229000},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"7b51a95c8c1db049b4a12827954423e5cde57e6a","modified":1588831812419},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"53e99461ae7f8efb2a1e78ad3090dd93d18bcd5c","modified":1557228823000},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","hash":"e6079d1bfdb68b37b111bccc08e4f7d2be9f5eaa","modified":1557228823000},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"be9ad73454b7029311caafd8e1faa469a5d4f58d","modified":1557228823000},{"_id":"themes/BlueLake/source/css/style-dark.styl","hash":"019565e55b7535545cbff03b99dd3c1d4a54cc42","modified":1588835998739},{"_id":"themes/BlueLake/source/css/style.styl","hash":"72346ea3983040110f131ba748fb17400060e629","modified":1588920262185},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1588918957182},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1588918957182},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1588918957182},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1588918957182},{"_id":"themes/BlueLake/source/js/mywidget.js","hash":"a9f4cc19c3697bed6ae4e0c3b17a8b34f8634cfb","modified":1588918957182},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1557228823000},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1557228823000},{"_id":"themes/BlueLake/source/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1557228823000},{"_id":"source/_posts/create-native-app-from-web-url/appmaker.png","hash":"da596c2ed8349d123e8a88e2a80a408f045cba10","modified":1565763099587},{"_id":"source/_posts/nextcloud-in-docker/drawio.png","hash":"bf3d94655e22c9b6db030d39c3fad762eb3d5a18","modified":1588152200826},{"_id":"source/_posts/nextcloud-in-docker/files.png","hash":"5b59aa60919142d346509ce09a19aa80d79fff09","modified":1588147404180},{"_id":"source/_posts/nextcloud-in-docker/httttttps.png","hash":"db045a4fcdaa6eac71eb9006cdd2b079ba87601e","modified":1588151494898},{"_id":"source/_posts/nextcloud-in-docker/mindmap.png","hash":"3c34afe9f98bb3b718a5c16039e20a9858746969","modified":1588151995857},{"_id":"source/_posts/welcome-my-blog/footbg2.png","hash":"de26ae1185f689988875bbc9f71bcef5f55de08a","modified":1557310424000},{"_id":"source/_posts/welcome-my-blog/touxiang.jpeg","hash":"bae34abad8c2f91dfa029066d3491d7eeb8d0afc","modified":1588075338944},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1557228823000},{"_id":"source/_posts/nextcloud-in-docker/login.png","hash":"3d67fa1e7d556f72d74f82fac7aeec84497ab2be","modified":1588147322167},{"_id":"source/_posts/nextcloud-in-docker/ocdownloader.png","hash":"db9007083fa004bd73d7bb7d89e9773dade69695","modified":1588148078024},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.eot","hash":"e92beeb716ed23fae4b4346205d8488ae18165b0","modified":1588920032552},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.svg","hash":"750eb1e5556324d87e4a62ccb43d46518dfc2006","modified":1588920032580},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.ttf","hash":"c865a29cffb1347905be1766c486aafc32a96fae","modified":1588920032600},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.woff","hash":"8c7d76c03eb867a736d8f3336fb0d608fc3736f0","modified":1588920032620},{"_id":"themes/BlueLake/source/iconfont/icofont/icofont.woff2","hash":"a759b7644874fc90ce8c6260f39229d169e1e907","modified":1588920032640},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1557228823000},{"_id":"themes/BlueLake/source/share/css/share.styl","hash":"dea3b7a6adb17969e57e5c3d71876245016be21a","modified":1557228823000},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1588918957182},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1588918957182},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1588918957182},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1588918957182},{"_id":"themes/BlueLake/source/share/js/qrcode.js","hash":"9caa0d9a9ba4409a3f77540a1b15a7617aeb28e8","modified":1557228823000},{"_id":"themes/BlueLake/source/share/js/social-share.js","hash":"9bfe34fe7691833e90815c5c862545bde581cf29","modified":1557228823000},{"_id":"source/_posts/ubuntu-create-desktop-icon/typora.png","hash":"0bbfa9902b74bc5f8faf16ba73d600a0c4d849bf","modified":1565762606158},{"_id":"public/baidusitemap.xml","hash":"b91357c760749b8d264d07dedead2d0d66791397","modified":1588924144624},{"_id":"public/atom.xml","hash":"7a5971fa2303726592306d8eae8a39d086643aa8","modified":1588924144625},{"_id":"public/sitemap.xml","hash":"144d8a2f38912720d0f85e3d9e23c5136fa1f8ee","modified":1588924144630},{"_id":"public/content.json","hash":"6db416cf558427d940eeff87941223c551d44c3a","modified":1588924144631},{"_id":"public/about/index.html","hash":"4c54ac98bbcf885a634bf251908c0da03e75eb6a","modified":1588924144637},{"_id":"public/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/index.html","hash":"7f80fd46f3dcbd2a8f6e14174006fb8f5fb6596f","modified":1588924144637},{"_id":"public/2019/08/14/create-native-app-from-web-url/index.html","hash":"faf5a23f809167a0b5bb9a54fae7bca938ac3564","modified":1588924144637},{"_id":"public/2019/08/14/ubuntu-create-desktop-icon/index.html","hash":"f7bcf9f45540a87e819af855105b5ad956a549b6","modified":1588924144637},{"_id":"public/2019/06/28/My-personal-bookmarks/index.html","hash":"340a14498da4c43ac8affb400e05ae0a7f0d68cd","modified":1588924144638},{"_id":"public/2019/06/17/textarea/index.html","hash":"710bff0ce0ffb3cc6aada7415e3571c9f3fe4c4b","modified":1588924144638},{"_id":"public/2019/06/13/docker-pull-remote-error-tls-handshake-failure/index.html","hash":"df76d855362bd93c7f56e2ea66bc2c5d0bbdc271","modified":1588924144638},{"_id":"public/2019/06/13/k8s-docker-images-mirrors/index.html","hash":"cd571dc4d71cf5729fd36fda920d529d1590b37e","modified":1588924144638},{"_id":"public/2019/05/07/mysql-create-user/index.html","hash":"bb680eb5f1d82670acafc1554af7dd7ff9f5f66b","modified":1588924144639},{"_id":"public/2019/05/07/welcome-my-blog/index.html","hash":"7e291dcec0dd845d2da4d7cdb580bdfe6737e396","modified":1588924144639},{"_id":"public/archives/index.html","hash":"915f3b67e5e22501881287ea2c87947ae1c8ba28","modified":1588924144639},{"_id":"public/archives/page/2/index.html","hash":"51ddef69ab3fba09af94b8618fec8b36283293a3","modified":1588924144639},{"_id":"public/archives/2019/index.html","hash":"0dedcf7846554006dccee8f0b147bd906754c3d6","modified":1588924144639},{"_id":"public/archives/2019/05/index.html","hash":"0374b659d4bb13bce5d852d13f68afd3b2c11d55","modified":1588924144639},{"_id":"public/archives/2019/06/index.html","hash":"4b0da5b6257b87196e0fbf729a703630c09a72fc","modified":1588924144639},{"_id":"public/archives/2019/08/index.html","hash":"c7c987561677b33f35ef8f4caaf19c62d80fe0b6","modified":1588924144639},{"_id":"public/archives/2019/09/index.html","hash":"39595515b5129821ec3f6046ccfa8d91b7e80db5","modified":1588924144639},{"_id":"public/archives/2020/index.html","hash":"10ef69394226de4b709f7da115be20f6390ccceb","modified":1588924144639},{"_id":"public/archives/2020/04/index.html","hash":"8fbaeddcf656e773a62ac27dbf4716023902f2f8","modified":1588924144639},{"_id":"public/archives/2020/05/index.html","hash":"3dc64f5f06cdc9eea9e2c465f5233cc8c1524c99","modified":1588924144639},{"_id":"public/categories/实用/index.html","hash":"a6ea8876299537917461130dca3aff488f3bbc0d","modified":1588924144640},{"_id":"public/categories/kubernetes/index.html","hash":"4ec17d42c96d6c536ee29e5cdcbe21a678e1b3f4","modified":1588924144640},{"_id":"public/categories/杂谈/index.html","hash":"a21c37e2562c0818b1a98c981f88418796628554","modified":1588924144640},{"_id":"public/index.html","hash":"e15bc7fe39fa3ec3788c645775c2197754249388","modified":1588924144640},{"_id":"public/page/2/index.html","hash":"89fb5db68b36d7607f0d4088c592f72de1b1fe3f","modified":1588924144640},{"_id":"public/tags/nextcloud/index.html","hash":"1054446a7401a6298bfcc5495e5cbec8a089a74e","modified":1588924144640},{"_id":"public/tags/ocdownloader/index.html","hash":"d3de11ab5ebe3a3e12e428fcb742db323a58f0de","modified":1588924144640},{"_id":"public/tags/kubernetes/index.html","hash":"2f1f9f8a5339c022e347034a1ff193556ff1bcd7","modified":1588924144640},{"_id":"public/tags/markdown/index.html","hash":"80252bc938f0ef5ba7a801e8d8a5dd5f2344f027","modified":1588924144640},{"_id":"public/tags/图床/index.html","hash":"c6dafd1d25face1e622bc5abf499d403c7195c2a","modified":1588924144640},{"_id":"public/tags/golang学习/index.html","hash":"ec990e9bf71447722736c84fb1a2f9f445d7aaf5","modified":1588924144640},{"_id":"public/tags/ubuntu/index.html","hash":"e34a4747dbd0f486324afeede9e85427f0b86a79","modified":1588924144640},{"_id":"public/tags/docker/index.html","hash":"ca67ce6de2c5b28c1ea530b74330f3869f97ee33","modified":1588924144640},{"_id":"public/tags/k8s/index.html","hash":"7adff7f5348535c9a7161d17489c2fd2aee78e61","modified":1588924144640},{"_id":"public/tags/helm/index.html","hash":"ccd0814797f37be42079cfe4d88db9c0be3e68b4","modified":1588924144640},{"_id":"public/tags/mysql/index.html","hash":"3046dfee46c7581bd442e42836cd40b5c6ebfcc7","modified":1588924144640},{"_id":"public/tags/tools/index.html","hash":"a8f7ffb98f0a3af35a8f035b45ae1fd84fe9b4c4","modified":1588924144640},{"_id":"public/tags/欢迎/index.html","hash":"160e263a809151089f0f54f4d3c0a66eb0a769f7","modified":1588924144640},{"_id":"public/tags/博客/index.html","hash":"69ba3379e80f12a5a63d2a3e928521488b146625","modified":1588924144640},{"_id":"public/2020/05/06/Expand-the-function-of-ocdownloader/index.html","hash":"67859e68cd5f05dd340baeb57fbed9909a70a49b","modified":1588924144640},{"_id":"public/2020/04/29/nextcloud-in-docker/index.html","hash":"22870ad5b089db91172da4bae216a95864f1e2c9","modified":1588924144640},{"_id":"public/2019/09/20/The-Go-Memory-Model/index.html","hash":"049952118cab8d9acfc21244731cdbab6a3c3eee","modified":1588924144640},{"_id":"public/CNAME","hash":"0eef4184c552dfe787cc854dfd78d9f2c042b89f","modified":1588924144648},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1588924144648},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1588924144648},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1588924144648},{"_id":"public/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1588924144648},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1588924144648},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1588924144648},{"_id":"public/iconfont/icofont/icofont.eot","hash":"e92beeb716ed23fae4b4346205d8488ae18165b0","modified":1588924144648},{"_id":"public/iconfont/icofont/icofont.svg","hash":"750eb1e5556324d87e4a62ccb43d46518dfc2006","modified":1588924144648},{"_id":"public/iconfont/icofont/icofont.ttf","hash":"c865a29cffb1347905be1766c486aafc32a96fae","modified":1588924144648},{"_id":"public/iconfont/icofont/icofont.woff","hash":"8c7d76c03eb867a736d8f3336fb0d608fc3736f0","modified":1588924144648},{"_id":"public/iconfont/icofont/icofont.woff2","hash":"a759b7644874fc90ce8c6260f39229d169e1e907","modified":1588924144648},{"_id":"public/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1588924144648},{"_id":"public/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1588924144648},{"_id":"public/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1588924144648},{"_id":"public/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1588924144648},{"_id":"public/2020/05/06/Expand-the-function-of-ocdownloader/downloadpage.png","hash":"5e4b83d91ebc2d2775a03f85bdf91501514cf3be","modified":1588924144648},{"_id":"public/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png","hash":"9305442f7271f148c4f4e53828bd068e895e4917","modified":1588924144648},{"_id":"public/2020/05/06/Expand-the-function-of-ocdownloader/tool-example.png","hash":"2bcdf9071830b67e98bfbec3e96d535502f50173","modified":1588924144648},{"_id":"public/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png","hash":"228a051f8c33862d2998fbfbfa3017a851641371","modified":1588924144649},{"_id":"public/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png","hash":"d505f5e5f9cf681b6420e85a4bf3a0fab7938b45","modified":1588924144649},{"_id":"public/2019/05/07/welcome-my-blog/shamo.jpg","hash":"457cb458300ec2200506d9bf6515fb0aae94e5bc","modified":1588924144649},{"_id":"public/2020/04/29/nextcloud-in-docker/downloader.png","hash":"d4fb9d8ca8466c26754060d1f51f8996922210c6","modified":1588924144649},{"_id":"public/2020/04/29/nextcloud-in-docker/main.png","hash":"95f18d1421b29658d1fbb334e2b01c0b15624605","modified":1588924144649},{"_id":"public/2020/04/29/nextcloud-in-docker/屏幕截图.png","hash":"c21583608f7bda34014eee984c275020be71695d","modified":1588924144649},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1588924144794},{"_id":"public/2019/08/14/create-native-app-from-web-url/appmaker.png","hash":"da596c2ed8349d123e8a88e2a80a408f045cba10","modified":1588924144794},{"_id":"public/2019/05/07/welcome-my-blog/touxiang.jpeg","hash":"bae34abad8c2f91dfa029066d3491d7eeb8d0afc","modified":1588924144795},{"_id":"public/2020/04/29/nextcloud-in-docker/drawio.png","hash":"bf3d94655e22c9b6db030d39c3fad762eb3d5a18","modified":1588924144795},{"_id":"public/2020/04/29/nextcloud-in-docker/httttttps.png","hash":"db045a4fcdaa6eac71eb9006cdd2b079ba87601e","modified":1588924144795},{"_id":"public/2020/04/29/nextcloud-in-docker/mindmap.png","hash":"3c34afe9f98bb3b718a5c16039e20a9858746969","modified":1588924144795},{"_id":"public/css/highlight-dark.css","hash":"e6f5491318fbba0995c17c33ff8f4d8af957c2cb","modified":1588924144799},{"_id":"public/css/highlight.css","hash":"932879716cbce6f9a1b830070ed514082398f1ca","modified":1588924144799},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1588924144800},{"_id":"public/js/mywidget.js","hash":"a9f4cc19c3697bed6ae4e0c3b17a8b34f8634cfb","modified":1588924144800},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1588924144800},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1588924144800},{"_id":"public/share/css/share.css","hash":"f2c752f5eec4f88233c5f2d09807c01adee63100","modified":1588924144800},{"_id":"public/2019/05/07/welcome-my-blog/footbg2.png","hash":"de26ae1185f689988875bbc9f71bcef5f55de08a","modified":1588924144800},{"_id":"public/2020/04/29/nextcloud-in-docker/files.png","hash":"5b59aa60919142d346509ce09a19aa80d79fff09","modified":1588924144800},{"_id":"public/2020/04/29/nextcloud-in-docker/ocdownloader.png","hash":"db9007083fa004bd73d7bb7d89e9773dade69695","modified":1588924144800},{"_id":"public/share/js/social-share.js","hash":"9bfe34fe7691833e90815c5c862545bde581cf29","modified":1588924144949},{"_id":"public/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1588924144949},{"_id":"public/2020/04/29/nextcloud-in-docker/login.png","hash":"3d67fa1e7d556f72d74f82fac7aeec84497ab2be","modified":1588924144950},{"_id":"public/css/style.css","hash":"815043dc787eb044f7f84dfbd714d3acd2efb0c7","modified":1588924144952},{"_id":"public/css/style-dark.css","hash":"b6489efd229955a23b95f4829b5404eaaa9e6a99","modified":1588924144952},{"_id":"public/share/js/qrcode.js","hash":"9caa0d9a9ba4409a3f77540a1b15a7617aeb28e8","modified":1588924144955},{"_id":"public/2019/08/14/ubuntu-create-desktop-icon/typora.png","hash":"0bbfa9902b74bc5f8faf16ba73d600a0c4d849bf","modified":1588924144961}],"Category":[{"name":"实用","_id":"ck9xwerhj0002wrd7r0jc3dqm"},{"name":"kubernetes","_id":"ck9xwerhw000dwrd744v1uofc"},{"name":"杂谈","_id":"ck9xweri1000rwrd7jjip9mvw"}],"Data":[],"Page":[{"title":"about","date":"2019-05-07T12:27:30.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-05-07 20:27:30\n---\n","updated":"2019-05-07T12:27:30.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9xweryu001lwrd7v7lr05b7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"拓展nextcloud中ocdownloader的功能","date":"2020-05-06T08:32:03.000Z","_content":"\n\n\n\n\n\n\n**本文只针对不熟悉php的用户**\n\n\n\n经过[上文](https://www.lixf.io/2020/04/29/nextcloud-in-docker/)的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。\n\n首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点\n\n1. 其能够从指定的http链接上下载其对应的文件，\n2. 其大部分功能都是通过调用第三方工具实现\n\n根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。\n\n\n\n### 开发工具\n\n这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具\n\n![工具例子](https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/tool-example.png)\n\n该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接\n\n> 至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。\n\n\n\n### 拓展代码\n\n一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。\n\n为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。\n\n下面是修改步骤\n\n首先，将其插件代码克隆到本地\n\n```bash\nhttps://github.com/e-alfred/ocdownloader.git\n```\n\n然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。\n\n例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。\n\n```php\n<?php\n\nnamespace OCA\\ocDownloader\\Controller\\Lib;\n\nclass PBUtil{\n\n    private $PBDLBinary = null;\n    private $URL = null;\n    private $ProxyAddress = null;\n    private $ProxyPort = 0;\n\n    // 构造函数需要传入pbutil的执行文件路径，以及视频链接\n    // 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码\n    public function __construct($PBDLBinary, $URL){\n        $this->PBDLBinary = $PBDLBinary;\n        $this->URL = $URL;\n    }\n\n    public function setProxy($ProxyAddress, $ProxyPort)\n    {\n        $this->ProxyAddress = $ProxyAddress;\n        $this->ProxyPort = $ProxyPort;\n    }\n    \n    //  这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。\n    public function getVideoUrl(){\n        $Proxy = null;\n        if (!is_null($this->ProxyAddress) && $this->ProxyPort > 0 && $this->ProxyPort <= 65536) {\n            $Proxy = ' -proxy ' . rtrim($this->ProxyAddress, '/') . ':' . $this->ProxyPort;\n        }\n        $Output = shell_exec(\n            $this->PBDLBinary.' -videoUrl \\''.$this->URL.'\\' '\n            .(is_null($Proxy) ? '' : $Proxy)\n        );\n        return $Output;\n    }\n\n}\n```\n\n\n\n然后修改controller目录下的httpdownloader.php文件，\n\n首先，在99行的上面，也就是  if($isMagnet)这个代码的上面，加入下面的代码片段\n\n```php\n$sourceUrl = $_POST['FILE'];\nif (strpos($sourceUrl, '******') !== false) { //******换成视频网站的名字，例如 youku\n    $pbUtil = new PBUtil('/usr/bin/pbutil', $sourceUrl); //传入执行文件路径以及视频链接\n    if (!is_null($this - > ProxyAddress) && $this - > ProxyPort > 0 && $this - > ProxyPort <= 65536) {\n        $pbUtil - > SetProxy($this - > ProxyAddress, $this - > ProxyPort);\n    }\n    $respdata = $pbUtil - > GetVideoUrl();\n    $jsondata = json_decode($respdata); //获取返回结果后调用json解析\n    $sourceUrl = $jsondata - > url; // 获取资源链接\n    $videotitle = $jsondata - > title.'.mp4'; //获取文件名称\n}\n\n```\n\n接下来，将 if($isMagnet)后面出现的$_POST['FILE']全部替换为$sourceUrl\n\n然后，在114行的下面，也就是 $OPTIONS = array('dir' => $this->AbsoluteDownloadsFolder, 'out' => $Target, 'follow-torrent' => $isMagnet);这一行的代码下面，加入下面的代码\n\n```php\nif (isset($videotitle) && strlen(trim($videotitle)) > 0) {\n    $OPTIONS['out'] = $videotitle;\n}\n```\n\n\n\n### 部署插件\n\n将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!!\n\n![下载页面](https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/downloadpage.png)\n\n\n\n### 视频封面\n\n默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客[Nextcloud: Install Preview Generator](https://www.allerstorfer.at/nextcloud-install-preview-generator/)","source":"_posts/Expand-the-function-of-ocdownloader.md","raw":"---\ntitle: 拓展nextcloud中ocdownloader的功能\ndate: 2020-05-06 16:32:03\ncategories: 实用\ntags: \n  - nextcloud\n  - ocdownloader\n---\n\n\n\n\n\n\n\n**本文只针对不熟悉php的用户**\n\n\n\n经过[上文](https://www.lixf.io/2020/04/29/nextcloud-in-docker/)的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。\n\n首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点\n\n1. 其能够从指定的http链接上下载其对应的文件，\n2. 其大部分功能都是通过调用第三方工具实现\n\n根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。\n\n\n\n### 开发工具\n\n这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具\n\n![工具例子](https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/tool-example.png)\n\n该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接\n\n> 至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。\n\n\n\n### 拓展代码\n\n一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。\n\n为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。\n\n下面是修改步骤\n\n首先，将其插件代码克隆到本地\n\n```bash\nhttps://github.com/e-alfred/ocdownloader.git\n```\n\n然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。\n\n例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。\n\n```php\n<?php\n\nnamespace OCA\\ocDownloader\\Controller\\Lib;\n\nclass PBUtil{\n\n    private $PBDLBinary = null;\n    private $URL = null;\n    private $ProxyAddress = null;\n    private $ProxyPort = 0;\n\n    // 构造函数需要传入pbutil的执行文件路径，以及视频链接\n    // 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码\n    public function __construct($PBDLBinary, $URL){\n        $this->PBDLBinary = $PBDLBinary;\n        $this->URL = $URL;\n    }\n\n    public function setProxy($ProxyAddress, $ProxyPort)\n    {\n        $this->ProxyAddress = $ProxyAddress;\n        $this->ProxyPort = $ProxyPort;\n    }\n    \n    //  这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。\n    public function getVideoUrl(){\n        $Proxy = null;\n        if (!is_null($this->ProxyAddress) && $this->ProxyPort > 0 && $this->ProxyPort <= 65536) {\n            $Proxy = ' -proxy ' . rtrim($this->ProxyAddress, '/') . ':' . $this->ProxyPort;\n        }\n        $Output = shell_exec(\n            $this->PBDLBinary.' -videoUrl \\''.$this->URL.'\\' '\n            .(is_null($Proxy) ? '' : $Proxy)\n        );\n        return $Output;\n    }\n\n}\n```\n\n\n\n然后修改controller目录下的httpdownloader.php文件，\n\n首先，在99行的上面，也就是  if($isMagnet)这个代码的上面，加入下面的代码片段\n\n```php\n$sourceUrl = $_POST['FILE'];\nif (strpos($sourceUrl, '******') !== false) { //******换成视频网站的名字，例如 youku\n    $pbUtil = new PBUtil('/usr/bin/pbutil', $sourceUrl); //传入执行文件路径以及视频链接\n    if (!is_null($this - > ProxyAddress) && $this - > ProxyPort > 0 && $this - > ProxyPort <= 65536) {\n        $pbUtil - > SetProxy($this - > ProxyAddress, $this - > ProxyPort);\n    }\n    $respdata = $pbUtil - > GetVideoUrl();\n    $jsondata = json_decode($respdata); //获取返回结果后调用json解析\n    $sourceUrl = $jsondata - > url; // 获取资源链接\n    $videotitle = $jsondata - > title.'.mp4'; //获取文件名称\n}\n\n```\n\n接下来，将 if($isMagnet)后面出现的$_POST['FILE']全部替换为$sourceUrl\n\n然后，在114行的下面，也就是 $OPTIONS = array('dir' => $this->AbsoluteDownloadsFolder, 'out' => $Target, 'follow-torrent' => $isMagnet);这一行的代码下面，加入下面的代码\n\n```php\nif (isset($videotitle) && strlen(trim($videotitle)) > 0) {\n    $OPTIONS['out'] = $videotitle;\n}\n```\n\n\n\n### 部署插件\n\n将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!!\n\n![下载页面](https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/downloadpage.png)\n\n\n\n### 视频封面\n\n默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客[Nextcloud: Install Preview Generator](https://www.allerstorfer.at/nextcloud-install-preview-generator/)","slug":"Expand-the-function-of-ocdownloader","published":1,"updated":"2020-05-08T01:34:46.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhd0000wrd7jiqaaqay","content":"<p><strong>本文只针对不熟悉php的用户</strong></p>\n<p>经过<a href=\"https://www.lixf.io/2020/04/29/nextcloud-in-docker/\">上文</a>的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。</p>\n<p>首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点</p>\n<ol>\n<li>其能够从指定的http链接上下载其对应的文件，</li>\n<li>其大部分功能都是通过调用第三方工具实现</li>\n</ol>\n<p>根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。</p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><p>这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/tool-example.png\" alt=\"工具例子\"></p>\n<p>该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接</p>\n<blockquote>\n<p>至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。</p>\n</blockquote>\n<h3 id=\"拓展代码\"><a href=\"#拓展代码\" class=\"headerlink\" title=\"拓展代码\"></a>拓展代码</h3><p>一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。</p>\n<p>为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。</p>\n<p>下面是修改步骤</p>\n<p>首先，将其插件代码克隆到本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/e-alfred/ocdownloader.git</span><br></pre></td></tr></table></figure>\n<p>然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。</p>\n<p>例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">OCA</span>\\<span class=\"title\">ocDownloader</span>\\<span class=\"title\">Controller</span>\\<span class=\"title\">Lib</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PBUtil</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $PBDLBinary = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $URL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $ProxyAddress = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $ProxyPort = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数需要传入pbutil的执行文件路径，以及视频链接</span></span><br><span class=\"line\">    <span class=\"comment\">// 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($PBDLBinary, $URL)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;PBDLBinary = $PBDLBinary;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;URL = $URL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setProxy</span><span class=\"params\">($ProxyAddress, $ProxyPort)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;ProxyAddress = $ProxyAddress;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;ProxyPort = $ProxyPort;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//  这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVideoUrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        $Proxy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_null(<span class=\"keyword\">$this</span>-&gt;ProxyAddress) &amp;&amp; <span class=\"keyword\">$this</span>-&gt;ProxyPort &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">$this</span>-&gt;ProxyPort &lt;= <span class=\"number\">65536</span>) &#123;</span><br><span class=\"line\">            $Proxy = <span class=\"string\">' -proxy '</span> . rtrim(<span class=\"keyword\">$this</span>-&gt;ProxyAddress, <span class=\"string\">'/'</span>) . <span class=\"string\">':'</span> . <span class=\"keyword\">$this</span>-&gt;ProxyPort;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $Output = shell_exec(</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;PBDLBinary.<span class=\"string\">' -videoUrl \\''</span>.<span class=\"keyword\">$this</span>-&gt;URL.<span class=\"string\">'\\' '</span></span><br><span class=\"line\">            .(is_null($Proxy) ? <span class=\"string\">''</span> : $Proxy)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $Output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后修改controller目录下的httpdownloader.php文件，</p>\n<p>首先，在99行的上面，也就是  if($isMagnet)这个代码的上面，加入下面的代码片段</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sourceUrl = $_POST[<span class=\"string\">'FILE'</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (strpos($sourceUrl, <span class=\"string\">'******'</span>) !== <span class=\"keyword\">false</span>) &#123; <span class=\"comment\">//******换成视频网站的名字，例如 youku</span></span><br><span class=\"line\">    $pbUtil = <span class=\"keyword\">new</span> PBUtil(<span class=\"string\">'/usr/bin/pbutil'</span>, $sourceUrl); <span class=\"comment\">//传入执行文件路径以及视频链接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_null(<span class=\"keyword\">$this</span> - &gt; ProxyAddress) &amp;&amp; <span class=\"keyword\">$this</span> - &gt; ProxyPort &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">$this</span> - &gt; ProxyPort &lt;= <span class=\"number\">65536</span>) &#123;</span><br><span class=\"line\">        $pbUtil - &gt; SetProxy(<span class=\"keyword\">$this</span> - &gt; ProxyAddress, <span class=\"keyword\">$this</span> - &gt; ProxyPort);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    $respdata = $pbUtil - &gt; GetVideoUrl();</span><br><span class=\"line\">    $jsondata = json_decode($respdata); <span class=\"comment\">//获取返回结果后调用json解析</span></span><br><span class=\"line\">    $sourceUrl = $jsondata - &gt; url; <span class=\"comment\">// 获取资源链接</span></span><br><span class=\"line\">    $videotitle = $jsondata - &gt; title.<span class=\"string\">'.mp4'</span>; <span class=\"comment\">//获取文件名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl</p>\n<p>然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    $OPTIONS[<span class=\"string\">'out'</span>] = $videotitle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署插件\"><a href=\"#部署插件\" class=\"headerlink\" title=\"部署插件\"></a>部署插件</h3><p>将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!!</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/downloadpage.png\" alt=\"下载页面\"></p>\n<h3 id=\"视频封面\"><a href=\"#视频封面\" class=\"headerlink\" title=\"视频封面\"></a>视频封面</h3><p>默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客<a href=\"https://www.allerstorfer.at/nextcloud-install-preview-generator/\" target=\"_blank\" rel=\"noopener\">Nextcloud: Install Preview Generator</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>本文只针对不熟悉php的用户</strong></p>\n<p>经过<a href=\"https://www.lixf.io/2020/04/29/nextcloud-in-docker/\">上文</a>的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。</p>\n<p>首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点</p>\n<ol>\n<li>其能够从指定的http链接上下载其对应的文件，</li>\n<li>其大部分功能都是通过调用第三方工具实现</li>\n</ol>\n<p>根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。</p>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><p>这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/tool-example.png\" alt=\"工具例子\"></p>\n<p>该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接</p>\n<blockquote>\n<p>至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。</p>\n</blockquote>\n<h3 id=\"拓展代码\"><a href=\"#拓展代码\" class=\"headerlink\" title=\"拓展代码\"></a>拓展代码</h3><p>一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。</p>\n<p>为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。</p>\n<p>下面是修改步骤</p>\n<p>首先，将其插件代码克隆到本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/e-alfred/ocdownloader.git</span><br></pre></td></tr></table></figure>\n<p>然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。</p>\n<p>例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">OCA</span>\\<span class=\"title\">ocDownloader</span>\\<span class=\"title\">Controller</span>\\<span class=\"title\">Lib</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PBUtil</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $PBDLBinary = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $URL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $ProxyAddress = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $ProxyPort = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数需要传入pbutil的执行文件路径，以及视频链接</span></span><br><span class=\"line\">    <span class=\"comment\">// 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($PBDLBinary, $URL)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;PBDLBinary = $PBDLBinary;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;URL = $URL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setProxy</span><span class=\"params\">($ProxyAddress, $ProxyPort)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;ProxyAddress = $ProxyAddress;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;ProxyPort = $ProxyPort;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//  这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVideoUrl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        $Proxy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!is_null(<span class=\"keyword\">$this</span>-&gt;ProxyAddress) &amp;&amp; <span class=\"keyword\">$this</span>-&gt;ProxyPort &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">$this</span>-&gt;ProxyPort &lt;= <span class=\"number\">65536</span>) &#123;</span><br><span class=\"line\">            $Proxy = <span class=\"string\">' -proxy '</span> . rtrim(<span class=\"keyword\">$this</span>-&gt;ProxyAddress, <span class=\"string\">'/'</span>) . <span class=\"string\">':'</span> . <span class=\"keyword\">$this</span>-&gt;ProxyPort;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $Output = shell_exec(</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;PBDLBinary.<span class=\"string\">' -videoUrl \\''</span>.<span class=\"keyword\">$this</span>-&gt;URL.<span class=\"string\">'\\' '</span></span><br><span class=\"line\">            .(is_null($Proxy) ? <span class=\"string\">''</span> : $Proxy)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $Output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后修改controller目录下的httpdownloader.php文件，</p>\n<p>首先，在99行的上面，也就是  if($isMagnet)这个代码的上面，加入下面的代码片段</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$sourceUrl = $_POST[<span class=\"string\">'FILE'</span>];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (strpos($sourceUrl, <span class=\"string\">'******'</span>) !== <span class=\"keyword\">false</span>) &#123; <span class=\"comment\">//******换成视频网站的名字，例如 youku</span></span><br><span class=\"line\">    $pbUtil = <span class=\"keyword\">new</span> PBUtil(<span class=\"string\">'/usr/bin/pbutil'</span>, $sourceUrl); <span class=\"comment\">//传入执行文件路径以及视频链接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_null(<span class=\"keyword\">$this</span> - &gt; ProxyAddress) &amp;&amp; <span class=\"keyword\">$this</span> - &gt; ProxyPort &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">$this</span> - &gt; ProxyPort &lt;= <span class=\"number\">65536</span>) &#123;</span><br><span class=\"line\">        $pbUtil - &gt; SetProxy(<span class=\"keyword\">$this</span> - &gt; ProxyAddress, <span class=\"keyword\">$this</span> - &gt; ProxyPort);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    $respdata = $pbUtil - &gt; GetVideoUrl();</span><br><span class=\"line\">    $jsondata = json_decode($respdata); <span class=\"comment\">//获取返回结果后调用json解析</span></span><br><span class=\"line\">    $sourceUrl = $jsondata - &gt; url; <span class=\"comment\">// 获取资源链接</span></span><br><span class=\"line\">    $videotitle = $jsondata - &gt; title.<span class=\"string\">'.mp4'</span>; <span class=\"comment\">//获取文件名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl</p>\n<p>然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">isset</span>($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    $OPTIONS[<span class=\"string\">'out'</span>] = $videotitle;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"部署插件\"><a href=\"#部署插件\" class=\"headerlink\" title=\"部署插件\"></a>部署插件</h3><p>将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!!</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Expand-the-function-of-ocdownloader/downloadpage.png\" alt=\"下载页面\"></p>\n<h3 id=\"视频封面\"><a href=\"#视频封面\" class=\"headerlink\" title=\"视频封面\"></a>视频封面</h3><p>默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客<a href=\"https://www.allerstorfer.at/nextcloud-install-preview-generator/\" target=\"_blank\" rel=\"noopener\">Nextcloud: Install Preview Generator</a></p>\n"},{"title":"我的私人书签记录","date":"2019-06-28T01:46:34.000Z","_content":"\n\n\n\n\n保存一下工作中常用的网址\n\n\n\n**k8s**相关\n\n[k8s官网文档](<https://kubernetes.io/docs>)   [helm官方仓库](https://hub.helm.sh) [nginx-ingress 部署](https://kubernetes.github.io/ingress-nginx/deploy/)  [operator-framework](https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md)\n\n[ambassador](https://www.getambassador.io/)  [Istio文档](https://istio.io)\n\n**docker**相关\n\n[Docker官方文档](https://docs.docker.com/)   [Dockerfile文档](https://docs.docker.com/engine/reference/builder/)   [Docker官方仓库](https://hub.docker.com/)\n\n**常用镜像**地址\n\n[阿里云镜像](https://opsx.alibaba.com/mirror)  [清华镜像](https://mirrors.tuna.tsinghua.edu.cn/)  [中科大镜像](http://mirrors.ustc.edu.cn/)  [Azure中国镜像](http://mirror.azure.cn)\n\n","source":"_posts/My-personal-bookmarks.md","raw":"---\ntitle: 我的私人书签记录\ndate: 2019-06-28 09:46:34\ntags: kubernetes\n---\n\n\n\n\n\n保存一下工作中常用的网址\n\n\n\n**k8s**相关\n\n[k8s官网文档](<https://kubernetes.io/docs>)   [helm官方仓库](https://hub.helm.sh) [nginx-ingress 部署](https://kubernetes.github.io/ingress-nginx/deploy/)  [operator-framework](https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md)\n\n[ambassador](https://www.getambassador.io/)  [Istio文档](https://istio.io)\n\n**docker**相关\n\n[Docker官方文档](https://docs.docker.com/)   [Dockerfile文档](https://docs.docker.com/engine/reference/builder/)   [Docker官方仓库](https://hub.docker.com/)\n\n**常用镜像**地址\n\n[阿里云镜像](https://opsx.alibaba.com/mirror)  [清华镜像](https://mirrors.tuna.tsinghua.edu.cn/)  [中科大镜像](http://mirrors.ustc.edu.cn/)  [Azure中国镜像](http://mirror.azure.cn)\n\n","slug":"My-personal-bookmarks","published":1,"updated":"2019-08-16T05:46:28.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhg0001wrd7fk4w36lj","content":"<p>保存一下工作中常用的网址</p>\n<p><strong>k8s</strong>相关</p>\n<p><a href=\"https://kubernetes.io/docs\" target=\"_blank\" rel=\"noopener\">k8s官网文档</a>   <a href=\"https://hub.helm.sh\" target=\"_blank\" rel=\"noopener\">helm官方仓库</a> <a href=\"https://kubernetes.github.io/ingress-nginx/deploy/\" target=\"_blank\" rel=\"noopener\">nginx-ingress 部署</a>  <a href=\"https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md\" target=\"_blank\" rel=\"noopener\">operator-framework</a></p>\n<p><a href=\"https://www.getambassador.io/\" target=\"_blank\" rel=\"noopener\">ambassador</a>  <a href=\"https://istio.io\" target=\"_blank\" rel=\"noopener\">Istio文档</a></p>\n<p><strong>docker</strong>相关</p>\n<p><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官方文档</a>   <a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener\">Dockerfile文档</a>   <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官方仓库</a></p>\n<p><strong>常用镜像</strong>地址</p>\n<p><a href=\"https://opsx.alibaba.com/mirror\" target=\"_blank\" rel=\"noopener\">阿里云镜像</a>  <a href=\"https://mirrors.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">清华镜像</a>  <a href=\"http://mirrors.ustc.edu.cn/\" target=\"_blank\" rel=\"noopener\">中科大镜像</a>  <a href=\"http://mirror.azure.cn\" target=\"_blank\" rel=\"noopener\">Azure中国镜像</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>保存一下工作中常用的网址</p>\n<p><strong>k8s</strong>相关</p>\n<p><a href=\"https://kubernetes.io/docs\" target=\"_blank\" rel=\"noopener\">k8s官网文档</a>   <a href=\"https://hub.helm.sh\" target=\"_blank\" rel=\"noopener\">helm官方仓库</a> <a href=\"https://kubernetes.github.io/ingress-nginx/deploy/\" target=\"_blank\" rel=\"noopener\">nginx-ingress 部署</a>  <a href=\"https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md\" target=\"_blank\" rel=\"noopener\">operator-framework</a></p>\n<p><a href=\"https://www.getambassador.io/\" target=\"_blank\" rel=\"noopener\">ambassador</a>  <a href=\"https://istio.io\" target=\"_blank\" rel=\"noopener\">Istio文档</a></p>\n<p><strong>docker</strong>相关</p>\n<p><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官方文档</a>   <a href=\"https://docs.docker.com/engine/reference/builder/\" target=\"_blank\" rel=\"noopener\">Dockerfile文档</a>   <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker官方仓库</a></p>\n<p><strong>常用镜像</strong>地址</p>\n<p><a href=\"https://opsx.alibaba.com/mirror\" target=\"_blank\" rel=\"noopener\">阿里云镜像</a>  <a href=\"https://mirrors.tuna.tsinghua.edu.cn/\" target=\"_blank\" rel=\"noopener\">清华镜像</a>  <a href=\"http://mirrors.ustc.edu.cn/\" target=\"_blank\" rel=\"noopener\">中科大镜像</a>  <a href=\"http://mirror.azure.cn\" target=\"_blank\" rel=\"noopener\">Azure中国镜像</a></p>\n"},{"title":"利用阿里云的OSS将markdown中的本地路径的图片替换为网络图片","date":"2020-05-07T13:09:46.000Z","_content":"\n### 概述\n\n在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。\n\n常见的有下面的方法来解决这个问题:\n\n1. 将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。\n\n2. 如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件([点击这里](https://whisperchi.com/posts/62275/)查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。\n\n这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。\n\n> 我们可以参考[这篇博客](https://whisperchi.com/posts/35930/)，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。\n\n### 解决方案\n\n综上，我写了一个小工具[md-img-oss](https://github.com/lixiaofei123/md-img-oss)来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。\n如图，分别是替换前和替换后的效果\n\n![替换前](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png)\n\n![替换后](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png)\n\n### 安装md-img-oss\n\n安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装\n```bash\ngo get github.com/lixiaofei123/md-img-oss\n```\n如果本地没有golang环境，点击这里[附件:md-img-oss](https://github.com/lixiaofei123/md-img-oss/releases)下载对应平台的软件。\n\n### 使用\n\n安装完毕后，执行下面的命令，即可自动替换图片链接\n\n```bash\nmd-img-oss -mddir \"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\" -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId <替换成你的accesskeyId> -accessKeySecret <替换成你的accesskeySecret> -bucketName <替换成你的bucketName> -ossDir lixfio/image -domain https://static.huiyuanai.com\n# ossDir 和 domain 是非必须的，可以不需要\n```\n如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令\n\n也可以执行下面的命令查看各个参数的意思\n\n```bash\nmd-img-oss --help\n```\n\n下面是执行结果\n![执行结果](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png)\n\n","source":"_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures.md","raw":"---\ntitle: 利用阿里云的OSS将markdown中的本地路径的图片替换为网络图片\ndate: 2020-05-07 21:09:46\ncategories: 实用\ntags:\n  - markdown\n  - 图床\n---\n\n### 概述\n\n在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。\n\n常见的有下面的方法来解决这个问题:\n\n1. 将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。\n\n2. 如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件([点击这里](https://whisperchi.com/posts/62275/)查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。\n\n这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。\n\n> 我们可以参考[这篇博客](https://whisperchi.com/posts/35930/)，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。\n\n### 解决方案\n\n综上，我写了一个小工具[md-img-oss](https://github.com/lixiaofei123/md-img-oss)来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。\n如图，分别是替换前和替换后的效果\n\n![替换前](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png)\n\n![替换后](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png)\n\n### 安装md-img-oss\n\n安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装\n```bash\ngo get github.com/lixiaofei123/md-img-oss\n```\n如果本地没有golang环境，点击这里[附件:md-img-oss](https://github.com/lixiaofei123/md-img-oss/releases)下载对应平台的软件。\n\n### 使用\n\n安装完毕后，执行下面的命令，即可自动替换图片链接\n\n```bash\nmd-img-oss -mddir \"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\" -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId <替换成你的accesskeyId> -accessKeySecret <替换成你的accesskeySecret> -bucketName <替换成你的bucketName> -ossDir lixfio/image -domain https://static.huiyuanai.com\n# ossDir 和 domain 是非必须的，可以不需要\n```\n如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令\n\n也可以执行下面的命令查看各个参数的意思\n\n```bash\nmd-img-oss --help\n```\n\n下面是执行结果\n![执行结果](https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png)\n\n","slug":"Replace-the-local-path-pictures-in-markdown-with-network-pictures","published":1,"updated":"2020-05-08T07:47:12.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhl0004wrd76xj8pivi","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。</p>\n<p>常见的有下面的方法来解决这个问题:</p>\n<ol>\n<li><p>将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。</p>\n</li>\n<li><p>如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件(<a href=\"https://whisperchi.com/posts/62275/\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。</p>\n</li>\n</ol>\n<p>这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。</p>\n<blockquote>\n<p>我们可以参考<a href=\"https://whisperchi.com/posts/35930/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。</p>\n</blockquote>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>综上，我写了一个小工具<a href=\"https://github.com/lixiaofei123/md-img-oss\" target=\"_blank\" rel=\"noopener\">md-img-oss</a>来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。<br>如图，分别是替换前和替换后的效果</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png\" alt=\"替换前\"></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png\" alt=\"替换后\"></p>\n<h3 id=\"安装md-img-oss\"><a href=\"#安装md-img-oss\" class=\"headerlink\" title=\"安装md-img-oss\"></a>安装md-img-oss</h3><p>安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/lixiaofei123/md-img-oss</span><br></pre></td></tr></table></figure></p>\n<p>如果本地没有golang环境，点击这里<a href=\"https://github.com/lixiaofei123/md-img-oss/releases\" target=\"_blank\" rel=\"noopener\">附件:md-img-oss</a>下载对应平台的软件。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装完毕后，执行下面的命令，即可自动替换图片链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md-img-oss -mddir <span class=\"string\">\"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\"</span> -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId &lt;替换成你的accesskeyId&gt; -accessKeySecret &lt;替换成你的accesskeySecret&gt; -bucketName &lt;替换成你的bucketName&gt; -ossDir lixfio/image -domain https://static.huiyuanai.com</span><br><span class=\"line\"><span class=\"comment\"># ossDir 和 domain 是非必须的，可以不需要</span></span><br></pre></td></tr></table></figure>\n<p>如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令</p>\n<p>也可以执行下面的命令查看各个参数的意思</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md-img-oss --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<p>下面是执行结果<br><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png\" alt=\"执行结果\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。</p>\n<p>常见的有下面的方法来解决这个问题:</p>\n<ol>\n<li><p>将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。</p>\n</li>\n<li><p>如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件(<a href=\"https://whisperchi.com/posts/62275/\" target=\"_blank\" rel=\"noopener\">点击这里</a>查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。</p>\n</li>\n</ol>\n<p>这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。</p>\n<blockquote>\n<p>我们可以参考<a href=\"https://whisperchi.com/posts/35930/\" target=\"_blank\" rel=\"noopener\">这篇博客</a>，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。</p>\n</blockquote>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>综上，我写了一个小工具<a href=\"https://github.com/lixiaofei123/md-img-oss\" target=\"_blank\" rel=\"noopener\">md-img-oss</a>来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。<br>如图，分别是替换前和替换后的效果</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png\" alt=\"替换前\"></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png\" alt=\"替换后\"></p>\n<h3 id=\"安装md-img-oss\"><a href=\"#安装md-img-oss\" class=\"headerlink\" title=\"安装md-img-oss\"></a>安装md-img-oss</h3><p>安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/lixiaofei123/md-img-oss</span><br></pre></td></tr></table></figure></p>\n<p>如果本地没有golang环境，点击这里<a href=\"https://github.com/lixiaofei123/md-img-oss/releases\" target=\"_blank\" rel=\"noopener\">附件:md-img-oss</a>下载对应平台的软件。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装完毕后，执行下面的命令，即可自动替换图片链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md-img-oss -mddir <span class=\"string\">\"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\"</span> -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId &lt;替换成你的accesskeyId&gt; -accessKeySecret &lt;替换成你的accesskeySecret&gt; -bucketName &lt;替换成你的bucketName&gt; -ossDir lixfio/image -domain https://static.huiyuanai.com</span><br><span class=\"line\"><span class=\"comment\"># ossDir 和 domain 是非必须的，可以不需要</span></span><br></pre></td></tr></table></figure>\n<p>如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令</p>\n<p>也可以执行下面的命令查看各个参数的意思</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">md-img-oss --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<p>下面是执行结果<br><img src=\"https://static.huiyuanai.com/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png\" alt=\"执行结果\"></p>\n"},{"title":"GoLang 内存模型","date":"2019-09-20T07:34:41.000Z","_content":"\n\n\nGolang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。\n\n\n\n# Happens Before\n\n在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。\n\nHappens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。\n\n**在单线程中，*happens-before*的顺序和代码表达的顺序是一致的。**\n\n现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。\n\n1. 读操作r不happen before写操作w (有可能是并发发生)\n2. 没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生)\n\n如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。\n\n1. 写操作w happen before 读操作r\n2. 任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。\n\n\n\n# Synchronization\n\n## 初始化\n\n*如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前*\n\n> *If a package* `p` *imports package* `q`*, the completion of* `q`*'s* `init` *functions happens before the start of any of* `p`*'s.*\n\n**main方法happen after所有的init方法结束之后**\n\n> *The* `go` *statement that starts a new goroutine happens before the goroutine's execution begins.*\n\n\n\n## 协程创建\n\n\n\n\n\n*新启动一个协程happens before这个协程的执行*\n\n> *The* `go` *statement that starts a new goroutine happens before the goroutine's execution begins.*\n\n\n\n## 协程的销毁\n\n\n\n协程的结束不保证happen before于程序中的任何事件。\n\n> The exit of a goroutine is not guaranteed to happen before any event in the program\n\n\n\n例如下面这个例子\n\n```golang\nvar a string\n\nfunc hello() {\n\tgo func() { a = \"hello\" }()\n\tprint(a)\n}\n```\n\n\n\n对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果\n\n\n\n## channel 通信\n\n\n\ngolang里有一个很重要的思想*不要通过共享内存来通信，而是通过通信来共享内存*.\n\n> Don't communicate by sharing memory; share memory by communicating.\n\n对应channel，也有几条重要的happens-before规则\n\n\n\n对channel发送数据happens before于对于此channel相应的接收。\n\n>  A send on a channel happens before the corresponding receive from that channel completes.\n\n\n\n例如下面代码\n\n```golang\nvar c = make(chan int, 10)\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\tc <- 0\n}\n\nfunc main() {\n\tgo f()\n\t<-c\n\tprint(a)\n}\n```\n\n\n\n能够确保输出 \"hello world\"。　a=\"hello, world\" happens before c <- 0,c <- 0 happens before <-c，<-c happens before print(a)，根据happens-before的传递性，a=\"hello, world\" happens before print(a)。\n\n\n\n*关闭channel happens before 接收channel因关闭返回的０值*\n\n> The closing of a channel happens before a receive that returns a zero value because the channel is closed.\n\n\n\n*从一个没有缓冲的channel里接收值happens before向这个channel发送值*\n\n> A receive from an unbuffered channel happens before the send on that channel completes.\n\n\n\n这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。\n\n```golang\nvar c = make(chan int)\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\t<- c\n}\n\nfunc main() {\n\tgo f()\n\tc <- 0\n\tprint(a)\n}\n```\n\n\n\n*一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送*\n\n> The* *k**th receive on a channel with capacity* *C* *happens before the* *k**+**C**th send from that channel completes.\n\n\n\n例如下面这个例子，可以确保同时只有三个协程在执行w()\n\n```golang\nvar limit = make(chan int, 3)\n\nfunc main() {\n\tfor _, w := range work {\n\t\tgo func(w func()) {\n\t\t\tlimit <- 1\n\t\t\tw()\n\t\t\t<-limit\n\t\t}(w)\n\t}\n\tselect{}\n}\n```\n\n\n\n## Locks\n\n\n\n*对于sync.Mutex或者sync.RWMutex　变量，如果n < m，那么第n次解锁happens before与第m次加锁*\n\n> *For any* `sync.Mutex` *or* `sync.RWMutex` *variable* `l` *and* *n* *<* *m**, call* *n* *of* `l.Unlock()` *happens before call* *m* *of* `l.Lock()` *returns.*\n\n\n\n例如\n\n```golang\nvar l sync.Mutex\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\tl.Unlock()\n}\n\nfunc main() {\n\tl.Lock()\n\tgo f()\n\tl.Lock()\n\tprint(a)\n}\n```\n\n\n\n在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = \"hello, world\"　happens before　print(a)，因此可以确保输出\"hello, world\"\n\n\n\n> *For any call to* `l.RLock` *on a* `sync.RWMutex` *variable* `l`*, there is an* *n* *such that the* `l.RLock` *happens (returns) after call* *n* *to* `l.Unlock` *and the matching* `l.RUnlock` *happens before call* *n**+1 to* `l.Lock`*.*\n\n\n\n\n\n## Once\n\n\n\ngolang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。\n\n*once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。*\n\n> *A single call of* `f()` *from* `once.Do(f)` *happens (returns) before any call of* `once.Do(f)` *returns.*\n\n\n\n例如这个程序\n\n```\nvar a string\nvar once sync.Once\n\nfunc setup() {\n\ta = \"hello, world\"\n}\n\nfunc doprint() {\n\tonce.Do(setup)\n\tprint(a)\n}\n\nfunc twoprint() {\n\tgo doprint()\n\tgo doprint()\n}\n```\n\n\n\n# 不正确的同步\n\n\n在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。\n\n看下面的例子\n\n```golang\nvar a, b int\n\nfunc f() {\n\ta = 1\n\tb = 2\n}\n\nfunc g() {\n\tprint(b)\n\tprint(a)\n}\n\nfunc main() {\n\tgo f()\n\tg()\n}\n```\n\n\n\n上面输出的结果有可能是２　0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生）\n\n\n\n还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=\"hello, world\"，然后输出一个空字符串。\n\n```golang\nvar a string\nvar done bool\n\nfunc setup() {\n\ta = \"hello, world\"\n\tdone = true\n}\n\nfunc doprint() {\n\tif !done {\n\t\tonce.Do(setup)\n\t}\n\tprint(a)\n}\n\nfunc twoprint() {\n\tgo doprint()\n\tgo doprint()\n}\n```\n\n\n\n另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=\"hello, world\"，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。\n\n```golang\nvar a string\nvar done bool\n\nfunc setup() {\n\ta = \"hello, world\"\n\tdone = true\n}\n\nfunc main() {\n\tgo setup()\n\tfor !done {\n\t}\n\tprint(a)\n}\n```\n\n\n\n","source":"_posts/The-Go-Memory-Model.md","raw":"---\ntitle: GoLang 内存模型\ndate: 2019-09-20 15:34:41\ntags:  golang学习\n---\n\n\n\nGolang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。\n\n\n\n# Happens Before\n\n在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。\n\nHappens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。\n\n**在单线程中，*happens-before*的顺序和代码表达的顺序是一致的。**\n\n现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。\n\n1. 读操作r不happen before写操作w (有可能是并发发生)\n2. 没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生)\n\n如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。\n\n1. 写操作w happen before 读操作r\n2. 任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。\n\n\n\n# Synchronization\n\n## 初始化\n\n*如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前*\n\n> *If a package* `p` *imports package* `q`*, the completion of* `q`*'s* `init` *functions happens before the start of any of* `p`*'s.*\n\n**main方法happen after所有的init方法结束之后**\n\n> *The* `go` *statement that starts a new goroutine happens before the goroutine's execution begins.*\n\n\n\n## 协程创建\n\n\n\n\n\n*新启动一个协程happens before这个协程的执行*\n\n> *The* `go` *statement that starts a new goroutine happens before the goroutine's execution begins.*\n\n\n\n## 协程的销毁\n\n\n\n协程的结束不保证happen before于程序中的任何事件。\n\n> The exit of a goroutine is not guaranteed to happen before any event in the program\n\n\n\n例如下面这个例子\n\n```golang\nvar a string\n\nfunc hello() {\n\tgo func() { a = \"hello\" }()\n\tprint(a)\n}\n```\n\n\n\n对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果\n\n\n\n## channel 通信\n\n\n\ngolang里有一个很重要的思想*不要通过共享内存来通信，而是通过通信来共享内存*.\n\n> Don't communicate by sharing memory; share memory by communicating.\n\n对应channel，也有几条重要的happens-before规则\n\n\n\n对channel发送数据happens before于对于此channel相应的接收。\n\n>  A send on a channel happens before the corresponding receive from that channel completes.\n\n\n\n例如下面代码\n\n```golang\nvar c = make(chan int, 10)\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\tc <- 0\n}\n\nfunc main() {\n\tgo f()\n\t<-c\n\tprint(a)\n}\n```\n\n\n\n能够确保输出 \"hello world\"。　a=\"hello, world\" happens before c <- 0,c <- 0 happens before <-c，<-c happens before print(a)，根据happens-before的传递性，a=\"hello, world\" happens before print(a)。\n\n\n\n*关闭channel happens before 接收channel因关闭返回的０值*\n\n> The closing of a channel happens before a receive that returns a zero value because the channel is closed.\n\n\n\n*从一个没有缓冲的channel里接收值happens before向这个channel发送值*\n\n> A receive from an unbuffered channel happens before the send on that channel completes.\n\n\n\n这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。\n\n```golang\nvar c = make(chan int)\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\t<- c\n}\n\nfunc main() {\n\tgo f()\n\tc <- 0\n\tprint(a)\n}\n```\n\n\n\n*一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送*\n\n> The* *k**th receive on a channel with capacity* *C* *happens before the* *k**+**C**th send from that channel completes.\n\n\n\n例如下面这个例子，可以确保同时只有三个协程在执行w()\n\n```golang\nvar limit = make(chan int, 3)\n\nfunc main() {\n\tfor _, w := range work {\n\t\tgo func(w func()) {\n\t\t\tlimit <- 1\n\t\t\tw()\n\t\t\t<-limit\n\t\t}(w)\n\t}\n\tselect{}\n}\n```\n\n\n\n## Locks\n\n\n\n*对于sync.Mutex或者sync.RWMutex　变量，如果n < m，那么第n次解锁happens before与第m次加锁*\n\n> *For any* `sync.Mutex` *or* `sync.RWMutex` *variable* `l` *and* *n* *<* *m**, call* *n* *of* `l.Unlock()` *happens before call* *m* *of* `l.Lock()` *returns.*\n\n\n\n例如\n\n```golang\nvar l sync.Mutex\nvar a string\n\nfunc f() {\n\ta = \"hello, world\"\n\tl.Unlock()\n}\n\nfunc main() {\n\tl.Lock()\n\tgo f()\n\tl.Lock()\n\tprint(a)\n}\n```\n\n\n\n在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = \"hello, world\"　happens before　print(a)，因此可以确保输出\"hello, world\"\n\n\n\n> *For any call to* `l.RLock` *on a* `sync.RWMutex` *variable* `l`*, there is an* *n* *such that the* `l.RLock` *happens (returns) after call* *n* *to* `l.Unlock` *and the matching* `l.RUnlock` *happens before call* *n**+1 to* `l.Lock`*.*\n\n\n\n\n\n## Once\n\n\n\ngolang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。\n\n*once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。*\n\n> *A single call of* `f()` *from* `once.Do(f)` *happens (returns) before any call of* `once.Do(f)` *returns.*\n\n\n\n例如这个程序\n\n```\nvar a string\nvar once sync.Once\n\nfunc setup() {\n\ta = \"hello, world\"\n}\n\nfunc doprint() {\n\tonce.Do(setup)\n\tprint(a)\n}\n\nfunc twoprint() {\n\tgo doprint()\n\tgo doprint()\n}\n```\n\n\n\n# 不正确的同步\n\n\n在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。\n\n看下面的例子\n\n```golang\nvar a, b int\n\nfunc f() {\n\ta = 1\n\tb = 2\n}\n\nfunc g() {\n\tprint(b)\n\tprint(a)\n}\n\nfunc main() {\n\tgo f()\n\tg()\n}\n```\n\n\n\n上面输出的结果有可能是２　0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生）\n\n\n\n还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=\"hello, world\"，然后输出一个空字符串。\n\n```golang\nvar a string\nvar done bool\n\nfunc setup() {\n\ta = \"hello, world\"\n\tdone = true\n}\n\nfunc doprint() {\n\tif !done {\n\t\tonce.Do(setup)\n\t}\n\tprint(a)\n}\n\nfunc twoprint() {\n\tgo doprint()\n\tgo doprint()\n}\n```\n\n\n\n另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=\"hello, world\"，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。\n\n```golang\nvar a string\nvar done bool\n\nfunc setup() {\n\ta = \"hello, world\"\n\tdone = true\n}\n\nfunc main() {\n\tgo setup()\n\tfor !done {\n\t}\n\tprint(a)\n}\n```\n\n\n\n","slug":"The-Go-Memory-Model","published":1,"updated":"2019-09-20T10:43:56.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhn0005wrd7upk0tnp4","content":"<p>Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。</p>\n<h1 id=\"Happens-Before\"><a href=\"#Happens-Before\" class=\"headerlink\" title=\"Happens Before\"></a>Happens Before</h1><p>在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。</p>\n<p>Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。</p>\n<p><strong>在单线程中，<em>happens-before</em>的顺序和代码表达的顺序是一致的。</strong></p>\n<p>现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。</p>\n<ol>\n<li>读操作r不happen before写操作w (有可能是并发发生)</li>\n<li>没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生)</li>\n</ol>\n<p>如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。</p>\n<ol>\n<li>写操作w happen before 读操作r</li>\n<li>任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。</li>\n</ol>\n<h1 id=\"Synchronization\"><a href=\"#Synchronization\" class=\"headerlink\" title=\"Synchronization\"></a>Synchronization</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><em>如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前</em></p>\n<blockquote>\n<p><em>If a package</em> <code>p</code> <em>imports package</em> <code>q</code><em>, the completion of</em> <code>q</code><em>‘s</em> <code>init</code> <em>functions happens before the start of any of</em> <code>p</code><em>‘s.</em></p>\n</blockquote>\n<p><strong>main方法happen after所有的init方法结束之后</strong></p>\n<blockquote>\n<p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p>\n</blockquote>\n<h2 id=\"协程创建\"><a href=\"#协程创建\" class=\"headerlink\" title=\"协程创建\"></a>协程创建</h2><p><em>新启动一个协程happens before这个协程的执行</em></p>\n<blockquote>\n<p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p>\n</blockquote>\n<h2 id=\"协程的销毁\"><a href=\"#协程的销毁\" class=\"headerlink\" title=\"协程的销毁\"></a>协程的销毁</h2><p>协程的结束不保证happen before于程序中的任何事件。</p>\n<blockquote>\n<p>The exit of a goroutine is not guaranteed to happen before any event in the program</p>\n</blockquote>\n<p>例如下面这个例子</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; a = <span class=\"string\">\"hello\"</span> &#125;()</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果</p>\n<h2 id=\"channel-通信\"><a href=\"#channel-通信\" class=\"headerlink\" title=\"channel 通信\"></a>channel 通信</h2><p>golang里有一个很重要的思想<em>不要通过共享内存来通信，而是通过通信来共享内存</em>.</p>\n<blockquote>\n<p>Don’t communicate by sharing memory; share memory by communicating.</p>\n</blockquote>\n<p>对应channel，也有几条重要的happens-before规则</p>\n<p>对channel发送数据happens before于对于此channel相应的接收。</p>\n<blockquote>\n<p> A send on a channel happens before the corresponding receive from that channel completes.</p>\n</blockquote>\n<p>例如下面代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tc &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\t&lt;-c</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>能够确保输出 “hello world”。　a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。</p>\n<p><em>关闭channel happens before 接收channel因关闭返回的０值</em></p>\n<blockquote>\n<p>The closing of a channel happens before a receive that returns a zero value because the channel is closed.</p>\n</blockquote>\n<p><em>从一个没有缓冲的channel里接收值happens before向这个channel发送值</em></p>\n<blockquote>\n<p>A receive from an unbuffered channel happens before the send on that channel completes.</p>\n</blockquote>\n<p>这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\t&lt;- c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tc &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送</em></p>\n<blockquote>\n<p>The<em> </em>k<strong>th receive on a channel with capacity<em> </em>C<em> </em>happens before the<em> </em>k</strong>+<strong>C</strong>th send from that channel completes.</p>\n</blockquote>\n<p>例如下面这个例子，可以确保同时只有三个协程在执行w()</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> limit = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w <span class=\"keyword\">func</span>()</span>)</span> &#123;</span><br><span class=\"line\">\t\t\tlimit &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\tw()</span><br><span class=\"line\">\t\t\t&lt;-limit</span><br><span class=\"line\">\t\t&#125;(w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Locks\"><a href=\"#Locks\" class=\"headerlink\" title=\"Locks\"></a>Locks</h2><p><em>对于sync.Mutex或者sync.RWMutex　变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁</em></p>\n<blockquote>\n<p><em>For any</em> <code>sync.Mutex</code> <em>or</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code> <em>and</em> <em>n</em> <em>&lt;</em> <em>m**, call</em> <em>n</em> <em>of</em> <code>l.Unlock()</code> <em>happens before call</em> <em>m</em> <em>of</em> <code>l.Lock()</code> <em>returns.</em></p>\n</blockquote>\n<p>例如</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> l sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tl.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tl.Lock()</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world”　happens before　print(a)，因此可以确保输出”hello, world”</p>\n<blockquote>\n<p><em>For any call to</em> <code>l.RLock</code> <em>on a</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code><em>, there is an</em> <em>n</em> <em>such that the</em> <code>l.RLock</code> <em>happens (returns) after call</em> <em>n</em> <em>to</em> <code>l.Unlock</code> <em>and the matching</em> <code>l.RUnlock</code> <em>happens before call</em> <em>n**+1 to</em> <code>l.Lock</code><em>.</em></p>\n</blockquote>\n<h2 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h2><p>golang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。</p>\n<p><em>once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。</em></p>\n<blockquote>\n<p><em>A single call of</em> <code>f()</code> <em>from</em> <code>once.Do(f)</code> <em>happens (returns) before any call of</em> <code>once.Do(f)</code> <em>returns.</em></p>\n</blockquote>\n<p>例如这个程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a string</span><br><span class=\"line\">var once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">func setup() &#123;</span><br><span class=\"line\">\ta = &quot;hello, world&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func doprint() &#123;</span><br><span class=\"line\">\tonce.Do(setup)</span><br><span class=\"line\">\tprint(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func twoprint() &#123;</span><br><span class=\"line\">\tgo doprint()</span><br><span class=\"line\">\tgo doprint()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"不正确的同步\"><a href=\"#不正确的同步\" class=\"headerlink\" title=\"不正确的同步\"></a>不正确的同步</h1><p>在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。</p>\n<p>看下面的例子</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1</span></span><br><span class=\"line\">\tb = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tg()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面输出的结果有可能是２　0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生）</p>\n<p>还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doprint</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !done &#123;</span><br><span class=\"line\">\t\tonce.Do(setup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoprint</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> setup()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !done &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。</p>\n<h1 id=\"Happens-Before\"><a href=\"#Happens-Before\" class=\"headerlink\" title=\"Happens Before\"></a>Happens Before</h1><p>在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。</p>\n<p>Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。</p>\n<p><strong>在单线程中，<em>happens-before</em>的顺序和代码表达的顺序是一致的。</strong></p>\n<p>现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。</p>\n<ol>\n<li>读操作r不happen before写操作w (有可能是并发发生)</li>\n<li>没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生)</li>\n</ol>\n<p>如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。</p>\n<ol>\n<li>写操作w happen before 读操作r</li>\n<li>任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。</li>\n</ol>\n<h1 id=\"Synchronization\"><a href=\"#Synchronization\" class=\"headerlink\" title=\"Synchronization\"></a>Synchronization</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><em>如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前</em></p>\n<blockquote>\n<p><em>If a package</em> <code>p</code> <em>imports package</em> <code>q</code><em>, the completion of</em> <code>q</code><em>‘s</em> <code>init</code> <em>functions happens before the start of any of</em> <code>p</code><em>‘s.</em></p>\n</blockquote>\n<p><strong>main方法happen after所有的init方法结束之后</strong></p>\n<blockquote>\n<p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p>\n</blockquote>\n<h2 id=\"协程创建\"><a href=\"#协程创建\" class=\"headerlink\" title=\"协程创建\"></a>协程创建</h2><p><em>新启动一个协程happens before这个协程的执行</em></p>\n<blockquote>\n<p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p>\n</blockquote>\n<h2 id=\"协程的销毁\"><a href=\"#协程的销毁\" class=\"headerlink\" title=\"协程的销毁\"></a>协程的销毁</h2><p>协程的结束不保证happen before于程序中的任何事件。</p>\n<blockquote>\n<p>The exit of a goroutine is not guaranteed to happen before any event in the program</p>\n</blockquote>\n<p>例如下面这个例子</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; a = <span class=\"string\">\"hello\"</span> &#125;()</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果</p>\n<h2 id=\"channel-通信\"><a href=\"#channel-通信\" class=\"headerlink\" title=\"channel 通信\"></a>channel 通信</h2><p>golang里有一个很重要的思想<em>不要通过共享内存来通信，而是通过通信来共享内存</em>.</p>\n<blockquote>\n<p>Don’t communicate by sharing memory; share memory by communicating.</p>\n</blockquote>\n<p>对应channel，也有几条重要的happens-before规则</p>\n<p>对channel发送数据happens before于对于此channel相应的接收。</p>\n<blockquote>\n<p> A send on a channel happens before the corresponding receive from that channel completes.</p>\n</blockquote>\n<p>例如下面代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tc &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\t&lt;-c</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>能够确保输出 “hello world”。　a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。</p>\n<p><em>关闭channel happens before 接收channel因关闭返回的０值</em></p>\n<blockquote>\n<p>The closing of a channel happens before a receive that returns a zero value because the channel is closed.</p>\n</blockquote>\n<p><em>从一个没有缓冲的channel里接收值happens before向这个channel发送值</em></p>\n<blockquote>\n<p>A receive from an unbuffered channel happens before the send on that channel completes.</p>\n</blockquote>\n<p>这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\t&lt;- c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tc &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送</em></p>\n<blockquote>\n<p>The<em> </em>k<strong>th receive on a channel with capacity<em> </em>C<em> </em>happens before the<em> </em>k</strong>+<strong>C</strong>th send from that channel completes.</p>\n</blockquote>\n<p>例如下面这个例子，可以确保同时只有三个协程在执行w()</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> limit = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> work &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w <span class=\"keyword\">func</span>()</span>)</span> &#123;</span><br><span class=\"line\">\t\t\tlimit &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\tw()</span><br><span class=\"line\">\t\t\t&lt;-limit</span><br><span class=\"line\">\t\t&#125;(w)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Locks\"><a href=\"#Locks\" class=\"headerlink\" title=\"Locks\"></a>Locks</h2><p><em>对于sync.Mutex或者sync.RWMutex　变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁</em></p>\n<blockquote>\n<p><em>For any</em> <code>sync.Mutex</code> <em>or</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code> <em>and</em> <em>n</em> <em>&lt;</em> <em>m**, call</em> <em>n</em> <em>of</em> <code>l.Unlock()</code> <em>happens before call</em> <em>m</em> <em>of</em> <code>l.Lock()</code> <em>returns.</em></p>\n</blockquote>\n<p>例如</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> l sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tl.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tl.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tl.Lock()</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world”　happens before　print(a)，因此可以确保输出”hello, world”</p>\n<blockquote>\n<p><em>For any call to</em> <code>l.RLock</code> <em>on a</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code><em>, there is an</em> <em>n</em> <em>such that the</em> <code>l.RLock</code> <em>happens (returns) after call</em> <em>n</em> <em>to</em> <code>l.Unlock</code> <em>and the matching</em> <code>l.RUnlock</code> <em>happens before call</em> <em>n**+1 to</em> <code>l.Lock</code><em>.</em></p>\n</blockquote>\n<h2 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h2><p>golang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。</p>\n<p><em>once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。</em></p>\n<blockquote>\n<p><em>A single call of</em> <code>f()</code> <em>from</em> <code>once.Do(f)</code> <em>happens (returns) before any call of</em> <code>once.Do(f)</code> <em>returns.</em></p>\n</blockquote>\n<p>例如这个程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a string</span><br><span class=\"line\">var once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">func setup() &#123;</span><br><span class=\"line\">\ta = &quot;hello, world&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func doprint() &#123;</span><br><span class=\"line\">\tonce.Do(setup)</span><br><span class=\"line\">\tprint(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func twoprint() &#123;</span><br><span class=\"line\">\tgo doprint()</span><br><span class=\"line\">\tgo doprint()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"不正确的同步\"><a href=\"#不正确的同步\" class=\"headerlink\" title=\"不正确的同步\"></a>不正确的同步</h1><p>在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。</p>\n<p>看下面的例子</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a, b <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"number\">1</span></span><br><span class=\"line\">\tb = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> f()</span><br><span class=\"line\">\tg()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面输出的结果有可能是２　0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生）</p>\n<p>还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doprint</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !done &#123;</span><br><span class=\"line\">\t\tonce.Do(setup)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoprint</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> doprint()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> done <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setup</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta = <span class=\"string\">\"hello, world\"</span></span><br><span class=\"line\">\tdone = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> setup()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> !done &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"将网页转换成本地应用程序","date":"2019-08-14T06:05:37.000Z","_content":"\n\n\n\n\n微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。\n\n\n\n这里使用在线制作的方式\n\n打开网址 https://appmaker.xyz/web2desk ，如下图\n\n![](https://static.huiyuanai.com/lixfio/image/create-native-app-from-web-url/appmaker.png)\n\n\n\n根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。\n\n> 邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。\n\n\n\n然后根据我前面的[ubuntu制作桌面图标](<https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/>)制作成桌面图标就好\n\n\n\n","source":"_posts/create-native-app-from-web-url.md","raw":"---\ntitle: 将网页转换成本地应用程序\ndate: 2019-08-14 14:05:37\ncategories: 实用\ntags: \n  - ubuntu\n---\n\n\n\n\n\n微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。\n\n\n\n这里使用在线制作的方式\n\n打开网址 https://appmaker.xyz/web2desk ，如下图\n\n![](https://static.huiyuanai.com/lixfio/image/create-native-app-from-web-url/appmaker.png)\n\n\n\n根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。\n\n> 邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。\n\n\n\n然后根据我前面的[ubuntu制作桌面图标](<https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/>)制作成桌面图标就好\n\n\n\n","slug":"create-native-app-from-web-url","published":1,"updated":"2020-05-08T01:34:46.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhp0006wrd70cktc552","content":"<p>微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。</p>\n<p>这里使用在线制作的方式</p>\n<p>打开网址 <a href=\"https://appmaker.xyz/web2desk\" target=\"_blank\" rel=\"noopener\">https://appmaker.xyz/web2desk</a> ，如下图</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/create-native-app-from-web-url/appmaker.png\" alt></p>\n<p>根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。</p>\n<blockquote>\n<p>邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。</p>\n</blockquote>\n<p>然后根据我前面的<a href=\"https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/\">ubuntu制作桌面图标</a>制作成桌面图标就好</p>\n","site":{"data":{}},"excerpt":"","more":"<p>微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。</p>\n<p>这里使用在线制作的方式</p>\n<p>打开网址 <a href=\"https://appmaker.xyz/web2desk\" target=\"_blank\" rel=\"noopener\">https://appmaker.xyz/web2desk</a> ，如下图</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/create-native-app-from-web-url/appmaker.png\" alt></p>\n<p>根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。</p>\n<blockquote>\n<p>邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。</p>\n</blockquote>\n<p>然后根据我前面的<a href=\"https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/\">ubuntu制作桌面图标</a>制作成桌面图标就好</p>\n"},{"title":"docker下载镜像的时候出现handshake failure","date":"2019-06-13T11:38:59.000Z","_content":"\n\n\n\n\n在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误\n\n```log\nError response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure\n```\n\n\n\n在pod所运行的服务器上执行curl https://www.baidu.com也报了下面的错误\n\n\n\n```log\n[root@k8s-master ~]# curl https://www.baidu.com\ncurl: (60) Peer's Certificate issuer is not recognized.\nMore details here: http://curl.haxx.se/docs/sslcerts.html\n\ncurl performs SSL certificate verification by default, using a \"bundle\"\n of Certificate Authority (CA) public keys (CA certs). If the default\n bundle file isn't adequate, you can specify an alternate file\n using the --cacert option.\nIf this HTTPS server uses a certificate signed by a CA represented in\n the bundle, the certificate verification probably failed due to a\n problem with the certificate (it might be expired, or the name might\n not match the domain name in the URL).\nIf you'd like to turn off curl's verification of the certificate, use\n the -k (or --insecure) option.\n```\n\n\n\n在**stackoverflow**上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。\n\n```bash\nntpdate ntp1.aliyun.com\n```\n\n同步之后问题解决。\n\n当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。\n\n\n\n为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下）\n\n```bash\ncrontab -e\n```\n\n\n\n在里面加上这么一行命令,让每隔1分钟同步一下时间。\n\n```bash\n*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com > /dev/null 2>&1; /sbin/hwclock -w\n```\n\n","source":"_posts/docker-pull-remote-error-tls-handshake-failure.md","raw":"---\ntitle: docker下载镜像的时候出现handshake failure\ndate: 2019-06-13 19:38:59\ncategories: kubernetes\ntags: \n  - kubernetes\n  - docker\n---\n\n\n\n\n\n在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误\n\n```log\nError response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure\n```\n\n\n\n在pod所运行的服务器上执行curl https://www.baidu.com也报了下面的错误\n\n\n\n```log\n[root@k8s-master ~]# curl https://www.baidu.com\ncurl: (60) Peer's Certificate issuer is not recognized.\nMore details here: http://curl.haxx.se/docs/sslcerts.html\n\ncurl performs SSL certificate verification by default, using a \"bundle\"\n of Certificate Authority (CA) public keys (CA certs). If the default\n bundle file isn't adequate, you can specify an alternate file\n using the --cacert option.\nIf this HTTPS server uses a certificate signed by a CA represented in\n the bundle, the certificate verification probably failed due to a\n problem with the certificate (it might be expired, or the name might\n not match the domain name in the URL).\nIf you'd like to turn off curl's verification of the certificate, use\n the -k (or --insecure) option.\n```\n\n\n\n在**stackoverflow**上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。\n\n```bash\nntpdate ntp1.aliyun.com\n```\n\n同步之后问题解决。\n\n当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。\n\n\n\n为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下）\n\n```bash\ncrontab -e\n```\n\n\n\n在里面加上这么一行命令,让每隔1分钟同步一下时间。\n\n```bash\n*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com > /dev/null 2>&1; /sbin/hwclock -w\n```\n\n","slug":"docker-pull-remote-error-tls-handshake-failure","published":1,"updated":"2019-06-14T01:54:43.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerht0009wrd77njad10o","content":"<p>在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure</span><br></pre></td></tr></table></figure>\n<p>在pod所运行的服务器上执行curl <a href=\"https://www.baidu.com也报了下面的错误\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com也报了下面的错误</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@k8s-master ~]# curl https://www.baidu.com</span><br><span class=\"line\">curl: (60) Peer&apos;s Certificate issuer is not recognized.</span><br><span class=\"line\">More details here: http://curl.haxx.se/docs/sslcerts.html</span><br><span class=\"line\"></span><br><span class=\"line\">curl performs SSL certificate verification by default, using a &quot;bundle&quot;</span><br><span class=\"line\"> of Certificate Authority (CA) public keys (CA certs). If the default</span><br><span class=\"line\"> bundle file isn&apos;t adequate, you can specify an alternate file</span><br><span class=\"line\"> using the --cacert option.</span><br><span class=\"line\">If this HTTPS server uses a certificate signed by a CA represented in</span><br><span class=\"line\"> the bundle, the certificate verification probably failed due to a</span><br><span class=\"line\"> problem with the certificate (it might be expired, or the name might</span><br><span class=\"line\"> not match the domain name in the URL).</span><br><span class=\"line\">If you&apos;d like to turn off curl&apos;s verification of the certificate, use</span><br><span class=\"line\"> the -k (or --insecure) option.</span><br></pre></td></tr></table></figure>\n<p>在<strong>stackoverflow</strong>上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>\n<p>同步之后问题解决。</p>\n<p>当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。</p>\n<p>为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br></pre></td></tr></table></figure>\n<p>在里面加上这么一行命令,让每隔1分钟同步一下时间。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure</span><br></pre></td></tr></table></figure>\n<p>在pod所运行的服务器上执行curl <a href=\"https://www.baidu.com也报了下面的错误\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com也报了下面的错误</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@k8s-master ~]# curl https://www.baidu.com</span><br><span class=\"line\">curl: (60) Peer&apos;s Certificate issuer is not recognized.</span><br><span class=\"line\">More details here: http://curl.haxx.se/docs/sslcerts.html</span><br><span class=\"line\"></span><br><span class=\"line\">curl performs SSL certificate verification by default, using a &quot;bundle&quot;</span><br><span class=\"line\"> of Certificate Authority (CA) public keys (CA certs). If the default</span><br><span class=\"line\"> bundle file isn&apos;t adequate, you can specify an alternate file</span><br><span class=\"line\"> using the --cacert option.</span><br><span class=\"line\">If this HTTPS server uses a certificate signed by a CA represented in</span><br><span class=\"line\"> the bundle, the certificate verification probably failed due to a</span><br><span class=\"line\"> problem with the certificate (it might be expired, or the name might</span><br><span class=\"line\"> not match the domain name in the URL).</span><br><span class=\"line\">If you&apos;d like to turn off curl&apos;s verification of the certificate, use</span><br><span class=\"line\"> the -k (or --insecure) option.</span><br></pre></td></tr></table></figure>\n<p>在<strong>stackoverflow</strong>上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>\n<p>同步之后问题解决。</p>\n<p>当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。</p>\n<p>为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e</span><br></pre></td></tr></table></figure>\n<p>在里面加上这么一行命令,让每隔1分钟同步一下时间。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w</span><br></pre></td></tr></table></figure>\n"},{"title":"k8s相关镜像源整理","date":"2019-06-13T03:30:32.000Z","_content":"\n\n\n\n\n\n\n\n\n<span style='color:red'>*现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代*</span>\n\ngcr.io ==> registry.aliyuncs.com\n\nk8s.gcr.io ==> registry.aliyuncs.com/google-containers\n\nquay.io ==> quay-mirror.qiniu.com\n\n\n\n在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源\n\n\n\n## gcr.io、k8s.gcr.io镜像加速\n\ngcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用**Azure中国镜像**\n\ngcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn\n\n例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取\n\n```bash\ndocker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1\n```\n\n\n\n对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers\n\n例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取\n\n````bash\ndocker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4\n````\n\n\n\n##  quay.io镜像加速\n\n有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用**Azure中国镜像**来加快拉取速度\n\nquay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn\n\n例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取\n\n```bash\ndocker pull quay.azk8s.cn/dexidp/dex:v2.10.0\n```\n\n\n\n\n\n补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速\n\n例如\n\n```bash\ndocker pull dockerhub.azk8s.cn/library/nginx\n```\n\n\n\n\n\n## helm镜像仓库\n\n**Azure中国** 对于helm也提供了国内的镜像地址\n\n如果是新安装的helm,可以使用下面的命令进行初始化\n\n```bash\nhelm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/\n```\n\n\n\n对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库\n\n```bash\nhelm repo remove stable\nhelm repo add stable http://mirror.azure.cn/kubernetes/charts/\nhelm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/\nhelm repo update\nhelm repo list\n\n```\n\n\n\n\n\n除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址\n\n\n\n\n\n","source":"_posts/k8s-docker-images-mirrors.md","raw":"---\ntitle: k8s相关镜像源整理\ndate: 2019-06-13 11:30:32\ncategories: kubernetes\ntags: \n  - k8s\n  - docker\n  - helm\n---\n\n\n\n\n\n\n\n\n\n<span style='color:red'>*现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代*</span>\n\ngcr.io ==> registry.aliyuncs.com\n\nk8s.gcr.io ==> registry.aliyuncs.com/google-containers\n\nquay.io ==> quay-mirror.qiniu.com\n\n\n\n在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源\n\n\n\n## gcr.io、k8s.gcr.io镜像加速\n\ngcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用**Azure中国镜像**\n\ngcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn\n\n例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取\n\n```bash\ndocker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1\n```\n\n\n\n对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers\n\n例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取\n\n````bash\ndocker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4\n````\n\n\n\n##  quay.io镜像加速\n\n有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用**Azure中国镜像**来加快拉取速度\n\nquay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn\n\n例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取\n\n```bash\ndocker pull quay.azk8s.cn/dexidp/dex:v2.10.0\n```\n\n\n\n\n\n补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速\n\n例如\n\n```bash\ndocker pull dockerhub.azk8s.cn/library/nginx\n```\n\n\n\n\n\n## helm镜像仓库\n\n**Azure中国** 对于helm也提供了国内的镜像地址\n\n如果是新安装的helm,可以使用下面的命令进行初始化\n\n```bash\nhelm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/\n```\n\n\n\n对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库\n\n```bash\nhelm repo remove stable\nhelm repo add stable http://mirror.azure.cn/kubernetes/charts/\nhelm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/\nhelm repo update\nhelm repo list\n\n```\n\n\n\n\n\n除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址\n\n\n\n\n\n","slug":"k8s-docker-images-mirrors","published":1,"updated":"2020-04-15T07:18:35.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhv000awrd7xwqoto3p","content":"<p><span style=\"color:red\"><em>现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代</em></span></p>\n<p>gcr.io ==&gt; registry.aliyuncs.com</p>\n<p>k8s.gcr.io ==&gt; registry.aliyuncs.com/google-containers</p>\n<p>quay.io ==&gt; quay-mirror.qiniu.com</p>\n<p>在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源</p>\n<h2 id=\"gcr-io、k8s-gcr-io镜像加速\"><a href=\"#gcr-io、k8s-gcr-io镜像加速\" class=\"headerlink\" title=\"gcr.io、k8s.gcr.io镜像加速\"></a>gcr.io、k8s.gcr.io镜像加速</h2><p>gcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用<strong>Azure中国镜像</strong></p>\n<p>gcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn</p>\n<p>例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1</span><br></pre></td></tr></table></figure>\n<p>对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers</p>\n<p>例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4</span><br></pre></td></tr></table></figure>\n<h2 id=\"quay-io镜像加速\"><a href=\"#quay-io镜像加速\" class=\"headerlink\" title=\"quay.io镜像加速\"></a>quay.io镜像加速</h2><p>有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用<strong>Azure中国镜像</strong>来加快拉取速度</p>\n<p>quay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn</p>\n<p>例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull quay.azk8s.cn/dexidp/dex:v2.10.0</span><br></pre></td></tr></table></figure>\n<p>补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速</p>\n<p>例如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull dockerhub.azk8s.cn/library/nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"helm镜像仓库\"><a href=\"#helm镜像仓库\" class=\"headerlink\" title=\"helm镜像仓库\"></a>helm镜像仓库</h2><p><strong>Azure中国</strong> 对于helm也提供了国内的镜像地址</p>\n<p>如果是新安装的helm,可以使用下面的命令进行初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/</span><br></pre></td></tr></table></figure>\n<p>对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo remove stable</span><br><span class=\"line\">helm repo add stable http://mirror.azure.cn/kubernetes/charts/</span><br><span class=\"line\">helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/</span><br><span class=\"line\">helm repo update</span><br><span class=\"line\">helm repo list</span><br></pre></td></tr></table></figure>\n<p>除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址</p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color:red\"><em>现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代</em></span></p>\n<p>gcr.io ==&gt; registry.aliyuncs.com</p>\n<p>k8s.gcr.io ==&gt; registry.aliyuncs.com/google-containers</p>\n<p>quay.io ==&gt; quay-mirror.qiniu.com</p>\n<p>在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源</p>\n<h2 id=\"gcr-io、k8s-gcr-io镜像加速\"><a href=\"#gcr-io、k8s-gcr-io镜像加速\" class=\"headerlink\" title=\"gcr.io、k8s.gcr.io镜像加速\"></a>gcr.io、k8s.gcr.io镜像加速</h2><p>gcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用<strong>Azure中国镜像</strong></p>\n<p>gcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn</p>\n<p>例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1</span><br></pre></td></tr></table></figure>\n<p>对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers</p>\n<p>例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4</span><br></pre></td></tr></table></figure>\n<h2 id=\"quay-io镜像加速\"><a href=\"#quay-io镜像加速\" class=\"headerlink\" title=\"quay.io镜像加速\"></a>quay.io镜像加速</h2><p>有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用<strong>Azure中国镜像</strong>来加快拉取速度</p>\n<p>quay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn</p>\n<p>例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull quay.azk8s.cn/dexidp/dex:v2.10.0</span><br></pre></td></tr></table></figure>\n<p>补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速</p>\n<p>例如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull dockerhub.azk8s.cn/library/nginx</span><br></pre></td></tr></table></figure>\n<h2 id=\"helm镜像仓库\"><a href=\"#helm镜像仓库\" class=\"headerlink\" title=\"helm镜像仓库\"></a>helm镜像仓库</h2><p><strong>Azure中国</strong> 对于helm也提供了国内的镜像地址</p>\n<p>如果是新安装的helm,可以使用下面的命令进行初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/</span><br></pre></td></tr></table></figure>\n<p>对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo remove stable</span><br><span class=\"line\">helm repo add stable http://mirror.azure.cn/kubernetes/charts/</span><br><span class=\"line\">helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/</span><br><span class=\"line\">helm repo update</span><br><span class=\"line\">helm repo list</span><br></pre></td></tr></table></figure>\n<p>除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址</p>\n"},{"title":"MYSQL创建数据库和用户","date":"2019-05-07T12:49:24.000Z","_content":"\n### 创建UTF-8编码的数据库\n\n```mysql\ncreate database testbase default character set utf8 collate utf8_general_ci;\n```\n\n### 创建用户\n\n```mysql\ncreate user 'testuser'@'%' identified by 'password';\n```\n\n创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录\n\n### 授权数据库给用户\n\n```mysql\ngrant select,insert,update,delete,create,drop on test.* to testuser;\n```\n\n授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作\n\n### 刷新权限\n\n```mysql\nflush  privileges\n```\n\n### 取消授权\n\n```mysql\nrevoke all on *.* from testuser\n```\n\n### 删除用户\n\n```mysql\ndelete from mysql.user where user='testuser'\n```\n\n\n\n","source":"_posts/mysql-create-user.md","raw":"---\ntitle: MYSQL创建数据库和用户\ndate: 2019-05-07 20:49:24\ntags: mysql\n---\n\n### 创建UTF-8编码的数据库\n\n```mysql\ncreate database testbase default character set utf8 collate utf8_general_ci;\n```\n\n### 创建用户\n\n```mysql\ncreate user 'testuser'@'%' identified by 'password';\n```\n\n创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录\n\n### 授权数据库给用户\n\n```mysql\ngrant select,insert,update,delete,create,drop on test.* to testuser;\n```\n\n授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作\n\n### 刷新权限\n\n```mysql\nflush  privileges\n```\n\n### 取消授权\n\n```mysql\nrevoke all on *.* from testuser\n```\n\n### 删除用户\n\n```mysql\ndelete from mysql.user where user='testuser'\n```\n\n\n\n","slug":"mysql-create-user","published":1,"updated":"2019-05-16T02:09:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhw000ewrd7vttad0l9","content":"<h3 id=\"创建UTF-8编码的数据库\"><a href=\"#创建UTF-8编码的数据库\" class=\"headerlink\" title=\"创建UTF-8编码的数据库\"></a>创建UTF-8编码的数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database testbase default character set utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user &apos;testuser&apos;@&apos;%&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure>\n<p>创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录</p>\n<h3 id=\"授权数据库给用户\"><a href=\"#授权数据库给用户\" class=\"headerlink\" title=\"授权数据库给用户\"></a>授权数据库给用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant select,insert,update,delete,create,drop on test.* to testuser;</span><br></pre></td></tr></table></figure>\n<p>授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作</p>\n<h3 id=\"刷新权限\"><a href=\"#刷新权限\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush  privileges</span><br></pre></td></tr></table></figure>\n<h3 id=\"取消授权\"><a href=\"#取消授权\" class=\"headerlink\" title=\"取消授权\"></a>取消授权</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revoke all on *.* from testuser</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from mysql.user where user=&apos;testuser&apos;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"创建UTF-8编码的数据库\"><a href=\"#创建UTF-8编码的数据库\" class=\"headerlink\" title=\"创建UTF-8编码的数据库\"></a>创建UTF-8编码的数据库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create database testbase default character set utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create user &apos;testuser&apos;@&apos;%&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure>\n<p>创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录</p>\n<h3 id=\"授权数据库给用户\"><a href=\"#授权数据库给用户\" class=\"headerlink\" title=\"授权数据库给用户\"></a>授权数据库给用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grant select,insert,update,delete,create,drop on test.* to testuser;</span><br></pre></td></tr></table></figure>\n<p>授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作</p>\n<h3 id=\"刷新权限\"><a href=\"#刷新权限\" class=\"headerlink\" title=\"刷新权限\"></a>刷新权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flush  privileges</span><br></pre></td></tr></table></figure>\n<h3 id=\"取消授权\"><a href=\"#取消授权\" class=\"headerlink\" title=\"取消授权\"></a>取消授权</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revoke all on *.* from testuser</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除用户\"><a href=\"#删除用户\" class=\"headerlink\" title=\"删除用户\"></a>删除用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from mysql.user where user=&apos;testuser&apos;</span><br></pre></td></tr></table></figure>\n"},{"title":"ubuntu制作桌面图标","date":"2019-08-14T05:54:09.000Z","_content":"\n\n\n\n\n在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。\n\n这里以typora为例说一下怎么制作，其实也很简单\n\n进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容\n\n```\n[Desktop Entry]\nEncoding=UTF-8\nName=Typora\nComment=Typora\nExec=/home/lixf/software/Typora/Typora\nIcon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.png\nTerminal=false\nstarttupNotify=true\nType=Application\nCategories=Application;Development;\n```\n\n保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??\n\n![图标已经出来了](https://static.huiyuanai.com/lixfio/image/ubuntu-create-desktop-icon/typora.png)","source":"_posts/ubuntu-create-desktop-icon.md","raw":"---\ntitle: ubuntu制作桌面图标\ndate: 2019-08-14 13:54:09\ncategories: 实用\ntags: \n  - ubuntu\n---\n\n\n\n\n\n在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。\n\n这里以typora为例说一下怎么制作，其实也很简单\n\n进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容\n\n```\n[Desktop Entry]\nEncoding=UTF-8\nName=Typora\nComment=Typora\nExec=/home/lixf/software/Typora/Typora\nIcon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.png\nTerminal=false\nstarttupNotify=true\nType=Application\nCategories=Application;Development;\n```\n\n保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??\n\n![图标已经出来了](https://static.huiyuanai.com/lixfio/image/ubuntu-create-desktop-icon/typora.png)","slug":"ubuntu-create-desktop-icon","published":1,"updated":"2020-05-08T01:34:46.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhx000hwrd75vv60hg1","content":"<p>在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。</p>\n<p>这里以typora为例说一下怎么制作，其实也很简单</p>\n<p>进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Encoding=UTF-8</span><br><span class=\"line\">Name=Typora</span><br><span class=\"line\">Comment=Typora</span><br><span class=\"line\">Exec=/home/lixf/software/Typora/Typora</span><br><span class=\"line\">Icon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.png</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">starttupNotify=true</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Categories=Application;Development;</span><br></pre></td></tr></table></figure>\n<p>保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/ubuntu-create-desktop-icon/typora.png\" alt=\"图标已经出来了\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。</p>\n<p>这里以typora为例说一下怎么制作，其实也很简单</p>\n<p>进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Encoding=UTF-8</span><br><span class=\"line\">Name=Typora</span><br><span class=\"line\">Comment=Typora</span><br><span class=\"line\">Exec=/home/lixf/software/Typora/Typora</span><br><span class=\"line\">Icon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.png</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">starttupNotify=true</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Categories=Application;Development;</span><br></pre></td></tr></table></figure>\n<p>保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/ubuntu-create-desktop-icon/typora.png\" alt=\"图标已经出来了\"></p>\n"},{"title":"临时复制粘贴处","date":"2019-06-17T07:05:19.000Z","_content":"\n\n\n粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）\n\n<textarea id=\"editbox\" style=\"padding:10px;width:80%;margin-left:auto;margin-right:auto;height:350px\"> </textarea>\n<span id=\"tips\" style=\"color:red;font-size:12px\"></span>\n\n\n\n<script>\n    Date.prototype.Format = function(fmt) {\n            var o = {\n                \"M+\" : this.getMonth() + 1,\n                \"d+\" : this.getDate(),\n                \"h+\" : this.getHours(),\n                \"m+\" : this.getMinutes(),\n                \"s+\" : this.getSeconds(),\n                \"q+\" : Math.floor((this.getMonth() + 3) / 3),\n                \"S\" : this.getMilliseconds()\n            };\n            if (/(y+)/.test(fmt))\n                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            for (var k in o)\n            if (new RegExp(\"(\" + k + \")\").test(fmt))\n                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n            return fmt;\n        }\n\n      var editbox =  document.getElementById(\"editbox\");\n      if(localStorage.autoSave == undefined){\n        localStorage.autoSave = \"\";\n      }\n\teditbox.value = localStorage.autoSave;\n      setInterval(function(){\n         var value = editbox.value;\n         var saveValue = localStorage.autoSave;\n         if(value != saveValue){\n             localStorage.autoSave = value;\n             document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\";\n         }\n      },1000 * 3);\n</script>\n\n\n\n\n\n\n\n\n","source":"_posts/textarea.md","raw":"---\ntitle: 临时复制粘贴处\ndate: 2019-06-17 15:05:19\ntags: tools\n---\n\n\n\n粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）\n\n<textarea id=\"editbox\" style=\"padding:10px;width:80%;margin-left:auto;margin-right:auto;height:350px\"> </textarea>\n<span id=\"tips\" style=\"color:red;font-size:12px\"></span>\n\n\n\n<script>\n    Date.prototype.Format = function(fmt) {\n            var o = {\n                \"M+\" : this.getMonth() + 1,\n                \"d+\" : this.getDate(),\n                \"h+\" : this.getHours(),\n                \"m+\" : this.getMinutes(),\n                \"s+\" : this.getSeconds(),\n                \"q+\" : Math.floor((this.getMonth() + 3) / 3),\n                \"S\" : this.getMilliseconds()\n            };\n            if (/(y+)/.test(fmt))\n                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            for (var k in o)\n            if (new RegExp(\"(\" + k + \")\").test(fmt))\n                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n            return fmt;\n        }\n\n      var editbox =  document.getElementById(\"editbox\");\n      if(localStorage.autoSave == undefined){\n        localStorage.autoSave = \"\";\n      }\n\teditbox.value = localStorage.autoSave;\n      setInterval(function(){\n         var value = editbox.value;\n         var saveValue = localStorage.autoSave;\n         if(value != saveValue){\n             localStorage.autoSave = value;\n             document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\";\n         }\n      },1000 * 3);\n</script>\n\n\n\n\n\n\n\n\n","slug":"textarea","published":1,"updated":"2019-06-17T08:59:35.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xwerhz000lwrd7cy5sehme","content":"<p>粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）</p>\n<p><textarea id=\"editbox\" style=\"padding:10px;width:80%;margin-left:auto;margin-right:auto;height:350px\"> </textarea><br><span id=\"tips\" style=\"color:red;font-size:12px\"></span></p>\n<script>\n    Date.prototype.Format = function(fmt) {\n            var o = {\n                \"M+\" : this.getMonth() + 1,\n                \"d+\" : this.getDate(),\n                \"h+\" : this.getHours(),\n                \"m+\" : this.getMinutes(),\n                \"s+\" : this.getSeconds(),\n                \"q+\" : Math.floor((this.getMonth() + 3) / 3),\n                \"S\" : this.getMilliseconds()\n            };\n            if (/(y+)/.test(fmt))\n                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            for (var k in o)\n            if (new RegExp(\"(\" + k + \")\").test(fmt))\n                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n            return fmt;\n        }\n\n      var editbox =  document.getElementById(\"editbox\");\n      if(localStorage.autoSave == undefined){\n        localStorage.autoSave = \"\";\n      }\n    editbox.value = localStorage.autoSave;\n      setInterval(function(){\n         var value = editbox.value;\n         var saveValue = localStorage.autoSave;\n         if(value != saveValue){\n             localStorage.autoSave = value;\n             document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\";\n         }\n      },1000 * 3);\n</script>\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）</p>\n<p><textarea id=\"editbox\" style=\"padding:10px;width:80%;margin-left:auto;margin-right:auto;height:350px\"> </textarea><br><span id=\"tips\" style=\"color:red;font-size:12px\"></span></p>\n<script>\n    Date.prototype.Format = function(fmt) {\n            var o = {\n                \"M+\" : this.getMonth() + 1,\n                \"d+\" : this.getDate(),\n                \"h+\" : this.getHours(),\n                \"m+\" : this.getMinutes(),\n                \"s+\" : this.getSeconds(),\n                \"q+\" : Math.floor((this.getMonth() + 3) / 3),\n                \"S\" : this.getMilliseconds()\n            };\n            if (/(y+)/.test(fmt))\n                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            for (var k in o)\n            if (new RegExp(\"(\" + k + \")\").test(fmt))\n                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n            return fmt;\n        }\n\n      var editbox =  document.getElementById(\"editbox\");\n      if(localStorage.autoSave == undefined){\n        localStorage.autoSave = \"\";\n      }\n    editbox.value = localStorage.autoSave;\n      setInterval(function(){\n         var value = editbox.value;\n         var saveValue = localStorage.autoSave;\n         if(value != saveValue){\n             localStorage.autoSave = value;\n             document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\";\n         }\n      },1000 * 3);\n</script>\n\n\n\n\n\n\n\n\n"},{"title":"欢迎访问我的博客","date":"2019-05-07T12:16:23.000Z","_content":"\n\n\n\n\n## 欢迎访问李小飞的个人博客\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/shamo.jpg)\n\n\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/footbg2.png)\n\n\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/touxiang.jpeg)\n\n","source":"_posts/welcome-my-blog.md","raw":"---\ntitle: 欢迎访问我的博客\ndate: 2019-05-07 20:16:23\ncategories: 杂谈\ntags: \n  - 欢迎\n  - 博客\n---\n\n\n\n\n\n## 欢迎访问李小飞的个人博客\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/shamo.jpg)\n\n\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/footbg2.png)\n\n\n\n![](https://static.huiyuanai.com/lixfio/image/welcome-my-blog/touxiang.jpeg)\n\n","slug":"welcome-my-blog","published":1,"updated":"2020-05-08T01:34:46.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xweri0000owrd75e5v7evs","content":"<h2 id=\"欢迎访问李小飞的个人博客\"><a href=\"#欢迎访问李小飞的个人博客\" class=\"headerlink\" title=\"欢迎访问李小飞的个人博客\"></a>欢迎访问李小飞的个人博客</h2><p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/shamo.jpg\" alt></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/footbg2.png\" alt></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/touxiang.jpeg\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"欢迎访问李小飞的个人博客\"><a href=\"#欢迎访问李小飞的个人博客\" class=\"headerlink\" title=\"欢迎访问李小飞的个人博客\"></a>欢迎访问李小飞的个人博客</h2><p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/shamo.jpg\" alt></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/footbg2.png\" alt></p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/welcome-my-blog/touxiang.jpeg\" alt></p>\n"},{"title":"开源网盘nextcloud使用介绍","date":"2020-04-29T07:31:52.000Z","_content":"\n\n\n[NextCloud](https://nextcloud.com/)是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。\n\n\n\n### 预览\n\n#### 登录\n\n![登录页面](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/login.png)\n\n\n\n#### 主页\n\n![主页](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/main.png)\n\n\n\n#### 文件列表\n\n![文件列表](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/files.png)\n\n\n\n#### 下载 \n\n下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆\n\n![下载](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/downloader.png)\n\n\n\n\n\n### Docker部署\n\n部署的文档[官网](https://hub.docker.com/_/nextcloud)写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看[官网](https://hub.docker.com/_/nextcloud)说明，这里就不再详说了\n\n```bash\ndocker run -d -p 8080:80 nextcloud\n```\n\n\n\n### 离线下载\n\n这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。\n\n离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问[插件主页](https://apps.nextcloud.com/apps/ocdownloader)下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。\n\n\n\n效果如图:\n\n![ocDownloader](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/ocdownloader.png)\n\n\n\n从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。\n\n鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。\n\n下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-> 【其它设置】-> 【ocDownloader】中配置一下代理。\n\n如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。\n\n```\ndocker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli\n# 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错\n```\n\n启动代理容器后，在启动nextcloud的时候加上 --link proxy.cn参数，例如\n\n```bash\ndocker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria\n```\n\n然后在【其它设置】-> 【ocDownloader】中可以指定代理地址为 http://proxy.com ，端口是 7777\n\n设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。\n\n\n\n### HTTPS\n\n我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书\n\n虽然简单，我们还是要做一些准备工作。\n\n1. 第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar\n\n2. 由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。\n\n   在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，[点击这里](https://github.com/nginx-proxy/nginx-proxy)参考官方文档进行配置。\n\n```\nproxy_connect_timeout 600;\nproxy_send_timeout 600;\nproxy_read_timeout 600;\nclient_max_body_size 10000m;\n```\n\n\n\n这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器\n\n```bash\ndocker run --detach   \\\n--restart=always  --name nginx-proxy   \\\n--publish 80:80    \\\n--volume /usr/share/nginx/html    \\\n--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro  \\\n--volume /var/run/docker.sock:/tmp/docker.sock:ro  \\\njwilder/nginx-proxy\n```\n\n\n\nnginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将me@foo.bar换成自己的邮箱\n\n```bash\n docker run --detach \\\n    --name nginx-proxy-letsencrypt \\\n    --volumes-from nginx-proxy \\\n    --volume /var/run/docker.sock:/var/run/docker.sock:ro \\\n    --env \"DEFAULT_EMAIL=me@foo.bar\" \\\n    jrcs/letsencrypt-nginx-proxy-companion\n```\n\n\n\n最后就可以启动nextcloud容器啦\n\n```bash\ndocker run --detach \\\n    --name nextcloud \\\n    --restart always \\\n    --link proxy.com\\\n    --env \"VIRTUAL_HOST=pan.foo.bar\" \\\n    --env \"VIRTUAL_PORT=3000\" \\\n    --env \"LETSENCRYPT_HOST=pan.foo.bar\" \\\n    --env \"LETSENCRYPT_EMAIL=me@foo.bar\" \\\n    --v /data/nextcloud:/var/www/html \\\n     mrlee326/nextcloud-aria\n```\n\n\n\n启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。\n\n值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。\n\n最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。\n\n![https](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/httttttps.png)\n\n\n\n\n\n### 必备的插件\n\nnextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】\n\n#### Mind Map \n\n用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制\n\n![](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/mindmap.png)\n\n#### Draw.io\n\n用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。\n\n![](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/drawio.png)\n\n\n\n### 其它\n\n现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。\n","source":"_posts/nextcloud-in-docker.md","raw":"---\ntitle: 开源网盘nextcloud使用介绍\ndate: 2020-04-29 15:31:52\ncategories: 实用\ntags: \n  - nextcloud\n  - ocdownloader\n---\n\n\n\n[NextCloud](https://nextcloud.com/)是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。\n\n\n\n### 预览\n\n#### 登录\n\n![登录页面](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/login.png)\n\n\n\n#### 主页\n\n![主页](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/main.png)\n\n\n\n#### 文件列表\n\n![文件列表](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/files.png)\n\n\n\n#### 下载 \n\n下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆\n\n![下载](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/downloader.png)\n\n\n\n\n\n### Docker部署\n\n部署的文档[官网](https://hub.docker.com/_/nextcloud)写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看[官网](https://hub.docker.com/_/nextcloud)说明，这里就不再详说了\n\n```bash\ndocker run -d -p 8080:80 nextcloud\n```\n\n\n\n### 离线下载\n\n这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。\n\n离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问[插件主页](https://apps.nextcloud.com/apps/ocdownloader)下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。\n\n\n\n效果如图:\n\n![ocDownloader](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/ocdownloader.png)\n\n\n\n从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。\n\n鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。\n\n下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-> 【其它设置】-> 【ocDownloader】中配置一下代理。\n\n如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。\n\n```\ndocker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli\n# 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错\n```\n\n启动代理容器后，在启动nextcloud的时候加上 --link proxy.cn参数，例如\n\n```bash\ndocker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria\n```\n\n然后在【其它设置】-> 【ocDownloader】中可以指定代理地址为 http://proxy.com ，端口是 7777\n\n设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。\n\n\n\n### HTTPS\n\n我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书\n\n虽然简单，我们还是要做一些准备工作。\n\n1. 第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar\n\n2. 由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。\n\n   在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，[点击这里](https://github.com/nginx-proxy/nginx-proxy)参考官方文档进行配置。\n\n```\nproxy_connect_timeout 600;\nproxy_send_timeout 600;\nproxy_read_timeout 600;\nclient_max_body_size 10000m;\n```\n\n\n\n这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器\n\n```bash\ndocker run --detach   \\\n--restart=always  --name nginx-proxy   \\\n--publish 80:80    \\\n--volume /usr/share/nginx/html    \\\n--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro  \\\n--volume /var/run/docker.sock:/tmp/docker.sock:ro  \\\njwilder/nginx-proxy\n```\n\n\n\nnginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将me@foo.bar换成自己的邮箱\n\n```bash\n docker run --detach \\\n    --name nginx-proxy-letsencrypt \\\n    --volumes-from nginx-proxy \\\n    --volume /var/run/docker.sock:/var/run/docker.sock:ro \\\n    --env \"DEFAULT_EMAIL=me@foo.bar\" \\\n    jrcs/letsencrypt-nginx-proxy-companion\n```\n\n\n\n最后就可以启动nextcloud容器啦\n\n```bash\ndocker run --detach \\\n    --name nextcloud \\\n    --restart always \\\n    --link proxy.com\\\n    --env \"VIRTUAL_HOST=pan.foo.bar\" \\\n    --env \"VIRTUAL_PORT=3000\" \\\n    --env \"LETSENCRYPT_HOST=pan.foo.bar\" \\\n    --env \"LETSENCRYPT_EMAIL=me@foo.bar\" \\\n    --v /data/nextcloud:/var/www/html \\\n     mrlee326/nextcloud-aria\n```\n\n\n\n启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。\n\n值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。\n\n最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。\n\n![https](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/httttttps.png)\n\n\n\n\n\n### 必备的插件\n\nnextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】\n\n#### Mind Map \n\n用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制\n\n![](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/mindmap.png)\n\n#### Draw.io\n\n用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。\n\n![](https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/drawio.png)\n\n\n\n### 其它\n\n现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。\n","slug":"nextcloud-in-docker","published":1,"updated":"2020-05-08T01:34:46.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9xweryv001mwrd7hg0j8c6t","content":"<p><a href=\"https://nextcloud.com/\" target=\"_blank\" rel=\"noopener\">NextCloud</a>是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。</p>\n<h3 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h3><h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/login.png\" alt=\"登录页面\"></p>\n<h4 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/main.png\" alt=\"主页\"></p>\n<h4 id=\"文件列表\"><a href=\"#文件列表\" class=\"headerlink\" title=\"文件列表\"></a>文件列表</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/files.png\" alt=\"文件列表\"></p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p>下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/downloader.png\" alt=\"下载\"></p>\n<h3 id=\"Docker部署\"><a href=\"#Docker部署\" class=\"headerlink\" title=\"Docker部署\"></a>Docker部署</h3><p>部署的文档<a href=\"https://hub.docker.com/_/nextcloud\" target=\"_blank\" rel=\"noopener\">官网</a>写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看<a href=\"https://hub.docker.com/_/nextcloud\" target=\"_blank\" rel=\"noopener\">官网</a>说明，这里就不再详说了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 8080:80 nextcloud</span><br></pre></td></tr></table></figure>\n<h3 id=\"离线下载\"><a href=\"#离线下载\" class=\"headerlink\" title=\"离线下载\"></a>离线下载</h3><p>这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。</p>\n<p>离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问<a href=\"https://apps.nextcloud.com/apps/ocdownloader\" target=\"_blank\" rel=\"noopener\">插件主页</a>下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。</p>\n<p>效果如图:</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/ocdownloader.png\" alt=\"ocDownloader\"></p>\n<p>从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。</p>\n<p>鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。</p>\n<p>下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。</p>\n<p>如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli</span><br><span class=\"line\"># 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错</span><br></pre></td></tr></table></figure>\n<p>启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure>\n<p>然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 <a href=\"http://proxy.com\" target=\"_blank\" rel=\"noopener\">http://proxy.com</a> ，端口是 7777</p>\n<p>设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。</p>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><p>我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书</p>\n<p>虽然简单，我们还是要做一些准备工作。</p>\n<ol>\n<li><p>第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar</p>\n</li>\n<li><p>由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。</p>\n<p>在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，<a href=\"https://github.com/nginx-proxy/nginx-proxy\" target=\"_blank\" rel=\"noopener\">点击这里</a>参考官方文档进行配置。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_connect_timeout 600;</span><br><span class=\"line\">proxy_send_timeout 600;</span><br><span class=\"line\">proxy_read_timeout 600;</span><br><span class=\"line\">client_max_body_size 10000m;</span><br></pre></td></tr></table></figure>\n<p>这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach   \\</span><br><span class=\"line\">--restart=always  --name nginx-proxy   \\</span><br><span class=\"line\">--publish 80:80    \\</span><br><span class=\"line\">--volume /usr/share/nginx/html    \\</span><br><span class=\"line\">--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro  \\</span><br><span class=\"line\">--volume /var/run/docker.sock:/tmp/docker.sock:ro  \\</span><br><span class=\"line\">jwilder/nginx-proxy</span><br></pre></td></tr></table></figure>\n<p>nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将<a href=\"mailto:me@foo.bar\" target=\"_blank\" rel=\"noopener\">me@foo.bar</a>换成自己的邮箱</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach \\</span><br><span class=\"line\">   --name nginx-proxy-letsencrypt \\</span><br><span class=\"line\">   --volumes-from nginx-proxy \\</span><br><span class=\"line\">   --volume /var/run/docker.sock:/var/run/docker.sock:ro \\</span><br><span class=\"line\">   --env <span class=\"string\">\"DEFAULT_EMAIL=me@foo.bar\"</span> \\</span><br><span class=\"line\">   jrcs/letsencrypt-nginx-proxy-companion</span><br></pre></td></tr></table></figure>\n<p>最后就可以启动nextcloud容器啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach \\</span><br><span class=\"line\">    --name nextcloud \\</span><br><span class=\"line\">    --restart always \\</span><br><span class=\"line\">    --link proxy.com\\</span><br><span class=\"line\">    --env <span class=\"string\">\"VIRTUAL_HOST=pan.foo.bar\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"VIRTUAL_PORT=3000\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"LETSENCRYPT_HOST=pan.foo.bar\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"LETSENCRYPT_EMAIL=me@foo.bar\"</span> \\</span><br><span class=\"line\">    --v /data/nextcloud:/var/www/html \\</span><br><span class=\"line\">     mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure>\n<p>启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过<a href=\"https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。\" target=\"_blank\" rel=\"noopener\">https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。</a></p>\n<p>值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。</p>\n<p>最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/httttttps.png\" alt=\"https\"></p>\n<h3 id=\"必备的插件\"><a href=\"#必备的插件\" class=\"headerlink\" title=\"必备的插件\"></a>必备的插件</h3><p>nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】</p>\n<h4 id=\"Mind-Map\"><a href=\"#Mind-Map\" class=\"headerlink\" title=\"Mind Map\"></a>Mind Map</h4><p>用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/mindmap.png\" alt></p>\n<h4 id=\"Draw-io\"><a href=\"#Draw-io\" class=\"headerlink\" title=\"Draw.io\"></a>Draw.io</h4><p>用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/drawio.png\" alt></p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://nextcloud.com/\" target=\"_blank\" rel=\"noopener\">NextCloud</a>是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。</p>\n<h3 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h3><h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/login.png\" alt=\"登录页面\"></p>\n<h4 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/main.png\" alt=\"主页\"></p>\n<h4 id=\"文件列表\"><a href=\"#文件列表\" class=\"headerlink\" title=\"文件列表\"></a>文件列表</h4><p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/files.png\" alt=\"文件列表\"></p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p>下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/downloader.png\" alt=\"下载\"></p>\n<h3 id=\"Docker部署\"><a href=\"#Docker部署\" class=\"headerlink\" title=\"Docker部署\"></a>Docker部署</h3><p>部署的文档<a href=\"https://hub.docker.com/_/nextcloud\" target=\"_blank\" rel=\"noopener\">官网</a>写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看<a href=\"https://hub.docker.com/_/nextcloud\" target=\"_blank\" rel=\"noopener\">官网</a>说明，这里就不再详说了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 8080:80 nextcloud</span><br></pre></td></tr></table></figure>\n<h3 id=\"离线下载\"><a href=\"#离线下载\" class=\"headerlink\" title=\"离线下载\"></a>离线下载</h3><p>这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。</p>\n<p>离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问<a href=\"https://apps.nextcloud.com/apps/ocdownloader\" target=\"_blank\" rel=\"noopener\">插件主页</a>下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。</p>\n<p>效果如图:</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/ocdownloader.png\" alt=\"ocDownloader\"></p>\n<p>从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。</p>\n<p>鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。</p>\n<p>下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。</p>\n<p>如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli</span><br><span class=\"line\"># 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错</span><br></pre></td></tr></table></figure>\n<p>启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure>\n<p>然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 <a href=\"http://proxy.com\" target=\"_blank\" rel=\"noopener\">http://proxy.com</a> ，端口是 7777</p>\n<p>设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。</p>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><p>我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书</p>\n<p>虽然简单，我们还是要做一些准备工作。</p>\n<ol>\n<li><p>第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar</p>\n</li>\n<li><p>由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。</p>\n<p>在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，<a href=\"https://github.com/nginx-proxy/nginx-proxy\" target=\"_blank\" rel=\"noopener\">点击这里</a>参考官方文档进行配置。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_connect_timeout 600;</span><br><span class=\"line\">proxy_send_timeout 600;</span><br><span class=\"line\">proxy_read_timeout 600;</span><br><span class=\"line\">client_max_body_size 10000m;</span><br></pre></td></tr></table></figure>\n<p>这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach   \\</span><br><span class=\"line\">--restart=always  --name nginx-proxy   \\</span><br><span class=\"line\">--publish 80:80    \\</span><br><span class=\"line\">--volume /usr/share/nginx/html    \\</span><br><span class=\"line\">--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro  \\</span><br><span class=\"line\">--volume /var/run/docker.sock:/tmp/docker.sock:ro  \\</span><br><span class=\"line\">jwilder/nginx-proxy</span><br></pre></td></tr></table></figure>\n<p>nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将<a href=\"mailto:me@foo.bar\" target=\"_blank\" rel=\"noopener\">me@foo.bar</a>换成自己的邮箱</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach \\</span><br><span class=\"line\">   --name nginx-proxy-letsencrypt \\</span><br><span class=\"line\">   --volumes-from nginx-proxy \\</span><br><span class=\"line\">   --volume /var/run/docker.sock:/var/run/docker.sock:ro \\</span><br><span class=\"line\">   --env <span class=\"string\">\"DEFAULT_EMAIL=me@foo.bar\"</span> \\</span><br><span class=\"line\">   jrcs/letsencrypt-nginx-proxy-companion</span><br></pre></td></tr></table></figure>\n<p>最后就可以启动nextcloud容器啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --detach \\</span><br><span class=\"line\">    --name nextcloud \\</span><br><span class=\"line\">    --restart always \\</span><br><span class=\"line\">    --link proxy.com\\</span><br><span class=\"line\">    --env <span class=\"string\">\"VIRTUAL_HOST=pan.foo.bar\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"VIRTUAL_PORT=3000\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"LETSENCRYPT_HOST=pan.foo.bar\"</span> \\</span><br><span class=\"line\">    --env <span class=\"string\">\"LETSENCRYPT_EMAIL=me@foo.bar\"</span> \\</span><br><span class=\"line\">    --v /data/nextcloud:/var/www/html \\</span><br><span class=\"line\">     mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure>\n<p>启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过<a href=\"https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。\" target=\"_blank\" rel=\"noopener\">https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。</a></p>\n<p>值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。</p>\n<p>最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/httttttps.png\" alt=\"https\"></p>\n<h3 id=\"必备的插件\"><a href=\"#必备的插件\" class=\"headerlink\" title=\"必备的插件\"></a>必备的插件</h3><p>nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】</p>\n<h4 id=\"Mind-Map\"><a href=\"#Mind-Map\" class=\"headerlink\" title=\"Mind Map\"></a>Mind Map</h4><p>用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/mindmap.png\" alt></p>\n<h4 id=\"Draw-io\"><a href=\"#Draw-io\" class=\"headerlink\" title=\"Draw.io\"></a>Draw.io</h4><p>用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。</p>\n<p><img src=\"https://static.huiyuanai.com/lixfio/image/nextcloud-in-docker/drawio.png\" alt></p>\n<h3 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h3><p>现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。</p>\n"}],"PostAsset":[{"_id":"source/_posts/create-native-app-from-web-url/appmaker.png","post":"ck9xwerhp0006wrd70cktc552","slug":"appmaker.png","modified":1,"renderable":1},{"_id":"source/_posts/ubuntu-create-desktop-icon/typora.png","slug":"typora.png","post":"ck9xwerhx000hwrd75vv60hg1","modified":1,"renderable":0},{"_id":"source/_posts/Expand-the-function-of-ocdownloader/downloadpage.png","post":"ck9xwerhd0000wrd7jiqaaqay","slug":"downloadpage.png","modified":1,"renderable":1},{"_id":"source/_posts/Expand-the-function-of-ocdownloader/tool-example.png","post":"ck9xwerhd0000wrd7jiqaaqay","slug":"tool-example.png","modified":1,"renderable":1},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png","post":"ck9xwerhl0004wrd76xj8pivi","slug":"localpath.png","modified":1,"renderable":1},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png","post":"ck9xwerhl0004wrd76xj8pivi","slug":"networkpath.png","modified":1,"renderable":1},{"_id":"source/_posts/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png","post":"ck9xwerhl0004wrd76xj8pivi","slug":"output.png","modified":1,"renderable":1},{"_id":"source/_posts/welcome-my-blog/footbg2.png","post":"ck9xweri0000owrd75e5v7evs","slug":"footbg2.png","modified":1,"renderable":1},{"_id":"source/_posts/welcome-my-blog/shamo.jpg","post":"ck9xweri0000owrd75e5v7evs","slug":"shamo.jpg","modified":1,"renderable":1},{"_id":"source/_posts/welcome-my-blog/touxiang.jpeg","post":"ck9xweri0000owrd75e5v7evs","slug":"touxiang.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/downloader.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"downloader.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/drawio.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"drawio.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/files.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"files.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/httttttps.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"httttttps.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/login.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"login.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/main.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"main.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/mindmap.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"mindmap.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/ocdownloader.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"ocdownloader.png","modified":1,"renderable":1},{"_id":"source/_posts/nextcloud-in-docker/屏幕截图.png","post":"ck9xweryv001mwrd7hg0j8c6t","slug":"屏幕截图.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck9xwerhd0000wrd7jiqaaqay","category_id":"ck9xwerhj0002wrd7r0jc3dqm","_id":"ck9xwerhv000bwrd7o481gy69"},{"post_id":"ck9xwerhp0006wrd70cktc552","category_id":"ck9xwerhj0002wrd7r0jc3dqm","_id":"ck9xwerhx000fwrd7dhly5e2x"},{"post_id":"ck9xwerhl0004wrd76xj8pivi","category_id":"ck9xwerhj0002wrd7r0jc3dqm","_id":"ck9xwerhy000iwrd7mzdyrqbn"},{"post_id":"ck9xwerhx000hwrd75vv60hg1","category_id":"ck9xwerhj0002wrd7r0jc3dqm","_id":"ck9xweri1000qwrd74c3gz0mj"},{"post_id":"ck9xwerht0009wrd77njad10o","category_id":"ck9xwerhw000dwrd744v1uofc","_id":"ck9xweri1000swrd7yakc06kb"},{"post_id":"ck9xwerhv000awrd7xwqoto3p","category_id":"ck9xwerhw000dwrd744v1uofc","_id":"ck9xweri2000twrd7sthphln8"},{"post_id":"ck9xweri0000owrd75e5v7evs","category_id":"ck9xweri1000rwrd7jjip9mvw","_id":"ck9xweri2000ywrd75h39skm1"},{"post_id":"ck9xweryv001mwrd7hg0j8c6t","category_id":"ck9xwerhj0002wrd7r0jc3dqm","_id":"ck9xweryx001pwrd7w4zd9s61"}],"PostTag":[{"post_id":"ck9xwerhd0000wrd7jiqaaqay","tag_id":"ck9xwerhl0003wrd79ktv8lqo","_id":"ck9xwerhx000gwrd7bkpoukr3"},{"post_id":"ck9xwerhd0000wrd7jiqaaqay","tag_id":"ck9xwerhq0008wrd75v71xhra","_id":"ck9xwerhy000jwrd71wbqe7pa"},{"post_id":"ck9xwerhg0001wrd7fk4w36lj","tag_id":"ck9xwerhw000cwrd7r7j1ghmw","_id":"ck9xweri0000nwrd7t00p782d"},{"post_id":"ck9xwerhl0004wrd76xj8pivi","tag_id":"ck9xwerhy000kwrd7palzctyh","_id":"ck9xweri2000vwrd7chwgallh"},{"post_id":"ck9xwerhl0004wrd76xj8pivi","tag_id":"ck9xweri1000pwrd7hafivvvm","_id":"ck9xweri2000wwrd7640prdum"},{"post_id":"ck9xwerhn0005wrd7upk0tnp4","tag_id":"ck9xweri2000uwrd7fho60ztb","_id":"ck9xweri2000zwrd7p95330q3"},{"post_id":"ck9xwerhp0006wrd70cktc552","tag_id":"ck9xweri2000xwrd76tcinu3a","_id":"ck9xweri30011wrd7bnvsnuaa"},{"post_id":"ck9xwerht0009wrd77njad10o","tag_id":"ck9xwerhw000cwrd7r7j1ghmw","_id":"ck9xweri30014wrd7tatsly2z"},{"post_id":"ck9xwerht0009wrd77njad10o","tag_id":"ck9xweri30012wrd765g4bifd","_id":"ck9xweri30015wrd7zqgf6vrx"},{"post_id":"ck9xwerhv000awrd7xwqoto3p","tag_id":"ck9xweri30013wrd7d9f4x6lq","_id":"ck9xweri40019wrd7ou0suga7"},{"post_id":"ck9xwerhv000awrd7xwqoto3p","tag_id":"ck9xweri30012wrd765g4bifd","_id":"ck9xweri4001awrd76kalreo6"},{"post_id":"ck9xwerhv000awrd7xwqoto3p","tag_id":"ck9xweri40017wrd7i2cagu0s","_id":"ck9xweri5001cwrd75kobp2le"},{"post_id":"ck9xwerhw000ewrd7vttad0l9","tag_id":"ck9xweri40018wrd7etq66pwj","_id":"ck9xweri5001dwrd76vkinhbb"},{"post_id":"ck9xwerhx000hwrd75vv60hg1","tag_id":"ck9xweri2000xwrd76tcinu3a","_id":"ck9xweri5001fwrd7uj7i13y3"},{"post_id":"ck9xwerhz000lwrd7cy5sehme","tag_id":"ck9xweri5001ewrd7q7alz83a","_id":"ck9xweri5001hwrd7hu1nbnhn"},{"post_id":"ck9xweri0000owrd75e5v7evs","tag_id":"ck9xweri5001gwrd7mvqrjse8","_id":"ck9xweri5001jwrd77zd666y1"},{"post_id":"ck9xweri0000owrd75e5v7evs","tag_id":"ck9xweri5001iwrd7safupxm9","_id":"ck9xweri6001kwrd7x6kbjk3b"},{"post_id":"ck9xweryv001mwrd7hg0j8c6t","tag_id":"ck9xwerhl0003wrd79ktv8lqo","_id":"ck9xweryx001nwrd7o2f6ggap"},{"post_id":"ck9xweryv001mwrd7hg0j8c6t","tag_id":"ck9xwerhq0008wrd75v71xhra","_id":"ck9xweryx001owrd70lqtiitg"}],"Tag":[{"name":"nextcloud","_id":"ck9xwerhl0003wrd79ktv8lqo"},{"name":"ocdownloader","_id":"ck9xwerhq0008wrd75v71xhra"},{"name":"kubernetes","_id":"ck9xwerhw000cwrd7r7j1ghmw"},{"name":"markdown","_id":"ck9xwerhy000kwrd7palzctyh"},{"name":"图床","_id":"ck9xweri1000pwrd7hafivvvm"},{"name":"golang学习","_id":"ck9xweri2000uwrd7fho60ztb"},{"name":"ubuntu","_id":"ck9xweri2000xwrd76tcinu3a"},{"name":"docker","_id":"ck9xweri30012wrd765g4bifd"},{"name":"k8s","_id":"ck9xweri30013wrd7d9f4x6lq"},{"name":"helm","_id":"ck9xweri40017wrd7i2cagu0s"},{"name":"mysql","_id":"ck9xweri40018wrd7etq66pwj"},{"name":"tools","_id":"ck9xweri5001ewrd7q7alz83a"},{"name":"欢迎","_id":"ck9xweri5001gwrd7mvqrjse8"},{"name":"博客","_id":"ck9xweri5001iwrd7safupxm9"}]}}