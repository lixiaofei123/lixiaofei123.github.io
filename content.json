[{"title":"【5分钟玩转Lighthouse】搭建自己的在线作图工具","date":"2021-07-16T11:39:04.000Z","path":"2021/07/16/deploy-a-draw-tool-online/","text":"说起在线画流程图，大家第一个想到的都是ProcessOn了吧。ProcessOn的确是一个很好用的免费在线流程图工具，但是可惜的是，对于免费用户只能9张的免费额度，如果需要无限的画图，就需要开通159年一年的个人版了。因此，今天给大家推荐的是一个非常优秀的开源在线作图平台DrawIO，其功能强大，丝毫不逊色于ProcessOn。其自带了上百种常用模板，可以支持导出各种图片，使用起来也是特别容易简单。下面是画图的主界面，可以看到，其界面也非常清爽。 优秀的软件需要优秀的服务器来支撑。今天我们使用的是腾讯云轻量服务器，为什么推荐这款服务器呢？当时是因为其性价比特别高，新用户购买1核2G6M的配置只需要99元一年，比ProcessOn最便宜的个人版还要便宜60元，可以以这个价格购买三年。 下面就开始具体的搭建过程 购买服务器首先，我们需要购买一台腾讯云轻量服务器，点击这里打开购买页面，选择需要的配置、以及地域和时长，镜像选择Docker CE 19.03.9，点击立即购买，等支付完毕后，我们就拥有了自己的第一个云服务器。 如果我们想通过域名来访问我们的服务器的话，目前由于大陆的政策原因，使用域名指向大陆的服务器需要ICP备案(腾讯云会协助进行备案)，备案时间通常在十天左右。如果等不及的话，可以购买轻量云的香港节点进行使用，使用香港节点不需要进行备案。购买香港服务器以及购买域名和设置解析等内容请参考这里。 购买成功后，进入到控制台，在轻量应用服务器页面，就可以看到我们有了一台运行中的轻量服务器 点击上图中的【登录】按钮，会弹出下图这样的一个黑色对话框，我们后面的命令将直接在这个对话框里输入，无需再安装第三方的客户端。 这样，我们就有了一台已经安装好Docker的服务器，和一个输入命令的在线终端。 安装前准备 如果不需要域名和HTTPS的话，可以跳过此节。 首先将要使用的域名解析到我们服务器的IP上，我是把drawio.lixf.ink的域名解析到了我使用的服务器IP上，对此步有疑问的同学请参考这里。 然后依次运行下面命令 12345678910111213141516sudo docker run --detach \\ --name nginx-proxy \\ --publish 80:80 \\ --publish 443:443 \\ --volume /data/nginx/certs:/etc/nginx/certs \\ --volume /data/nginx/vhost:/etc/nginx/vhost.d \\ --volume /data/nginx/html:/usr/share/nginx/html \\ --volume /var/run/docker.sock:/tmp/docker.sock:ro \\ nginxproxy/nginx-proxysudo docker run --detach \\ --name nginx-proxy-acme \\ --volumes-from nginx-proxy \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ --volume acme:/etc/acme.sh \\ --env \"DEFAULT_EMAIL=123456789@qq.com\" \\ nginxproxy/acme-companion 这两个docker容器可以自动反向代理我们的docker服务以及自动颁发证书，我在Docker中运行的服务自动签发证书有讲到，有兴趣的同学可以点击进去看一下。 开始安装drawio提供了docker镜像，因此安装起来也特别容易，只需要下面一行命令，就可以安装 1234567docker run --detach \\ --name drawio \\ --restart always \\ --env \"VIRTUAL_HOST=drawio.lixf.ink\" \\ --env \"VIRTUAL_PORT=8080\" \\ --env \"LETSENCRYPT_HOST=drawio.lixf.ink\" \\ jgraph/drawio 上面命令中的环境变量是为了自动反向代理和颁发HTTPS证书使用的，注意要将里面的域名换成自己的。在运行之前，也要把域名解析到自己的服务器IP上。如果没有域名，想直接通过IP访问的话，运行下面的命令。 1docker run --detach --name drawio -p 80:8080 jgraph/draw.io 等待运行结束后，我们就有了一个自己的在线作图工具了。 使用说明在浏览器上输入自己的域名或者IP,然后打开在线作图工具。第一次打开的时候由于需要加载一些js文件，会比较慢，稍微等1分钟，就可以打开了。下面是打开后的界面 上图是让我们选择一个保存的地方，由于只有一个磁盘选项，我们就选择这个。这个选项会把图片保存到我们的本地磁盘上。然后会弹出对话框询问是要创建新的图表还是打开已经存在的，选择创建新的图表。接着就是让我们选择模板了。 此时模板还是空的，我们就选择这个空模板，然后点击创建,页面就跳转到画图界面了 绘制完成后，可以依次选择【File】-&gt;【Export As】-&gt;【png】，将我们绘制的内容导出成png图片下载下来 如下图所示 下面就是导出的图片了 由于我们的存储选择的本地磁盘，因此在绘制的过程中注意需要及时保存。这个时候问题就来了，默认情况下，drawio不会在云端保存的数据，这就意味着我们绘制的流程图无法与别人分享，也无法跨终端访问，十分的不方便。为了解决这一问题，我们需要另外一个同样强大的工具-nextcloud网盘，该网盘有一个drawio插件，通过此插件，就可以实现把流程图直接保存在网盘上和直接在网盘上打开编辑流程图。 NextCloud网盘配置DrawIO插件由于本文不是讲述怎么安装NextCloud网盘的，感兴趣的同学可以打开这篇博客来查看和安装。这里假设读者已经安装好了NextCloud。 打开https://apps.nextcloud.com/apps/drawio网址，根据自己安装的nextcloud版本下载对应的drawio插件包。将插件包解压以后，放在/var/www/html/custom_apps目录下。如下图所示 然后用管理员登录到nextcloud，点击右上角的头像，在弹出菜单中选择【应用】，在里面找到draw.io插件，选择启用。如下图所示 再点击右上角的头像，在弹出菜单中选择【设置】，然后在最右边的侧边菜单中选择【其他设置】，就可以看到Deaw.io的设置项，在Draw.io URL输入框中输入我们drawio服务的地址，然后选择保存。 保存以后，回到主界面，点击加号按钮，就可以看到里面多了一个【新的图表】选项。 点击【新的图表】按钮，输入名字按下回车，就会自动创建图标文件，并且自动在drawio打开了。从下图中可以看出，模板也不是空的了。然后选择自己喜欢的模板，点击创建，就可以自由自在的绘图了。而且借助NextCloud网盘，我们绘制的流程图也可以保存在云端和别人分享了。 总结本教程借助了腾讯云轻量服务器和DrawIo以及Nextcloud搭建了一个在线绘图的软件，这样，我们就可以不受限制的自由绘制流程图，而且我们的数据也是保存在自己的服务器上的，支持分享和多端共享。除了好用的工具以外，选择一个好用的服务器也会有事半功倍的效果。腾讯云轻量服务器自带的Docker镜像可以免除重新安装Docker的过程，而且，价格也是十分的优化，一年99元的价格就可以拥有一台属于自己的服务器。小伙伴们还在等什么呢。","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"processon","slug":"processon","permalink":"https://www.lixf.io/tags/processon/"},{"name":"在线作图","slug":"在线作图","permalink":"https://www.lixf.io/tags/在线作图/"},{"name":"流程图","slug":"流程图","permalink":"https://www.lixf.io/tags/流程图/"}]},{"title":"【5分钟玩转Lighthouse】为Docker中运行的服务自动签发证书","date":"2021-07-08T16:37:44.000Z","path":"2021/07/09/Automatically-issue-certificates-for-docker-service/","text":"​ 有Docker以前，我们部署一个软件或者服务，需要考虑不同平台的兼容性，需要考虑是不是和服务器已经安装的软件冲突。自从Docker的出现，在很大程度上解决了这些问题。只要软件提供了对应的Docker镜像，我们只需要简简单单一条命令，就可以迅速的安装和使用这个软件，而且也不用考虑平台的差异性以及和其它软件是否会有冲突。甚至，由于Docker的轻量性，我们可以在一台服务器上同时部署多个软件对外提供服务，只需要小心每个容器映射主机的端口不要冲突就行了。 ​ 但是我们也知道，HTTP默认的端口是80，HTTPS默认的端口是443，如果我们想让用户不需要指定端口，只通过不同的域名就可以访问到我们同一个服务器上不同Docker容器运行的服务，就需要在宿主机上安装一个Nginx服务，通过nginx的反向代理来将不同的域名反向代理到不同的服务上。 ​ 此外，如果我们想使用HTTPS，则必须拥有域名对应的证书。现在最流行的免费证书是Letsencrypt，虽然说证书的有效期只有三个月，但是可以借助Letsencrypt提供的Certbot工具来实现快到期自动续签，不需要担心证书会失效。 ​ Docker的一个强大之处是其及其丰富的生态系统，不仅有各种各样的服务镜像，还有一些有趣实用的工具镜像。今天介绍的就是其中的nginx-proxy镜像和acme-companion镜像，这两个镜像配合使用，可以实现自动反向代理容器中运行的服务和自动签发证书，可以说是十分的方便和实用了。 ​ 为了演示今天操作的过程，这里我使用了腾讯云轻量服务器，为什么使用腾讯云轻量服务器,首先是因为其性价比非常的高，对于新用户，1核2G的配置只需要99元一年，简直是主机界的一股清流，其次，对使用者也很友好，提供了各种各样的包含docker在内的各种预置镜像，能很快上手使用。 购买服务器首先，我们需要购买一台腾讯云轻量服务器，点击这里打开购买页面，选择需要的配置、以及地域和时长，镜像选择Docker CE 19.03.9，点击立即购买，等支付完毕后，我们就拥有了自己的第一个云服务器。 由于需要使用反向代理和签发证书，因此必须注册一个域名。目前由于大陆的政策原因，使用域名指向香港的服务器需要ICP备案(腾讯云会协助进行备案)，备案时间通常在十天左右。如果等不及的话，可以购买轻量云的香港节点进行使用，使用香港节点不需要进行备案。购买香港服务器以及购买域名和设置解析等内容请参考这里。 购买成功后，进入到控制台，在轻量应用服务器页面，就可以看到我们有了一台运行中的轻量服务器 点击上图中的【登录】按钮，会弹出下图这样的一个黑色对话框，我们后面的命令将直接在这个对话框里输入，无需再安装第三方的客户端。 测试环境在购买服务器的时候，我们选择了Docker CE这个镜像，因此，我们当前服务器里已经有了Docker的环境。而且，轻量云提供的Docker环境已经将docker镜像源替换成了腾讯云自己的Docker镜像源，拉取镜像的速度也是嗖嗖的快。 经测试，下载并解压一个1G左右的镜像，仅需要1分钟左右。和直接使用Docker官方镜像源相比，节省下来的时间可以绕地球跑上三圈了 Docker环境没有问题，下一步就可以启动并运行nginx-proxy容器和acme-companion容器了。 启动nginx-proxynginx-proxy容器的作用通过设置反向代理，将别的容器中的服务通过80端口或者443端口暴露在公网上。nginx-proxy容器会监视别的容器的启动，一旦发现别的容器里有VIRTUAL_HOST(指定了Host)和VIRTUAL_PORT(指定了容器中服务监听的端口)这两个环境变量，会自动对其添加相应的反向代理配置中。 首先需要启动nginx-proxy容器。在启动之前，先创建/data/nginx目录。也可以修改这个目录为自己需要的目录。创建好目录以后，就可以输入下面命令来启动nginx-proxy了。 123456789sudo docker run --detach \\ --name nginx-proxy \\ --publish 80:80 \\ --publish 443:443 \\ --volume /data/nginx/certs:/etc/nginx/certs \\ --volume /data/nginx/vhost:/etc/nginx/vhost.d \\ --volume /data/nginx/html:/usr/share/nginx/html \\ --volume /var/run/docker.sock:/tmp/docker.sock:ro \\ nginxproxy/nginx-proxy 启动以后，如果我们看到下面的文字,说明IPv4 forwarding是禁用状态，需要先把IPv4 forwarding打开，否则，就无法从公网上访问我们的docker容器内的服务了 1IPv4 forwarding is disabled. Networking will not work 打开也非常简单，只需要修改/etc/sysctl.conf文件中的net.ipv4.ip_forward，将其值设置为1，然后用下面命令重启网络 1systemctl restart network 重启网络之后，为了保险起见，最好用sudo docker rm -f nginx-proxy删除掉容器以后，重新启动该容器。 容器启动成功后，可以看到其已经正常运行了 我们可以运行一个服务来简单测试一下nginx-proxy是否像预期那样的工作。 首先，我将grafana.lixf.ink解析到了这台服务器的IP上。对此步有疑问的请参考这里 然后，使用下面命令运行一个grafana。从命令中可以看出，并没有将容器的然和端口映射到宿主机的端口上，只是额外添加了两个环境变量VIRTUAL_HOST和VIRTUAL_PORT来告诉nginx-proxy想使用的域名是grafana.lixf.ink，容器中服务的端口是3000。 12345sudo docker run --detach \\ --name grafana \\ --env \"VIRTUAL_HOST=grafana.lixf.ink\" \\ --env \"VIRTUAL_PORT=3000\" \\ grafana/grafana 容器启动成功后，在浏览器中访问http://grafana.lixf.in即可访问到grafana。 启动acme-companionacme-companion容器的作用是自动为域名签发证书，而且还会在证书快到有效期之前自动续发新的证书，从而保证证书永不过期。和nginx-proxy容器一样，acme-companion容器会监视别的容器的启动，一旦发现别的容器里有LETSENCRYPT_HOST(指定了要签发证书的域名)和LETSENCRYPT_EMAIL(指定了邮箱)这两个环境变量，就会为指定的域名签发对应的证书。签发了证书之后，acme-companion容器会自动修改nginx-proxy中相应的配置，使HTTPS和证书生效。 要注意的是，和nginx-proxy不同的是，nginx-proxy不一定非要在公网环境下才能使用，而acme-companion是必须在公网环境中才能使用的。一方面原因是letsencrypt服务器需要通过访问域名来验证域名所有权，另一个更直接的原因是acme-companion无法访问到letsencrypt服务器，就更不用说签发证书了。 好了，啰嗦了这么多，其实运行命令只有下面一条 1234567sudo docker run --detach \\ --name nginx-proxy-acme \\ --volumes-from nginx-proxy \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ --volume acme:/etc/acme.sh \\ --env \"DEFAULT_EMAIL=326256365@qq.com\" \\ nginxproxy/acme-companion 这时候执行docker ps，可以看到我们nginx-proxy和acme-companion在运行了 我们可以运行一个服务来简单测试一下acme-companion是否像预期那样的工作。这里我同时启动grafana和wordpress来进行测试 12345678910111213docker run --detach \\ --name grafana \\ --env &quot;VIRTUAL_HOST=grafana.lixf.ink&quot; \\ --env &quot;VIRTUAL_PORT=3000&quot; \\ --env &quot;LETSENCRYPT_HOST=grafana.lixf.ink&quot; \\ grafana/grafana docker run --detach \\ --name wordpress \\ --env &quot;VIRTUAL_HOST=blog.lixf.ink&quot; \\ --env &quot;VIRTUAL_PORT=80&quot; \\ --env &quot;LETSENCRYPT_HOST=blog.lixf.ink&quot; \\ wordpress 等待两个容器启动成功后，我们可以分别在浏览器中访问grafana.lixf.ink和blog.lixf.ink，可以看到，连个地址都是HTTPS协议了。 小结本教程借助了腾讯云轻量服务器和nginx-proxy和acme-companion搭建了一个自动为容器服务签发证书的环境，这样，我们后面在使用的时候，只需要指定相应的环境变量，即可以自动拥有安全的小锁标志。现在HTTPS已经是主流，谷歌浏览器不仅对HTTP网站标记为不安全，而且在未来也要默认用户输入的域名使用HTTPS协议。除此之外，HTTPS由于使用了证书签名，也保护了用户的数据安全，防止数据内容被中间人篡改和监听，甚至也防止网站被运营商劫持。从各个方面来看，将网站从HTTP升级为HTTPS都是大势所趋。除了好用的工具以外，选择一个好用的服务器也会有事半功倍的效果。腾讯云轻量服务器自带的Docker镜像可以免除重新安装Docker的过程，而且，价格也是十分的优化，一年99元的价格就可以拥有一台属于自己的服务器。小伙伴们还在等什么呢。","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://www.lixf.io/tags/nginx/"},{"name":"https","slug":"https","permalink":"https://www.lixf.io/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","permalink":"https://www.lixf.io/tags/letsencrypt/"}]},{"title":"【5分钟玩转Lighthouse】搭建自己的代码托管平台gitlab","date":"2021-07-06T11:52:30.000Z","path":"2021/07/06/deploy-a-gitlab-server/","text":"​ 熟练的使用git和github已经成为了每个程序员必备的技能。git可以使我们更好的管理和维护自己的代码，可以使团队成员之间以更高效的方式进行工作，github作为一个免费好用的代码托管平台，在一定程度上对开源社区的发展也起到了非常积极的作用。 ​ 然而，出于各种原因，比如，github对中国用户及其不友好的网速、团队私有的项目不想放在第三方服务器上抑或是无法访问公网的内网环境，搭建自己的私有代码平台也成了一部分开发人员的选择。针对这种需求，目前也有像gitWeb、gerrit、gitlab之类的解决方案，这几种解决方案各有优劣，这里为大家介绍的是其中的佼佼者gitlab，也是我们公司内部正在使用的一个代码管理平台，功能十分完善，页面也和github十分相似，如果对github使用的熟悉，对这个也不会感到陌生。 购买服务器为了方便在互联网环境下使用，这里我们选择了腾讯云轻量服务器来搭建gitlab服务器。 为什么使用腾讯云轻量服务器,首先是因为其性价比非常的高，对于新用户，1核2G的配置只需要99元一年，简直是主机界的一股清流，其次，对使用者也很友好，提供了各种各样的包含docker在内的各种预置镜像，能很快上手使用。 首先，我们需要购买一台腾讯云轻量服务器，点击这里打开购买页面，选择需要的配置、以及地域和时长，镜像选择Docker CE 19.03.9，点击立即购买，等支付完毕后，我们就拥有了自己的第一个云服务器。 为了方便使用，还需要注册一个域名，然后通过域名来访问我们的gitlab服务器。目前由于大陆的政策原因，使用域名指向香港的服务器需要ICP备案(腾讯云会协助进行备案)，备案时间通常在十天左右。如果等不及的话，可以购买轻量云的香港节点进行使用，使用香港节点不需要进行备案。购买香港服务器以及购买域名和设置解析等内容请参考这里。我已经注册好了一个域名lixf.ink，并将gitlab.lixf.ink指向了服务器的IP。 购买成功后，进入到控制台，在轻量应用服务器页面，就可以看到我们有了一台运行中的轻量服务器 第一次使用需要重置一下密码，这一步点击上图进入到概要界面，就可以看到相应的选项。重置密码以后要记住自己所设置的密码。由于篇幅限制，这里不再细说。 点击上图中的【登录】按钮，会弹出下图这样的一个黑色对话框，我们后面的命令将直接在这个对话框里输入，无需再安装第三方的客户端。 安装gitlab现在我们已经有了自己的轻量服务器，而且由于在购买的时候，我们选择了Docker CE作为镜像，因此，此时的服务器里，已经有了一个完整的docker环境，下面我们就可以直接以容器的方式快速安装gitlab服务器。 首先，需要为gitlab的数据创建一个目录，用来存储gitlab在运行过程中产生的数据。 1sudo mkdir -p /data/gitlab #/data/gitlab可以修改成合适的目录 然后，通过运行下面命令，就可以启动gitlab了。注意要把gitlab.lixf.ink换成自己的域名。 123456789sudo docker run --detach \\ --hostname gitlab.lixf.ink \\ --publish 443:443 --publish 80:80 --publish 23:22 \\ --name gitlab \\ --restart always \\ --volume /data/gitlab/config:/etc/gitlab \\ --volume /data/gitlab/logs:/var/log/gitlab \\ --volume /data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 第一次启动时，由于gitlab内部需要初始化一些数据，因此需要等待几分钟才能安装完毕，此时可以输入下面命令查看安装过程中的日志 1sudo docker logs -f gitlab 或者也可以通过watch命令来监控gitlab是否启动成功 1sudo watch docker ps 当看到下图中的healthy时，说明gitlab已经成功运行了 此时，用浏览器访问 gitlab.lixf.ink，就可以访问到我们自己的gitlab了。 重置管理员密码从上图中看到gitlab已经正确安装了，此时由于我们还不知道gitlab管理员账号和密码，需要回到黑窗口页面(终端)，接着设置管理员的密码。 如果首页上显示了设置管理员密码的输入框，我们在这个界面上直接设置管理员密码，无需下面的过程。 输入下面命令进入到gitlab容器内部的终端 1sudo docker exec -it gitlab /bin/bash 然后用下面命令进入 到gitlab的rails控制台 1gitlab-rails console #这一步比较慢，大概在1分钟左右，请耐心等待 当打开控制台后依次输入下面命令来重置管理员账号和密码。 123user=User.find_by_username &apos;root&apos;user.password=&quot;88888888&quot; #这里请换成一个复杂的密码user.save! 设置过程如下图所示 密码设置成功以后，就可以返回到gitlab登录页面登录了。下面是登录成功的页面。 创建并上传第一个项目点击导航栏中间的+号按钮，依次选择【New Project】-&gt; 【Create blank project】，进入到创建项目页面，然后填写相应的信息，点击Create project，即可创建新项目。 创建成功后会自动跳转到项目主页 然后就可以上传代码了。新创建的项目的首页已经提示我们该怎么初始化并上传我们的代码。我们只需要跟着操作就可以了。 第一步,先配置本地git的用户和邮箱 12git config --global user.name \"Administrator\" #换成自己的用户名git config --global user.email \"admin@example.com\" #换成自己的邮箱 第二步,拉取仓库，添加文件并提交代码 1234567git clone http://gitlab.lixf.ink/root/hellogitlab.gitcd hellogitlabgit switch -c mastertouch README.mdgit add README.mdgit commit -m \"add README\"git push -u origin master 下面是在我电脑上的运行结果 代码提交成功以后，再次刷新项目主页，就可以看到我们提交的代码了 我这里直接使用了管理员用户创建并上传项目，实际使用过程中，最好单独创建一个普通用户来进行相应的操作。 配置HTTPS相信有小伙伴看出来了，我们上面使用的是HTTP协议，HTTP协议是一种不安全的协议，因此，这里我们配置成HTTPS，让我们的代码仓库更安全。 gitlab内部集成了letsencrypt，因此，这里只需要启用letsencrypt，并进行一些必要的配置 用vim打开/data/gitlab/config/gitlab.rb，修改以下内容 在32行左右，将external_url前面的#删掉，并在单引号中填写gitlab服务器的https地址，例如https://gitlab.lixf.ink 在2235行左右，修改下面几项 123letsencrypt[&apos;enable&apos;] = true #删除前面的#号，并将值修改为trueletsencrypt[&apos;contact_emails&apos;] = [&apos;foo@email.com&apos;] #删除前面的#号,修改为自己的邮箱letsencrypt[&apos;auto_renew&apos;] = true #删除前面的#号 然后，执行下面命令重启gitlab容器 1sudo docker restart gitlab 等容器重启之后，gitlab就会通过letsencrypt自动签发免费的HTTPS证书，等证书签发成功(大概3分钟左右)，就可以通过https://gitlab.lixf.ink访问我们的代码仓库了。此时，地址栏旁边也会显示一把的小锁，代表这是一个安全的网址。 配置SSH为22端口前面在启动Docker容器的时候，指定了 -p 23:22参数，将gitlab容器的22端口映射到了宿主机的端口上。这个是因为宿主机的22端口已经被sshd服务给占用了，如果不将22端口映射到别的端口上，gitlab容器将无法启动。但是这么做，又会造成我们无法正常的通过ssh协议来提交和拉取代码，这会给习惯用ssh协议的小伙伴带来不必要的麻烦。 为了解决这个问题，我们需要修改sshd服务的端口。由于篇幅限制，这里不具体讲怎么修改sshd端口，详情请参考linux禁止root用户远程登录，并修改ssh端口这篇博客来进行修改。由于sshd是我们通过终端(包括轻量云自带的这个黑窗口)连接服务器所依赖的一个服务，修改了其端口以后，将会造成轻量云自带的终端无法正常连接到服务器，因此，修改了sshd端口之后，后面就只能用终端软件来连接服务器进行操作。另外要注意，修改了端口之后，把修改后的端口添加到轻量云的防火墙中。 如果使用的是window10系统，可以使用自带的power shell或者cmd来连接腾讯云服务器。 打开powershell窗口，输入下面命令然后根据提示输入密码连接到服务器 1ssh -p 24 root@1.1.1.1 # 将24端口换成sshd服务修改后的端口，将1.1.1.1换成轻量云的ip 连接到服务器以后，需要把原来的容器删除掉，然后重新执行一次启动的命令 1234567891011sudo docker rm -f gitlabsudo docker run --detach \\ --hostname gitlab.lixf.ink \\ --publish 443:443 --publish 80:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume /data/gitlab/config:/etc/gitlab \\ --volume /data/gitlab/logs:/var/log/gitlab \\ --volume /data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 因为我们在启动gitlab的时候，我们的配置文件和数据目录等都挂载了宿主机的/data/gitlab目录上，因此，即使我们删除并重新启动了一个新的容器，我们前面的配置和上传的项目依然有效。 至此，一个支持HTTPS和SSH协议的gitlab搭建完成了。 小结本教程借助了腾讯云轻量服务器和gitlab提供的docker镜像快速搭建了一个可用的gitlab代码仓库，并且通过进一步的配置，使搭建的gitlab正确的支持了HTTPS协议以及SSH协议。在搭建的过程中，由于腾讯轻量云自带了Docker环境，使我们免去了自行搭建Docker环境的步骤。而且，轻量云自带的Docker环境已经将docker的镜像源设置为了腾讯云自带的Docker镜像源，拉取gitlab镜像的速度也是非常快，也节省了等待拉取镜像的时间。","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"git","slug":"git","permalink":"https://www.lixf.io/tags/git/"},{"name":"gitlab","slug":"gitlab","permalink":"https://www.lixf.io/tags/gitlab/"}]},{"title":"我自己做的一个简易图床","date":"2021-06-30T12:53:59.000Z","path":"2021/06/30/a-image-host-made-by-myself/","text":"最近重新造了一个轮子，那就是自己做了一个简单图床。说是图床，其实是可以存储任意的文件的,比如word文档、压缩包等等。目前实现的特性有 支持本地上传 支持任意文件格式，不限于图片。只要是个文件就行 支持查看已上传文件 支持离线下载，即从指定网络地址上下载资源。 后端存储目前支持阿里云的OSS以及本地文件存储。 支持配置有/无用户模式 配套了一个Typora的图像上传工具。 首页可以看到页面还是很简洁的，没有多余的内容，专注于上传功能。 上传资源上传的时候可以查看上传进度，同时也支持同时上传多个文件。点击复制链接即可以复制对应的图片链接。如果浏览器不支持自动复制链接的话，则会跳出对话框让手动复制 离线下载重磅推荐类似于百度网盘的离线下载功能，目前仅支持HTTP/HTTPS协议。可以直接从指定网址下载对应的资源，无需下载再上传。 下载列表可以查看离线下载的任务列表，由于数据都在内存中，因此，只能查看最新的100条下载任务。可以直接点击每一行后面的【复制链接】按键来复制链接。同样的，如果浏览器不支持自动复制链接的话，则会跳出对话框让手动复制 文件管理支持文件管理，在上传的时候，会自动创建对应的日期目录，因此，在文件管理页面中，文件也是以事件组织的。 支持有/无用户模式如果是在公网环境下使用，支持配置需要用户登录","tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.lixf.io/tags/markdown/"},{"name":"图床","slug":"图床","permalink":"https://www.lixf.io/tags/图床/"}]},{"title":"theia editor","date":"2021-06-26T15:13:52.000Z","path":"2021/06/26/theia-editor/","text":"今天发现了一个由Eclipse 基金会发布的一个有意思的软件云端编辑器-Theia,支持golang、java、Python、C++等多种主流的编程语言，可以用浏览器直接打开，其运行界面和使用方式与VSCode几乎一摸一样，极大降低了使用者的学习成本。 运行截图下面是程序运行的截图，其中包含了我写的一段简单的测试代码，运行起来也没什么问题 安装说明由于我是用docker安装的，因此安装起来也非常简单 1docker run -d --name theiaide --restart=always -p 3000:3000 -v /data/theia/projects:/home/project:cached theiaide/theia-full 等容器启动以后，就可以在浏览器通过 ip:3000 访问在线编辑器了。但是这时候也仅仅是能访问而已，如果我们尝试创建文件夹或者文件，是不能创建成功的。 这是因为权限问题导致的，容器内部并不是以root用户运行的容器的主进程，而是以theia用户运行的，因此，需要修改一下/data/theia/projects的权限。 使用如下命令进入到容器内部 1docker exec -it theiaide /bin/bash 然后执行下面命令查看所有的用户，并找到theia用户，查看其用户ID 1cat /etc/passwd 如下图所示 可以看到其用户ID是1000 在新版的linux系统中，新建的普通用户，其用户ID一般都是从1000开始 然后，可以使用下面的命令来更改/data/theia/projects文件夹所属的用户 1sudo chown -R 1000 /data/theia/projects 更改了文件夹所属的用户以后，此时就应该可以正常的创建文件以及文件夹了 其它说明 由于需要加载一个2M的bundle.js文件以及别的一些静态的资源，如果带宽比较小，比如现在主流的1M带宽，可能需要等待20到30秒编辑器才能完全加载完毕。这里我的解决办法是到容器里面把lib目录里的内容全都拷贝了出来，然后上传到了阿里云的CDN里，然后再替换掉index.html里的bundle.js的地址。这个中间还涉及到了跨域的问题，有兴趣的话可以自己尝试一下 theia是没有账号密码机制，任何一个知道地址的人都可以直接使用，甚至操作我们的代码。由于我使用了nginx进行了反向代理，因此在nginx的配置文件中增加了用户的认证。这个比较简单，可以参考这个网址 配置了以后的效果如图。这样就可以在一定程度上防止别人未经授权使用我们的编辑器","tags":[{"name":"软件","slug":"软件","permalink":"https://www.lixf.io/tags/软件/"},{"name":"编码","slug":"编码","permalink":"https://www.lixf.io/tags/编码/"}]},{"title":"git和npm设置代理","date":"2021-05-19T08:04:22.000Z","path":"2021/05/19/git-set-proxy/","text":"由于不知名的原因，现在github.com不设置代理的话几乎无法访问。如下图所示，从github上克隆一个postgres，每秒的速度只有3到4KB。 下面分别提供通过https协议和ssh协议克隆仓库设置代理的方法 HTTPS协议如果我们本地有可以科学上网的http或者socket5代理的话，可以进行如下设置(只需要设置一个就行了) 12git config --global http.proxy http://127.0.0.1:10809 #走http代理git config --global http.proxy socks5://127.0.0.1:10808 #走socks5代理 设置完后再克隆，就可以发现拉取仓库的速度有了明显的提升（具体取决于代理的速度和当前网络的速度）。 此时，如果我们通过ssh协议克隆仓库，会发现克隆速度还是很慢(几乎是0)。如下图所示 这种情况下需要给ssh协议配置代理。 SSH协议配置通过ssh协议克隆仓库的话，需要socket5代理。windows用户在 C:\\Users\\用户名.ssh\\config 文件中增加下面的内容 (没有的话自行创建) 12Host github.comProxyCommand connect -S 127.0.0.1:10808 %h %p Linux在~/.ssh/config文件中增加下面内容 12Host github.comProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p 此时再克隆，可以看到速度明显有了提示 npm设置代理npm在国内拉取仓库时，也会特别慢，可以参考下面的配置来设置代理 12npm config set proxy http://127.0.0.1:10809npm config set https-proxy http://127.0.0.1:10809","tags":[{"name":"git","slug":"git","permalink":"https://www.lixf.io/tags/git/"},{"name":"代理","slug":"代理","permalink":"https://www.lixf.io/tags/代理/"}]},{"title":"表分区","date":"2021-05-10T13:22:39.000Z","path":"2021/05/10/table-partitioning/","text":"表分区是指将一个逻辑上的大表分成几个物理小块。表分区可以提供下面几个好处 当要查询的数据在同一个分区或者少数几个分区的时候，可以显著提高查询性能。分区有效代替了索引树的上层部分，看起来就像重度使用的部分放在了内存中一样。个人理解是，如果使用索引，数据库每次要从磁盘中加载索引，由于索引从上到下扫描索引树来查找数据，所以对索引树的上层部分的查询是很频繁的。使用了分区以后，分区数据已经相当于索引树的上层部分了，相当于最经常使用的部分已经放在了内存中了(原因参考最佳实践第4条)。 当查询或者更新占据单独的一个分区的很大比例的时候，通过使用顺序扫描会比使用索引有性能提升。因为索引会在整个表上进行随机读取，随机读取比顺序读取慢得多。 如果使用了设计模式的话，批量加载和删除可以通过分区来完成。直接加载某个分区的数据或者直接删除某个分区的数据要比批量删除快得多。 很少使用的数据可以被迁移到便宜的介质上 postgres支持的几个默认的分区方法 Range Partitioning 范围分区是根据表中的某个或者某几个字段进行分区，例如 1-10 11-20 List Partitioning 通过显式的列出表中的键值对来进行分区 Hash Partitioning 通过为每个分区指定一个除数和余来进行分区。即每一行的hash值除以除数然后得到余，根据余值来放到对应的分区里 分区使用示例 通过指定partitioning by 创建分区表 12345CREATE TABLE measurement ( city_id int not null, logdate date not null, peaktemp int, unitsales int) PARTITION BY RANGE (logdate); 分别创建每一个分区 12CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');CREATE TABLE measurement_y2006m03 PARTITION OF measurement FOR VALUES FROM ('2006-03-01') TO ('2006-04-01') PARTITION BY RANGE (peaktemp); #创建分区表的分区表 如果插入一条不对应任何分区的数据，那么插入会报错，应该手动创建对应的分区 创建索引 1CREATE INDEX ON measurement (logdate); 创建索引是非必须的，分区表上的索引和约束条件都是虚拟的，实际上的索引位置和约束条件都在分区中 确定 数据库配置中 enable_partition_pruning 的值不是禁用状态 分区维护 删除某个分区的数据 12DROP TABLE measurement_y2006m02; # 快速删除数百万条数据，需要在主表上加ACCESS EXCLUSIVEALTER TABLE measurement DETACH PARTITION measurement_y2006m02; #接触分区和分区表的关系，同时保留数据，数据可以做进一步的分析 增加新的分区 1CREATE TABLE measurement_y2008m02 PARTITION OF measurement FOR VALUES FROM (&apos;2008-02-01&apos;) TO (&apos;2008-03-01&apos;) TABLESPACE fasttablespace; 先创建表，再创建分区表 12345CREATE TABLE measurement_y2008m02 (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS) TABLESPACE fasttablespace;ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02 CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );\\copy measurement_y2008m02 from 'measurement_y2008m02'-- possibly some other data preparation workALTER TABLE measurement ATTACH PARTITION measurement_y2008m02 FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' ); 创建索引 123CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);CREATE INDEX measurement_usls_200602_idx ON measurement_y2006m02 (unitsales);ALTER INDEX measurement_usls_idx ATTACH PARTITION measurement_usls_200602_idx; 同样的方式可以用在primary和unique上 123ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);ALTER INDEX measurement_city_id_logdate_key ATTACH PARTITION measurement_y2006m02_city_id_logdate_key 分区表限制 分区表的唯一约束必须包含所有的分区键列。因为各个分区只能保证在自己表中的唯一约束性，保证不了全表的唯一约束性，因此分区表自身必须负责在不同的分区中没有重复。如果唯一约束包含了分区键，那么各个分区对应的唯一约束中的分区键都不同，因此也就保证了在所有分区中的唯一约束都成立 无法创建排除约束（exclusion constraint），原因同上，分区不能跨区排除 insert的BEFORE ROW 触发器不能更改新行的目标区。即 在BEFORE ROW触发器中修改了分区键的值，分区的结果也不会改变。 分区表 临时表和永久表不能混用。分区表是临时的，那么分区也是临时的，分区表是永久的，那么分区也是永久的。 ​ 分区表的幕后是分区和分区表是继承关系，但并不是可以使用所有的继承特性。尤其是分区不能有分区表中不存在的字段，分区表和分区也并不能继承其它表。 ​ 不能使用的继承特性有 分区不能有分区表中不存在的字段 分区表的CHECK和NOT NULL约束会被它的所有分区继承。不能在分区表上使用被标记了NO INHERIT的CHECK。如果分区表的字段上有NOT NULL的话，分区的字段上的NOT NULL不能被删除 当分区表上没有任何分区的时候可以使用ONLY来增加约束，当存在分区的时候，使用ONLY会报错。替代的可以在分区上添加和删除（如果父表中没有）约束 后续再看 分区表本身没有任何数据，使用TRUNCATE ONLY会报错 跳过了使用继承的分区，后面再看 分区修剪(Partition Pruning) 分区修剪是一种提高性能的查询优化技术。 例如 12SET enable_partition_pruning = on; -- the defaultSELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01'; 如果没有分区修剪，那么pg会扫描分区表的所有的分区来计算数量。如果开启了分区修剪，计划器会查看每个分区的定义来提前排除掉不需要查询的分区。 分区修剪是基于分区键的而不是基于索引的，因此是否对分区键建立索引取决于你需要查询分区的一大部分还是一小部分，如果是一大部分，那么建立索引是没有用的。 分区修剪不仅在计划阶段有效，在执行阶段也有效 分区约束排除(Constraint exclusion) Constraint exclusion是一种类似于分区修剪的查询优化技术。主要是利用CHECK约束实现，在计划阶段有效，比分区修剪慢 默认情况下constraint_exclusion的值是partition，这个值表示约束排除仅工作在继承分区表上，on代表在所有的查询上都检查check约束 注意点： 约束排除仅在计划阶段有用 约束排除仅在查询的where条件包含常量的时候有用。 分区的约束应该简单，否则约束排除无法判断是否需要访问子表。 最佳实践 最关键一点是你选择的分区的列（或者多列）。通常最好的选择是那些经常出现在where中的列。与分区绑定约束兼容的where可以用来修剪不需要的分区。然而，由于primary key和 unique约束也可能做出其它选择。删除数据也是一个计划分区策略的一个考虑因素。 选择分区的数量也是一个重要的因素。分区太少导致索引仍然很大和数据的局部性仍然很低。分区太多，会导致更长的查询计划时间和查询计划和执行期间的更高的内存占用。同时，在设置分区的数目的时候，也需要为将来考虑。 当预期一个分区会变的很大的时候采用子分区是有用的。而如果采用多列范围分区会导致分区的数目变多，因此要加以限制 考虑查询计划和执行阶段的开销是重要的。如果查询能够允许查询计划器修剪大部分分区，那个查询计划器能够处理几千个分区的查询，否则的话，计划时间就会变长内存消耗也会变高，对UPDATE和DELETE同样如此。另一个原因是，服务器的内存消耗会随着时间的推移而显著增长，尤其是大量会话都涉及到分区的情况，这是因为每一个涉及到分区查询的会话都会把分区元数据信息加载到自己的本地内存中 数据库负载类型，warehouse(数据仓库 OLAP On-line Analytical Processing)类型使用大量分区要比OLTP(On-line Transaction Processing 在线事务交易)更有意义。因为，在数据仓库类型中，查询计划时间不重要，因为大部分时间都在查询执行时间。根据数据库的负载类型早做决定。 OLAP 在线分析处理，查询一般都非常复杂，因此执行时间会比较长，主要是提供报表之类的功能 OLTP 在线事务处理，短时间内会有大量的插入、删除、更新语句，要求非常快的查询处理，","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"schema 和 search_path","date":"2021-05-10T13:11:37.000Z","path":"2021/05/10/schema-and-search-path/","text":"一个postgres集群中可以包含多个database，每个database包含了一个或者多个schema,schema包含了表、数据类型、函数以及操作符，不同的schema可以包含相同的表。 1234create schema myschema; #创建一个新的schemadrop schema mychema; # 删除一个空的的schemadrop schema mychema cascade; # 删除一个非空的schemaCREATE SCHEMA schema_name AUTHORIZATION user_name; #创建一个属于某用户的schema 在写sql语句的时候，可以通过schema.table来区分对应的schema里的表 查看schema 123select nspname from pg_catalog.pg_namespace; SELECT schema_name FROM information_schema.schemata;# 参考地址 https://soft-builder.com/how-to-list-all-schemas-in-postgresql/ 1\\dn #在psql中执行，但是看不到系统级别的schema 一般在写sql语句的时候不会特意指定schema，如果没有指定schema的话，数据库会根据search_path的值来查找schema里的表 查看search_path的值 1show search_path; #默认值为 $user,public 修改search_path 1set search_path to myschema,public #将search_path的值设置成mychema和public 此时，如果用如下sql语句创建表(没有指定schema)，pg数据库会在search_path中第一个存在的schema创建对应的表 1create table testdb(id int); #由于search_path的值是myschema,public 所以此时表被创建在myschema中 可以直接指定schema让表创建在指定的schema中 12create table public.testdb1(id int); #直接在pubic中创建testdb1create table public.testdb(id int); #直接在pubic中创建testdb,由于在不同的schema中，所以table的名字可以重复 此时如果用 \\d 查看当前数据的表，可以看出testdb1在public中，但是没有看见public下有testdb，这是因为pg已经在位置靠前的schema中发现testdb了，会忽略靠后的schema中相同名字的表。但是这个表是真实存在的，可以通过在表名前面加scheme前缀来进行查询和更改。 安全策略 约束每个用户只使用自己私有的schema，先使用下面语句禁止别的用户操作public schema，然后为每个用户创建和用户名同名的schema 1REVOKE CREATE ONSCHEMA public FROM PUBLIC 通过设置 ALTER ROLE ALL SET search_path = “$user” 将所有用户的search_path设置成$user 保持默认 仅数据库只有一个用户或者少数几个受信任的用户的时候使用","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"窗口函数","date":"2021-05-10T12:27:12.000Z","path":"2021/05/10/windows-function/","text":"窗口函数在一组与当前行有某种联系的表行上进行计算。这个看起来和聚集函数有些相似，但是不同的是，不像聚集函数那样将结果输出为一条，而是每行保留自己的标识。这一点看下面的例子来说明： 用聚集函数来计算各地区的员工工资总和 1select city,sum(salary) from empsalary group by city; 用窗口函数来计算工资总和 1SELECT id,name,city,salary, sum(salary) OVER (partition by city) FROM empsalary; 值得注意的是，在聚集函数中，SELECL后面不能有没有出现在ORDER BY后面的属性，而窗口函数是可以的 窗口函数的调用会始终在窗口函数和参数的后面加一个OVER，在语法上就将窗口函数和其它函数区分开来。OVER子句决定了如何分割查询后的行以便于窗口函数来处理。其中，OVER中的 PARTITION BY子句决定了如何将数据分区，ORDER BY子句则可以控制窗口函数处理行的顺序 例如下面的例子是根据工资进行排名 1SELECT name,salary,rank() OVER (ORDER BY salary desc) FROM empsalary; 使用rank()函数时，排名会出现终端，例如，存在两个第一名，那么加下来的名次就是第三名，如果需要连续的名次，可以使用dense_rank() 分区函数的几个特性 和聚合函数相比，聚合函数只能输出每组的单一行，而窗口函数可以输出每一行包含其它属性的结果 聚合函数操作的对象是 query查询（where、group by、having之后）的结果，例如如果一行记录不满足where条件，那么这条记录对窗口函数不可见 如果顺序不重要，可以省略order by，如果分区不重要，可以省略partition by，相当于全表了 另外一个关于窗口函数重要的事情是，对于每一行，在其分区内都有一组叫做window frame的行。有一些窗口函数（例如sum）仅在window frame的行上起作用，而不是整个分区。默认情况下，如果指定了order by，那么frame是由从分区开始到当前行，然后加上根据order by指定的顺序和当前行相等的行。如果order by是空的，默认的frame由分区内的所有行组成。(这个是postgres的默认设置，可以更改window frame的行为) 第4条我们来看例子来理解 如果OVER子句中没有指定ORDER BY 1SELECT salary, sum(salary) OVER () FROM empsalary; 查询的结果是 因为此时没有指定order by，所以每一行在分区内对应的window frame包含了当前分区的所有行，然后对于sum的计算，就是当前分区内所有行的salary的总和。（因为也没有指定partition by，所以window frame包含了整张表） 如果OVER子句中指定了ORDER BY 1SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; 查询的结果是 这时候因为指定了order by,所以每一行在分区内对应的windows frame是不一样的。例如，第3、4行在分区内对应的window frame就应该是（1，2，3，3），所以其sum的值是9","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"聚集函数","date":"2021-05-10T12:15:02.000Z","path":"2021/05/10/aggregate-function/","text":"最近工作和数据库有关，就借着这个机会好好学一下postgresql。 像其它的大多数关系型数据库一样，postgresql支持聚集函数(aggregate function).聚集函数从多行记录中计算出一个单一的结果。例如count,sum,avg.max,min等等 下面的例子是查询最高温度 1SELECT max(temp_lo) FROM weather; 如果需要知道最高温度对应的城市，也许会尝试下面的查询语句 1SELECT city FROM weather WHERE temp_lo = max(temp_lo) 但是这个查询是错误的，因为聚集函数是在where之后才执行的。但是我们可以通过子查询来实现这样的要求 1SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather) 聚集函数通常和GROUP BY一起使用，例如下面的例子，可以查询每个城市的最高温度 1SELECT city, max(temp_lo) FROM weather GROUP BY city 可以通过HAVING来过滤结果,例如下面的查询最高气温小于40度的城市 1SELECT city, max(temp_lo) FROM weather GROUP BY city HAVING max(temp_lo) &lt; 40 聚合函数中 where 和 having 区别 where发生在分组和聚合之前，控制了哪些数据需要分组和聚合，这也是为什么where条件中不能使用聚合函数的原因 having则相反，发生在分组和聚合之后，所以having一般都包含了聚合函数。虽然也允许在having中不使用聚合函数，但是放在where中更加高效","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"linux禁止root用户远程登录，并修改ssh端口","date":"2021-05-09T09:52:36.000Z","path":"2021/05/09/Linux-forbids-remote-login-of-root/","text":"前言在创建一台新服务器以后，为了安全考虑，要修改ssh的端口为其它端口，同时禁止root用户远程登陆。 由于需要设置禁止root用户远程登陆，因此需要先创建一个普通用户，使用这个普通用户登陆以后，再使用su命令切换到root用户 创建新用户例如，我们使用下面的命令创建一个名为jerry的用户 1sudo adduser jerry 执行结果如下图所示，除了密码是必填的以外，其它的选项可以为空 创建了新用户以后，就可以使用这个用户来进行登陆了。如果不想要这个用户了，可以使用下面的命令来删除此用户 1sudo userdel -r jerry 禁止root用户远程登陆以及修改端口使用vim打开/etc/ssh/sshd_config文件后进入编辑模式 在配置文件中找到下面两项分别进行修改 12Port 22 # 将22修改为别的端口,例如修改成2222PermitRootLogin yes # 将yes修改为no 修改完成后保存并重启ssh服务 1sudo systemctl restart sshd 注意有些云服务(比如阿里云或者腾讯云)有安全组策略，需要在安全组策略里将上面修改后的端口添加到安全组中，否则将会无法登陆 测试修改完毕后，可以测试一下用root用户进行登录 1ssh -p 2222 root@***.***.***.*** #注意把端口换成修改后的端口 从下图可以看出,root用户已经无法登陆了 这时候我们尝试使用jerry用户进行登陆 1ssh -p 2222 jerry@***.***.***.*** jerry可以远程登陆到服务器上 然后切换到root用户即可 如果担心这样做还不安全的话，也可以彻底禁止使用用户名密码登陆，改用使用密钥文件登陆的方式，有兴趣的可以自己去搜索怎么做","tags":[{"name":"linux","slug":"linux","permalink":"https://www.lixf.io/tags/linux/"},{"name":"运维","slug":"运维","permalink":"https://www.lixf.io/tags/运维/"}]},{"title":"ios 微信自带浏览器上webrtc不能正常使用的解决方法","date":"2021-03-26T10:34:04.000Z","path":"2021/03/26/webrtc-in-ios-weixin-browser/","text":"以下内容只适用于 ios版本 &gt;= 14 微信版本 &gt;= 8.0，其余版本请自行测试 最近使用到了webrtc，在其它各端(包括safari浏览器、iOS企业微信)测试没问题后，唯独在ios版微信浏览器上不能正常使用，查看日志，发现webrtc各个流程都已正常建立，包括onHandleTrackd都已经触发，video.srcObject也已经执行，收集的统计信息也说明webrtc的视频流数据也在正常传输，就是没有显示画面。 百度和谷歌了一下，也不知道是不是因为iOS版微信浏览器刚刚支持webrtc的缘故，只有一则3月10多日的新闻说随着ios的更新，采用wkwebview的微信浏览器也已经支持webrtc，再没有其它有用的资料。 后来看了一个使用webrtc支持ios版微信浏览器的网站，发现玄机竟然是下面的代码 123document.addEventListener(\"WeixinJSBridgeReady\", function () &#123; document.getElementById(\"remoteVideo\").play();&#125;, false); 加上去以后，测试OK，可以不用加班了 值得注意的是，WeixinJSBridgeReady这个事件会在页面加载后马上触发，因此，上面的这个代码最好写在window.onload=&gt;(){}函数体中，所以video标签也要提前写在html网页中，不要等webrtc通道建立后再去动态创建video。 顺便贴一下我的video标签使用的属性 12&lt;video preload=\"auto\" autoplay=\"autoplay\" x-webkit-airplay=\"true\" playsinline =\"true\" webkit-playsinline =\"true\" x5-video-player-type=\"h5\" x5-video-player-fullscreen=\"true\" x5-video-orientation=\"portraint\"&gt;&lt;/video&gt; 业余前端，写的不对请见谅。","tags":[{"name":"webrtc","slug":"webrtc","permalink":"https://www.lixf.io/tags/webrtc/"},{"name":"微信浏览器","slug":"微信浏览器","permalink":"https://www.lixf.io/tags/微信浏览器/"}]},{"title":"解决mapbox中事件冲突的几种方法","date":"2020-06-21T07:25:19.000Z","path":"2020/06/21/mapbox-event-conflict2/","text":"最近在基于mapbox做项目，随着功能越来越多，mapbox上的事件冲突也越来越严重。比如说一个人需要实现在地图上点击一下出现一个弹窗显示当前地点的效果，另外一个人需要实现在地图上点击选中某片区域的功能，最终得到的效果是当用户在地图上点击以后既出现了弹窗又选中了某片区域。 例如下面的代码会导致点击地图后同时在控制台打印两条信息12345678map.on(\"load\", () =&gt; &#123; map.on(\"click\",() =&gt; &#123; console.log(\"click 1\") &#125;) map.on(\"click\",() =&gt; &#123; console.log(\"click 2\") &#125;) &#125;); 从下图中可以看出click事件被响应了两次 下面是解决这些问题的一些思路，仅供参考。 e.preventDefault e.preventDefault()本身是用来阻止事件发生后的默认行为的。例如下面的代码可以屏蔽掉mapbox的拖拽移动等功能 12345map.on(\"load\", () =&gt; &#123; map.on(\"mousedown\", e =&gt; &#123; e.preventDefault(); &#125;) &#125;); 但是默认情况下这个只会阻止mapbox上的一些默认行为，只在代码里加一个e.preventDefault并不能阻止我们自己代码里的一些冲突。所幸的是，在调用了e.preventDefault()之后，e.defaultPrevented会被修改为true，因此，我们的代码里可以通过判断这个值来避免事件的冲突。下面是示例代码:12345678910111213141516map.on(\"load\", () =&gt; &#123; map.on(\"click\",e =&gt; &#123; if(e.defaultPrevented)&#123; return; &#125; e.preventDefault(); console.log(\"click 1\") &#125;) map.on(\"click\",e =&gt; &#123; if(e.defaultPrevented)&#123; return; &#125; e.preventDefault(); console.log(\"click 2\") &#125;)&#125;); 从下图中可以看出click事件被响应了一次（实际上是两次，但是第二次直接返回了） 故意出错这个方案不太好，就是故意加一些出错的代码，这样js在执行到出错的代码后就不再往下执行了。12345678910map.on(\"load\", () =&gt; &#123; map.on(\"click\",e =&gt; &#123; console.log(\"click 1\") console.log(i) &#125;) map.on(\"click\",e =&gt; &#123; console.log(\"click 2\") console.log(i) &#125;)&#125;); 从下图中可以看出click事件被响应了一次但是相信这样的代码对于大多数人来说连编译都过不了 重写mapbox的on和off方法前面的方法1虽然可以避免部分的事件冲突，但是一方面我们的遗留代码比较多，一处一处的修改不太现实，另一方面除了解决冲突外，我们可能也会希望有些监听能够优先被响应（类似于css中的z-index）。熟悉面向对象的朋友都应该知道子类可以重写父类的方法。因此我们可以设计出一个子类来继承mapboxgl.Map，重写Map的on和off方法，同时也要考虑兼容以前的用法。 由于我的代码水平不高，下面的代码完全仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class iMap extends mapboxgl.Map &#123; constructor(options) &#123; super(options); &#125; off(type, arg1, arg2) &#123; let listener = typeof arg1 === \"function\" ? arg1 : arg2; if (this.listenerMap[type]) &#123; let index = this.listenerMap[type].findIndex( (l) =&gt; l.listener === listener ); if (index != -1) &#123; this.listenerMap[type].splice(index, 1); &#125; &#125; &#125; /** *支持两种调用形式 * on(type, layerId, listener, priority, forceCall) * on(type, listener, priority, forceCall) * priority为优先级，值越大在调用链中越靠前 * forceCall为强制调用，如果为true,则即使前面的事件屏蔽了事件的传播，仍然会被调用 * 由于priority和forceCall为可选属性，因此，新的on接口完全兼容原来的接口 */ on(type, arg1, arg2, arg3, arg4) &#123; this.listenerMap = this.listenerMap || &#123;&#125;; let listener = undefined; let priority = 0; let forceCall = false; let layerId; if (typeof arg1 === \"function\") &#123; // arg1 为listener arg2为优先级, arg3为是否强制调用 if (arg2 &amp;&amp; typeof arg2 === \"number\") &#123; priority = arg2; &#125; if (arg3 &amp;&amp; typeof arg3 === \"boolean\") &#123; forceCall = arg1; &#125; listener = arg1; &#125; else &#123; // arg1 为图层ID，arg2为listener, arg3为优先级，arg4为是否强制调用 layerId = arg1; if (arg3 &amp;&amp; typeof arg3 === \"number\") &#123; priority = arg3; &#125; if (arg4 &amp;&amp; typeof arg4 === \"boolean\") &#123; forceCall = arg4; &#125; listener = arg2; &#125; if (listener) &#123; if (this.listenerMap[type] === undefined) &#123; //注册事件 this.listenerMap[type] = []; super.on(type, (event) =&gt; &#123; let eventNotStop = true; let sortListeners = this.listenerMap[type].sort( (a, b) =&gt; b.priority - a.priority ); let filterLayers; if (event.point) &#123; //如果事件包含点事件的话需要进行过滤出哪些图层包含了这些点。如果事件是绑定在图层上的话，需要这个来判断是否需要被调用 filterLayers = this._whichLayerContainsGeometry( event.point, sortListeners .map((l) =&gt; l.layerId) .filter((item) =&gt; item !== undefined) ); &#125; for (let listener of sortListeners) &#123; if ( !filterLayers || !listener.layerId || filterLayers.findIndex((l) =&gt; l === listener.layerId) !== -1 ) &#123; if (eventNotStop) &#123; let executeResult = listener.listener(event); eventNotStop = executeResult === undefined ? true : executeResult; &#125; else &#123; //事件已经被终止，只允许forceCall的lisnten被调用 if (listener.forceCall) &#123; listener.listener(event); &#125; &#125; &#125; &#125; &#125;); &#125; this.listenerMap[type].push(&#123; priority: priority, layerId: layerId, forceCall: forceCall, listener: listener, &#125;); &#125; &#125; _whichLayerContainsGeometry(geometry, layers) &#123; let newlayers = []; for (let layer of layers) &#123; if (this.getLayer(layer)) &#123; newlayers.push(layer); &#125; &#125; let features = this.queryRenderedFeatures(geometry, &#123; layers: newlayers, &#125;); let targetLayers = features.map((f) =&gt; f.layer.id); return targetLayers; &#125;&#125; 使用的话，只需要把原来的new mapboxgl.Map() 换成 new iMap() 12345678mapboxgl.accessToken =\"&lt;your access token&gt;\";var map = new iMap(&#123; container: \"map\", style: \"mapbox://styles/mapbox/streets-v11\", center: [-74.5, 40], zoom: 9, &#125;); 下面是调用示例123456789101112131415map.on(\"load\", () =&gt; &#123; map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然我排在第一个，但是由于我的优先级低(默认为0)，而且前面的调用返回了false，所以我不会被调用\"); &#125;); map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然前面的调用返回了false，但是我的forceCall被设置为了true，所以仍然会被调用\"); &#125;,1,true); map.on(\"click\", (e) =&gt; &#123; console.log(\"我的优先级排第二，我要阻止事件的继续向下传播\"); return false; &#125;,7); map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然我排在最后，但是由于我的优先级最高，会被第一个调用\"); &#125;,9);&#125;); 下面是执行结果 完整代码请参考这个地址 同时基于iMap，我们也可以重写mapbox.marker，来避免两个marker在重叠时点击其中一个marker会导致两个marker都响应点击事件的情况","tags":[{"name":"mapbox","slug":"mapbox","permalink":"https://www.lixf.io/tags/mapbox/"},{"name":"前端开发","slug":"前端开发","permalink":"https://www.lixf.io/tags/前端开发/"}]},{"title":"正则表达式在线匹配/替换测试","date":"2020-06-18T10:41:04.000Z","path":"2020/06/18/regex-online/","text":"本页面提供了在线测试正则表达式的功能。 请输入待匹配文本 请输入正则表达式 &nbsp;&nbsp;测试匹配&nbsp;&nbsp;测试替换 匹配结果 let matchBtn = document.getElementById(\"matchBtn\"); let replaceBtn = document.getElementById(\"replaceBtn\"); let matchContentInput = document.getElementById(\"matchContent\"); let regexStrInput = document.getElementById(\"regexStr\"); let replacewordInput = document.getElementById(\"replaceword\"); let resultArea = document.getElementById(\"result\"); matchBtn.onclick = function(){ let matchContent = matchContentInput.value; let regexStr = regexStrInput.value let regex = new RegExp(regexStr, \"g\"); let matches = [...matchContent.matchAll(regex)] resultArea.value = matches.length !== 0 ? JSON.stringify(matches,null, 4) : \"无匹配结果，请检查正则表达式是否正确\" } replaceBtn.onclick= function(){ let matchContent = matchContentInput.value; let regexStr = regexStrInput.value let rw = replacewordInput.value let regex = new RegExp(regexStr, \"g\"); matchContent = matchContent.replace(regex,rw) resultArea.value = matchContent }","tags":[{"name":"在线转换","slug":"在线转换","permalink":"https://www.lixf.io/tags/在线转换/"},{"name":"在线匹配","slug":"在线匹配","permalink":"https://www.lixf.io/tags/在线匹配/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.lixf.io/tags/正则表达式/"}]},{"title":"二维码在线生成","date":"2020-05-13T07:39:30.000Z","path":"2020/05/13/text-to-qrcode/","text":"在线生成二维码，也可以直接在本链接后面加入?text=要转换的文字，例如https://www.lixf.io/2020/05/13/text-to-qrcode/?text=hello 待转换的文字 二维码在下面，右键点击保存 let qrcodeImg = document.getElementById('qrcode'); let qrtext = document.getElementById(\"qrtext\") function generateQRcode() { qrcodeImg.innerHTML = \"\"; new QRCode(qrcodeImg, { text: qrtext.value, width: 200, height: 200 }); } function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(\"&\"); for (var i = 0; i < vars.length; i++) { var pair = vars[i].split(\"=\"); if (pair[0] == variable) { return pair[1]; } } return (false); } let text = getQueryVariable(\"text\") if(text){ qrtext.value = decodeURIComponent(text); } window.addEventListener(\"load\",function(){ generateQRcode() })","tags":[{"name":"在线工具","slug":"在线工具","permalink":"https://www.lixf.io/tags/在线工具/"},{"name":"二维码","slug":"二维码","permalink":"https://www.lixf.io/tags/二维码/"},{"name":"在线生成二维码","slug":"在线生成二维码","permalink":"https://www.lixf.io/tags/在线生成二维码/"}]},{"title":"文件在线转base64字符串和base64字符串在线转图片","date":"2020-05-12T08:16:10.000Z","path":"2020/05/12/file-to-base64-and-base64-to-img/","text":"本页面提供了文件转base64字符串以及base64字符串转图片的功能。你也可以直接在本文链接后面加入参数base64Str，值为图片的base64编码,例如https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/?base64Str=data:image/png;base64,xxxxxxxxx可直接打开上面链接查看示例 文件名:未知&nbsp;&nbsp;文件大小:未知&nbsp;&nbsp; 文件类型:未知&nbsp;&nbsp; 转图片&nbsp;&nbsp; 清空结果 let dropbox = document.getElementById(\"dropbox\"); let filename = document.getElementById(\"filename\"); let filetype = document.getElementById(\"filetype\"); let filesize = document.getElementById(\"filesize\"); let base64result = document.getElementById(\"result\"); let base64ToImgBtn = document.getElementById(\"base64ToImgBtn\") let clearBtn = document.getElementById(\"clearBtn\") dropbox.addEventListener(\"dragenter\", e => { e.stopPropagation(); e.preventDefault(); dropbox.style.border = \"2px solid green\" }, false); dropbox.addEventListener(\"dragleave\", e => { e.stopPropagation(); e.preventDefault(); dropbox.style.border = \"1px solid black\" }, false); dropbox.addEventListener(\"dragover\", e => { e.stopPropagation(); e.preventDefault(); }, false); dropbox.addEventListener(\"drop\", e => { e.stopPropagation(); e.preventDefault(); var dt = e.dataTransfer; let files = dt.files; handleFiles(files); }, false); clearBtn.addEventListener(\"click\",()=>{ base64result.value = \"\" }) base64ToImgBtn.addEventListener(\"click\",()=>{ let popup = document.getElementById('popup') if(popup){ popup.parentNode.remove(popup) } let base64Str = base64result.value showBase64Pic(base64Str) }) let base64Str = getQueryVariable(\"base64Str\") if(base64Str){ base64result.value = base64Str showBase64Pic(base64Str) } function handleFiles(files) { if (files.length > 0) { base64result.value = \"正在处理中，请稍后\" let file = files[0]; let fileSize = file.size; let fileName = file.name; let fileType = file.type; filename.innerText = fileName; filetype.innerText = fileType; filesize.innerText = wellFileSize(fileSize); if (fileSize { base64result.value = e.target.result; } reader.readAsDataURL(file); } else { base64result.value = \"文件太大了，请选择小于3M的文件\"; } }else{ base64result.value = \"请选择一个文件\"; } } function wellFileSize(size) { if (size","tags":[{"name":"在线转换","slug":"在线转换","permalink":"https://www.lixf.io/tags/在线转换/"},{"name":"base64编码","slug":"base64编码","permalink":"https://www.lixf.io/tags/base64编码/"},{"name":"文件转base64","slug":"文件转base64","permalink":"https://www.lixf.io/tags/文件转base64/"},{"name":"base64转图片","slug":"base64转图片","permalink":"https://www.lixf.io/tags/base64转图片/"}]},{"title":"利用阿里云的OSS将markdown中的本地路径的图片替换为网络图片","date":"2020-05-07T13:09:46.000Z","path":"2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/","text":"这个方法太麻烦了，我自己都不用了 概述在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。 常见的有下面的方法来解决这个问题: 将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。 如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件(点击这里查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。 这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。 我们可以参考这篇博客，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。 解决方案综上，我写了一个小工具md-img-oss来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。如图，分别是替换前和替换后的效果 安装md-img-oss安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装1go get github.com/lixiaofei123/md-img-oss 如果本地没有golang环境，点击这里附件:md-img-oss下载对应平台的软件。 使用安装完毕后，执行下面的命令，即可自动替换图片链接 12md-img-oss -mddir \"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\" -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId &lt;替换成你的accesskeyId&gt; -accessKeySecret &lt;替换成你的accesskeySecret&gt; -bucketName &lt;替换成你的bucketName&gt; -ossDir lixfio/image -domain https://static.lixfio.huiyuanai.cn# ossDir 和 domain 是非必须的，可以不需要 如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令 也可以执行下面的命令查看各个参数的意思 1md-img-oss --help 下面是执行结果","tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.lixf.io/tags/markdown/"},{"name":"图床","slug":"图床","permalink":"https://www.lixf.io/tags/图床/"}]},{"title":"拓展nextcloud中ocdownloader的功能","date":"2020-05-06T08:32:03.000Z","path":"2020/05/06/Expand-the-function-of-ocdownloader/","text":"本文只针对不熟悉php的用户 经过上文的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。 首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点 其能够从指定的http链接上下载其对应的文件， 其大部分功能都是通过调用第三方工具实现 根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。 开发工具这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具 该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接 至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。 拓展代码一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。 为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。 下面是修改步骤 首先，将其插件代码克隆到本地 1https://github.com/e-alfred/ocdownloader.git 然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。 例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace OCA\\ocDownloader\\Controller\\Lib;class PBUtil&#123; private $PBDLBinary = null; private $URL = null; private $ProxyAddress = null; private $ProxyPort = 0; // 构造函数需要传入pbutil的执行文件路径，以及视频链接 // 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码 public function __construct($PBDLBinary, $URL)&#123; $this-&gt;PBDLBinary = $PBDLBinary; $this-&gt;URL = $URL; &#125; public function setProxy($ProxyAddress, $ProxyPort) &#123; $this-&gt;ProxyAddress = $ProxyAddress; $this-&gt;ProxyPort = $ProxyPort; &#125; // 这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。 public function getVideoUrl()&#123; $Proxy = null; if (!is_null($this-&gt;ProxyAddress) &amp;&amp; $this-&gt;ProxyPort &gt; 0 &amp;&amp; $this-&gt;ProxyPort &lt;= 65536) &#123; $Proxy = ' -proxy ' . rtrim($this-&gt;ProxyAddress, '/') . ':' . $this-&gt;ProxyPort; &#125; $Output = shell_exec( $this-&gt;PBDLBinary.' -videoUrl \\''.$this-&gt;URL.'\\' ' .(is_null($Proxy) ? '' : $Proxy) ); return $Output; &#125;&#125; 然后修改controller目录下的httpdownloader.php文件， 首先，在99行的上面，也就是 if($isMagnet)这个代码的上面，加入下面的代码片段 1234567891011$sourceUrl = $_POST['FILE'];if (strpos($sourceUrl, '******') !== false) &#123; //******换成视频网站的名字，例如 youku $pbUtil = new PBUtil('/usr/bin/pbutil', $sourceUrl); //传入执行文件路径以及视频链接 if (!is_null($this - &gt; ProxyAddress) &amp;&amp; $this - &gt; ProxyPort &gt; 0 &amp;&amp; $this - &gt; ProxyPort &lt;= 65536) &#123; $pbUtil - &gt; SetProxy($this - &gt; ProxyAddress, $this - &gt; ProxyPort); &#125; $respdata = $pbUtil - &gt; GetVideoUrl(); $jsondata = json_decode($respdata); //获取返回结果后调用json解析 $sourceUrl = $jsondata - &gt; url; // 获取资源链接 $videotitle = $jsondata - &gt; title.'.mp4'; //获取文件名称&#125; 接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl 然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码 123if (isset($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; 0) &#123; $OPTIONS['out'] = $videotitle;&#125; 部署插件将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!! 视频封面默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客Nextcloud: Install Preview Generator","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"开源网盘nextcloud使用介绍","date":"2020-04-29T07:31:52.000Z","path":"2020/04/29/nextcloud-in-docker/","text":"NextCloud是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。 预览登录 主页 文件列表 下载下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆 Docker部署部署的文档官网写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看官网说明，这里就不再详说了 1docker run -d -p 8080:80 nextcloud 离线下载这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。 离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问插件主页下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。 效果如图: 从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。 鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。 下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。 如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。 12docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli# 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错 启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如 1docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria 然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 http://proxy.com ，端口是 7777 设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。 HTTPS我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书 虽然简单，我们还是要做一些准备工作。 第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar 由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。 在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，点击这里参考官方文档进行配置。 1234proxy_connect_timeout 600;proxy_send_timeout 600;proxy_read_timeout 600;client_max_body_size 10000m; 这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器 1234567docker run --detach \\--restart=always --name nginx-proxy \\--publish 80:80 \\--volume /usr/share/nginx/html \\--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro \\--volume /var/run/docker.sock:/tmp/docker.sock:ro \\jwilder/nginx-proxy nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将me@foo.bar换成自己的邮箱 123456docker run --detach \\ --name nginx-proxy-letsencrypt \\ --volumes-from nginx-proxy \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ --env \"DEFAULT_EMAIL=me@foo.bar\" \\ jrcs/letsencrypt-nginx-proxy-companion 最后就可以启动nextcloud容器啦 12345678910docker run --detach \\ --name nextcloud \\ --restart always \\ --link proxy.com\\ --env \"VIRTUAL_HOST=pan.foo.bar\" \\ --env \"VIRTUAL_PORT=3000\" \\ --env \"LETSENCRYPT_HOST=pan.foo.bar\" \\ --env \"LETSENCRYPT_EMAIL=me@foo.bar\" \\ --v /data/nextcloud:/var/www/html \\ mrlee326/nextcloud-aria 启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。 值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。 最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。 必备的插件nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】 Mind Map用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制 Draw.io用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。 其它现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"GoLang 内存模型","date":"2019-09-20T07:34:41.000Z","path":"2019/09/20/The-Go-Memory-Model/","text":"Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。 Happens Before在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。 Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。 在单线程中，happens-before的顺序和代码表达的顺序是一致的。 现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。 读操作r不happen before写操作w (有可能是并发发生) 没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生) 如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。 写操作w happen before 读操作r 任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。 Synchronization初始化如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前 If a package p imports package q, the completion of q‘s init functions happens before the start of any of p‘s. main方法happen after所有的init方法结束之后 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程创建新启动一个协程happens before这个协程的执行 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程的销毁协程的结束不保证happen before于程序中的任何事件。 The exit of a goroutine is not guaranteed to happen before any event in the program 例如下面这个例子 123456var a stringfunc hello() &#123; go func() &#123; a = \"hello\" &#125;() print(a)&#125; 对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果 channel 通信golang里有一个很重要的思想不要通过共享内存来通信，而是通过通信来共享内存. Don’t communicate by sharing memory; share memory by communicating. 对应channel，也有几条重要的happens-before规则 对channel发送数据happens before于对于此channel相应的接收。 A send on a channel happens before the corresponding receive from that channel completes. 例如下面代码 12345678910111213var c = make(chan int, 10)var a stringfunc f() &#123; a = \"hello, world\" c &lt;- 0&#125;func main() &#123; go f() &lt;-c print(a)&#125; 能够确保输出 “hello world”。 a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。 关闭channel happens before 接收channel因关闭返回的０值 The closing of a channel happens before a receive that returns a zero value because the channel is closed. 从一个没有缓冲的channel里接收值happens before向这个channel发送值 A receive from an unbuffered channel happens before the send on that channel completes. 这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。 12345678910111213var c = make(chan int)var a stringfunc f() &#123; a = \"hello, world\" &lt;- c&#125;func main() &#123; go f() c &lt;- 0 print(a)&#125; 一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送 The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes. 例如下面这个例子，可以确保同时只有三个协程在执行w() 123456789101112var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func(w func()) &#123; limit &lt;- 1 w() &lt;-limit &#125;(w) &#125; select&#123;&#125;&#125; Locks对于sync.Mutex或者sync.RWMutex 变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁 For any sync.Mutex or sync.RWMutex variable l and n &lt; m**, call n of l.Unlock() happens before call m of l.Lock() returns. 例如 1234567891011121314var l sync.Mutexvar a stringfunc f() &#123; a = \"hello, world\" l.Unlock()&#125;func main() &#123; l.Lock() go f() l.Lock() print(a)&#125; 在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world” happens before print(a)，因此可以确保输出”hello, world” For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n**+1 to l.Lock. Oncegolang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。 once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。 A single call of f() from once.Do(f) happens (returns) before any call of once.Do(f) returns. 例如这个程序 12345678910111213141516var a stringvar once sync.Oncefunc setup() &#123; a = &quot;hello, world&quot;&#125;func doprint() &#123; once.Do(setup) print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 不正确的同步在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。 看下面的例子 12345678910111213141516var a, b intfunc f() &#123; a = 1 b = 2&#125;func g() &#123; print(b) print(a)&#125;func main() &#123; go f() g()&#125; 上面输出的结果有可能是２ 0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生） 还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。 12345678910111213141516171819var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func doprint() &#123; if !done &#123; once.Do(setup) &#125; print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。 1234567891011121314var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func main() &#123; go setup() for !done &#123; &#125; print(a)&#125;","tags":[{"name":"golang学习","slug":"golang学习","permalink":"https://www.lixf.io/tags/golang学习/"}]},{"title":"将网页转换成本地应用程序","date":"2019-08-14T06:05:37.000Z","path":"2019/08/14/create-native-app-from-web-url/","text":"微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。 这里使用在线制作的方式 打开网址 https://appmaker.xyz/web2desk ，如下图 根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。 邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。 然后根据我前面的ubuntu制作桌面图标制作成桌面图标就好","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"ubuntu制作桌面图标","date":"2019-08-14T05:54:09.000Z","path":"2019/08/14/ubuntu-create-desktop-icon/","text":"在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。 这里以typora为例说一下怎么制作，其实也很简单 进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容 12345678910[Desktop Entry]Encoding=UTF-8Name=TyporaComment=TyporaExec=/home/lixf/software/Typora/TyporaIcon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.pngTerminal=falsestarttupNotify=trueType=ApplicationCategories=Application;Development; 保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"我的私人书签记录","date":"2019-06-28T01:46:34.000Z","path":"2019/06/28/My-personal-bookmarks/","text":"保存一下工作中常用的网址 k8s相关 k8s官网文档 helm官方仓库 nginx-ingress 部署 operator-framework ambassador Istio文档 docker相关 Docker官方文档 Dockerfile文档 Docker官方仓库 常用镜像地址 阿里云镜像 清华镜像 中科大镜像 Azure中国镜像","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"}]},{"title":"临时复制粘贴处","date":"2019-06-17T07:05:19.000Z","path":"2019/06/17/textarea/","text":"粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地） Date.prototype.Format = function(fmt) { var o = { \"M+\" : this.getMonth() + 1, \"d+\" : this.getDate(), \"h+\" : this.getHours(), \"m+\" : this.getMinutes(), \"s+\" : this.getSeconds(), \"q+\" : Math.floor((this.getMonth() + 3) / 3), \"S\" : this.getMilliseconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt; } var editbox = document.getElementById(\"editbox\"); if(localStorage.autoSave == undefined){ localStorage.autoSave = \"\"; } editbox.value = localStorage.autoSave; setInterval(function(){ var value = editbox.value; var saveValue = localStorage.autoSave; if(value != saveValue){ localStorage.autoSave = value; document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\"; } },1000 * 3);","tags":[{"name":"在线工具","slug":"在线工具","permalink":"https://www.lixf.io/tags/在线工具/"},{"name":"临时保存","slug":"临时保存","permalink":"https://www.lixf.io/tags/临时保存/"}]},{"title":"docker下载镜像的时候出现handshake failure","date":"2019-06-13T11:38:59.000Z","path":"2019/06/13/docker-pull-remote-error-tls-handshake-failure/","text":"在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误 1Error response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure 在pod所运行的服务器上执行curl https://www.baidu.com也报了下面的错误 1234567891011121314[root@k8s-master ~]# curl https://www.baidu.comcurl: (60) Peer&apos;s Certificate issuer is not recognized.More details here: http://curl.haxx.se/docs/sslcerts.htmlcurl performs SSL certificate verification by default, using a &quot;bundle&quot; of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn&apos;t adequate, you can specify an alternate file using the --cacert option.If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL).If you&apos;d like to turn off curl&apos;s verification of the certificate, use the -k (or --insecure) option. 在stackoverflow上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。 1ntpdate ntp1.aliyun.com 同步之后问题解决。 当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。 为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下） 1crontab -e 在里面加上这么一行命令,让每隔1分钟同步一下时间。 1*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"},{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"}]},{"title":"k8s相关镜像源整理","date":"2019-06-13T03:30:32.000Z","path":"2019/06/13/k8s-docker-images-mirrors/","text":"现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代 gcr.io ==&gt; registry.aliyuncs.com k8s.gcr.io ==&gt; registry.aliyuncs.com/google-containers quay.io ==&gt; quay-mirror.qiniu.com 在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源 gcr.io、k8s.gcr.io镜像加速gcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用Azure中国镜像 gcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn 例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1 对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers 例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4 quay.io镜像加速有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用Azure中国镜像来加快拉取速度 quay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn 例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取 1docker pull quay.azk8s.cn/dexidp/dex:v2.10.0 补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速 例如 1docker pull dockerhub.azk8s.cn/library/nginx helm镜像仓库Azure中国 对于helm也提供了国内的镜像地址 如果是新安装的helm,可以使用下面的命令进行初始化 1helm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/ 对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库 12345helm repo remove stablehelm repo add stable http://mirror.azure.cn/kubernetes/charts/helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/helm repo updatehelm repo list 除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://www.lixf.io/tags/k8s/"},{"name":"helm","slug":"helm","permalink":"https://www.lixf.io/tags/helm/"}]},{"title":"MYSQL创建数据库和用户","date":"2019-05-07T12:49:24.000Z","path":"2019/05/07/mysql-create-user/","text":"创建UTF-8编码的数据库1create database testbase default character set utf8 collate utf8_general_ci; 创建用户1create user &apos;testuser&apos;@&apos;%&apos; identified by &apos;password&apos;; 创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录 授权数据库给用户1grant select,insert,update,delete,create,drop on test.* to testuser; 授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作 刷新权限1flush privileges 取消授权1revoke all on *.* from testuser 删除用户1delete from mysql.user where user=&apos;testuser&apos;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.lixf.io/tags/mysql/"}]},{"title":"欢迎访问我的博客","date":"2019-05-07T12:16:23.000Z","path":"2019/05/07/welcome-my-blog/","text":"欢迎访问李小飞的个人博客","tags":[{"name":"欢迎","slug":"欢迎","permalink":"https://www.lixf.io/tags/欢迎/"},{"name":"博客","slug":"博客","permalink":"https://www.lixf.io/tags/博客/"}]}]