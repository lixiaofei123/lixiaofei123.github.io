[{"title":"很久没写博客了","date":"2021-06-26T13:32:50.000Z","path":"2021/06/26/I-haven-t-write-blog-for-a-long-time/","text":"没什么好写的。。。。!!! aaaa","tags":[]},{"title":"git和npm设置代理","date":"2021-05-19T08:04:22.000Z","path":"2021/05/19/git-set-proxy/","text":"由于不知名的原因，现在github.com不设置代理的话几乎无法访问。如下图所示，从github上克隆一个postgres，每秒的速度只有3到4KB。 下面分别提供通过https协议和ssh协议克隆仓库设置代理的方法 HTTPS协议如果我们本地有可以科学上网的http或者socket5代理的话，可以进行如下设置(只需要设置一个就行了) 12git config --global http.proxy http://127.0.0.1:10809 #走http代理git config --global http.proxy socks5://127.0.0.1:10808 #走socks5代理 设置完后再克隆，就可以发现拉取仓库的速度有了明显的提升（具体取决于代理的速度和当前网络的速度）。 此时，如果我们通过ssh协议克隆仓库，会发现克隆速度还是很慢(几乎是0)。如下图所示 这种情况下需要给ssh协议配置代理。 SSH协议配置通过ssh协议克隆仓库的话，需要socket5代理。windows用户在 C:\\Users\\用户名.ssh\\config 文件中增加下面的内容 (没有的话自行创建) 12Host github.comProxyCommand connect -S 127.0.0.1:10808 %h %p Linux在~/.ssh/config文件中增加下面内容 12Host github.comProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p 此时再克隆，可以看到速度明显有了提示 npm设置代理npm在国内拉取仓库时，也会特别慢，可以参考下面的配置来设置代理 12npm config set proxy http://127.0.0.1:10809npm config set https-proxy http://127.0.0.1:10809","tags":[{"name":"git","slug":"git","permalink":"https://www.lixf.io/tags/git/"},{"name":"代理","slug":"代理","permalink":"https://www.lixf.io/tags/代理/"}]},{"title":"表分区","date":"2021-05-10T13:22:39.000Z","path":"2021/05/10/table-partitioning/","text":"表分区是指将一个逻辑上的大表分成几个物理小块。表分区可以提供下面几个好处 当要查询的数据在同一个分区或者少数几个分区的时候，可以显著提高查询性能。分区有效代替了索引树的上层部分，看起来就像重度使用的部分放在了内存中一样。个人理解是，如果使用索引，数据库每次要从磁盘中加载索引，由于索引从上到下扫描索引树来查找数据，所以对索引树的上层部分的查询是很频繁的。使用了分区以后，分区数据已经相当于索引树的上层部分了，相当于最经常使用的部分已经放在了内存中了(原因参考最佳实践第4条)。 当查询或者更新占据单独的一个分区的很大比例的时候，通过使用顺序扫描会比使用索引有性能提升。因为索引会在整个表上进行随机读取，随机读取比顺序读取慢得多。 如果使用了设计模式的话，批量加载和删除可以通过分区来完成。直接加载某个分区的数据或者直接删除某个分区的数据要比批量删除快得多。 很少使用的数据可以被迁移到便宜的介质上 postgres支持的几个默认的分区方法 Range Partitioning 范围分区是根据表中的某个或者某几个字段进行分区，例如 1-10 11-20 List Partitioning 通过显式的列出表中的键值对来进行分区 Hash Partitioning 通过为每个分区指定一个除数和余来进行分区。即每一行的hash值除以除数然后得到余，根据余值来放到对应的分区里 分区使用示例 通过指定partitioning by 创建分区表 12345CREATE TABLE measurement ( city_id int not null, logdate date not null, peaktemp int, unitsales int) PARTITION BY RANGE (logdate); 分别创建每一个分区 12CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');CREATE TABLE measurement_y2006m03 PARTITION OF measurement FOR VALUES FROM ('2006-03-01') TO ('2006-04-01') PARTITION BY RANGE (peaktemp); #创建分区表的分区表 如果插入一条不对应任何分区的数据，那么插入会报错，应该手动创建对应的分区 创建索引 1CREATE INDEX ON measurement (logdate); 创建索引是非必须的，分区表上的索引和约束条件都是虚拟的，实际上的索引位置和约束条件都在分区中 确定 数据库配置中 enable_partition_pruning 的值不是禁用状态 分区维护 删除某个分区的数据 12DROP TABLE measurement_y2006m02; # 快速删除数百万条数据，需要在主表上加ACCESS EXCLUSIVEALTER TABLE measurement DETACH PARTITION measurement_y2006m02; #接触分区和分区表的关系，同时保留数据，数据可以做进一步的分析 增加新的分区 1CREATE TABLE measurement_y2008m02 PARTITION OF measurement FOR VALUES FROM (&apos;2008-02-01&apos;) TO (&apos;2008-03-01&apos;) TABLESPACE fasttablespace; 先创建表，再创建分区表 12345CREATE TABLE measurement_y2008m02 (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS) TABLESPACE fasttablespace;ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02 CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );\\copy measurement_y2008m02 from 'measurement_y2008m02'-- possibly some other data preparation workALTER TABLE measurement ATTACH PARTITION measurement_y2008m02 FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' ); 创建索引 123CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);CREATE INDEX measurement_usls_200602_idx ON measurement_y2006m02 (unitsales);ALTER INDEX measurement_usls_idx ATTACH PARTITION measurement_usls_200602_idx; 同样的方式可以用在primary和unique上 123ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);ALTER INDEX measurement_city_id_logdate_key ATTACH PARTITION measurement_y2006m02_city_id_logdate_key 分区表限制 分区表的唯一约束必须包含所有的分区键列。因为各个分区只能保证在自己表中的唯一约束性，保证不了全表的唯一约束性，因此分区表自身必须负责在不同的分区中没有重复。如果唯一约束包含了分区键，那么各个分区对应的唯一约束中的分区键都不同，因此也就保证了在所有分区中的唯一约束都成立 无法创建排除约束（exclusion constraint），原因同上，分区不能跨区排除 insert的BEFORE ROW 触发器不能更改新行的目标区。即 在BEFORE ROW触发器中修改了分区键的值，分区的结果也不会改变。 分区表 临时表和永久表不能混用。分区表是临时的，那么分区也是临时的，分区表是永久的，那么分区也是永久的。 ​ 分区表的幕后是分区和分区表是继承关系，但并不是可以使用所有的继承特性。尤其是分区不能有分区表中不存在的字段，分区表和分区也并不能继承其它表。 ​ 不能使用的继承特性有 分区不能有分区表中不存在的字段 分区表的CHECK和NOT NULL约束会被它的所有分区继承。不能在分区表上使用被标记了NO INHERIT的CHECK。如果分区表的字段上有NOT NULL的话，分区的字段上的NOT NULL不能被删除 当分区表上没有任何分区的时候可以使用ONLY来增加约束，当存在分区的时候，使用ONLY会报错。替代的可以在分区上添加和删除（如果父表中没有）约束 后续再看 分区表本身没有任何数据，使用TRUNCATE ONLY会报错 跳过了使用继承的分区，后面再看 分区修剪(Partition Pruning) 分区修剪是一种提高性能的查询优化技术。 例如 12SET enable_partition_pruning = on; -- the defaultSELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01'; 如果没有分区修剪，那么pg会扫描分区表的所有的分区来计算数量。如果开启了分区修剪，计划器会查看每个分区的定义来提前排除掉不需要查询的分区。 分区修剪是基于分区键的而不是基于索引的，因此是否对分区键建立索引取决于你需要查询分区的一大部分还是一小部分，如果是一大部分，那么建立索引是没有用的。 分区修剪不仅在计划阶段有效，在执行阶段也有效 分区约束排除(Constraint exclusion) Constraint exclusion是一种类似于分区修剪的查询优化技术。主要是利用CHECK约束实现，在计划阶段有效，比分区修剪慢 默认情况下constraint_exclusion的值是partition，这个值表示约束排除仅工作在继承分区表上，on代表在所有的查询上都检查check约束 注意点： 约束排除仅在计划阶段有用 约束排除仅在查询的where条件包含常量的时候有用。 分区的约束应该简单，否则约束排除无法判断是否需要访问子表。 最佳实践 最关键一点是你选择的分区的列（或者多列）。通常最好的选择是那些经常出现在where中的列。与分区绑定约束兼容的where可以用来修剪不需要的分区。然而，由于primary key和 unique约束也可能做出其它选择。删除数据也是一个计划分区策略的一个考虑因素。 选择分区的数量也是一个重要的因素。分区太少导致索引仍然很大和数据的局部性仍然很低。分区太多，会导致更长的查询计划时间和查询计划和执行期间的更高的内存占用。同时，在设置分区的数目的时候，也需要为将来考虑。 当预期一个分区会变的很大的时候采用子分区是有用的。而如果采用多列范围分区会导致分区的数目变多，因此要加以限制 考虑查询计划和执行阶段的开销是重要的。如果查询能够允许查询计划器修剪大部分分区，那个查询计划器能够处理几千个分区的查询，否则的话，计划时间就会变长内存消耗也会变高，对UPDATE和DELETE同样如此。另一个原因是，服务器的内存消耗会随着时间的推移而显著增长，尤其是大量会话都涉及到分区的情况，这是因为每一个涉及到分区查询的会话都会把分区元数据信息加载到自己的本地内存中 数据库负载类型，warehouse(数据仓库 OLAP On-line Analytical Processing)类型使用大量分区要比OLTP(On-line Transaction Processing 在线事务交易)更有意义。因为，在数据仓库类型中，查询计划时间不重要，因为大部分时间都在查询执行时间。根据数据库的负载类型早做决定。 OLAP 在线分析处理，查询一般都非常复杂，因此执行时间会比较长，主要是提供报表之类的功能 OLTP 在线事务处理，短时间内会有大量的插入、删除、更新语句，要求非常快的查询处理，","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"schema 和 search_path","date":"2021-05-10T13:11:37.000Z","path":"2021/05/10/schema-and-search-path/","text":"一个postgres集群中可以包含多个database，每个database包含了一个或者多个schema,schema包含了表、数据类型、函数以及操作符，不同的schema可以包含相同的表。 1234create schema myschema; #创建一个新的schemadrop schema mychema; # 删除一个空的的schemadrop schema mychema cascade; # 删除一个非空的schemaCREATE SCHEMA schema_name AUTHORIZATION user_name; #创建一个属于某用户的schema 在写sql语句的时候，可以通过schema.table来区分对应的schema里的表 查看schema 123select nspname from pg_catalog.pg_namespace; SELECT schema_name FROM information_schema.schemata;# 参考地址 https://soft-builder.com/how-to-list-all-schemas-in-postgresql/ 1\\dn #在psql中执行，但是看不到系统级别的schema 一般在写sql语句的时候不会特意指定schema，如果没有指定schema的话，数据库会根据search_path的值来查找schema里的表 查看search_path的值 1show search_path; #默认值为 $user,public 修改search_path 1set search_path to myschema,public #将search_path的值设置成mychema和public 此时，如果用如下sql语句创建表(没有指定schema)，pg数据库会在search_path中第一个存在的schema创建对应的表 1create table testdb(id int); #由于search_path的值是myschema,public 所以此时表被创建在myschema中 可以直接指定schema让表创建在指定的schema中 12create table public.testdb1(id int); #直接在pubic中创建testdb1create table public.testdb(id int); #直接在pubic中创建testdb,由于在不同的schema中，所以table的名字可以重复 此时如果用 \\d 查看当前数据的表，可以看出testdb1在public中，但是没有看见public下有testdb，这是因为pg已经在位置靠前的schema中发现testdb了，会忽略靠后的schema中相同名字的表。但是这个表是真实存在的，可以通过在表名前面加scheme前缀来进行查询和更改。 安全策略 约束每个用户只使用自己私有的schema，先使用下面语句禁止别的用户操作public schema，然后为每个用户创建和用户名同名的schema 1REVOKE CREATE ONSCHEMA public FROM PUBLIC 通过设置 ALTER ROLE ALL SET search_path = “$user” 将所有用户的search_path设置成$user 保持默认 仅数据库只有一个用户或者少数几个受信任的用户的时候使用","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"窗口函数","date":"2021-05-10T12:27:12.000Z","path":"2021/05/10/windows-function/","text":"窗口函数在一组与当前行有某种联系的表行上进行计算。这个看起来和聚集函数有些相似，但是不同的是，不像聚集函数那样将结果输出为一条，而是每行保留自己的标识。这一点看下面的例子来说明： 用聚集函数来计算各地区的员工工资总和 1select city,sum(salary) from empsalary group by city; 用窗口函数来计算工资总和 1SELECT id,name,city,salary, sum(salary) OVER (partition by city) FROM empsalary; 值得注意的是，在聚集函数中，SELECL后面不能有没有出现在ORDER BY后面的属性，而窗口函数是可以的 窗口函数的调用会始终在窗口函数和参数的后面加一个OVER，在语法上就将窗口函数和其它函数区分开来。OVER子句决定了如何分割查询后的行以便于窗口函数来处理。其中，OVER中的 PARTITION BY子句决定了如何将数据分区，ORDER BY子句则可以控制窗口函数处理行的顺序 例如下面的例子是根据工资进行排名 1SELECT name,salary,rank() OVER (ORDER BY salary desc) FROM empsalary; 使用rank()函数时，排名会出现终端，例如，存在两个第一名，那么加下来的名次就是第三名，如果需要连续的名次，可以使用dense_rank() 分区函数的几个特性 和聚合函数相比，聚合函数只能输出每组的单一行，而窗口函数可以输出每一行包含其它属性的结果 聚合函数操作的对象是 query查询（where、group by、having之后）的结果，例如如果一行记录不满足where条件，那么这条记录对窗口函数不可见 如果顺序不重要，可以省略order by，如果分区不重要，可以省略partition by，相当于全表了 另外一个关于窗口函数重要的事情是，对于每一行，在其分区内都有一组叫做window frame的行。有一些窗口函数（例如sum）仅在window frame的行上起作用，而不是整个分区。默认情况下，如果指定了order by，那么frame是由从分区开始到当前行，然后加上根据order by指定的顺序和当前行相等的行。如果order by是空的，默认的frame由分区内的所有行组成。(这个是postgres的默认设置，可以更改window frame的行为) 第4条我们来看例子来理解 如果OVER子句中没有指定ORDER BY 1SELECT salary, sum(salary) OVER () FROM empsalary; 查询的结果是 因为此时没有指定order by，所以每一行在分区内对应的window frame包含了当前分区的所有行，然后对于sum的计算，就是当前分区内所有行的salary的总和。（因为也没有指定partition by，所以window frame包含了整张表） 如果OVER子句中指定了ORDER BY 1SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; 查询的结果是 这时候因为指定了order by,所以每一行在分区内对应的windows frame是不一样的。例如，第3、4行在分区内对应的window frame就应该是（1，2，3，3），所以其sum的值是9","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"聚集函数","date":"2021-05-10T12:15:02.000Z","path":"2021/05/10/aggregate-function/","text":"最近工作和数据库有关，就借着这个机会好好学一下postgresql。 像其它的大多数关系型数据库一样，postgresql支持聚集函数(aggregate function).聚集函数从多行记录中计算出一个单一的结果。例如count,sum,avg.max,min等等 下面的例子是查询最高温度 1SELECT max(temp_lo) FROM weather; 如果需要知道最高温度对应的城市，也许会尝试下面的查询语句 1SELECT city FROM weather WHERE temp_lo = max(temp_lo) 但是这个查询是错误的，因为聚集函数是在where之后才执行的。但是我们可以通过子查询来实现这样的要求 1SELECT city FROM weather WHERE temp_lo = (SELECT max(temp_lo) FROM weather) 聚集函数通常和GROUP BY一起使用，例如下面的例子，可以查询每个城市的最高温度 1SELECT city, max(temp_lo) FROM weather GROUP BY city 可以通过HAVING来过滤结果,例如下面的查询最高气温小于40度的城市 1SELECT city, max(temp_lo) FROM weather GROUP BY city HAVING max(temp_lo) &lt; 40 聚合函数中 where 和 having 区别 where发生在分组和聚合之前，控制了哪些数据需要分组和聚合，这也是为什么where条件中不能使用聚合函数的原因 having则相反，发生在分组和聚合之后，所以having一般都包含了聚合函数。虽然也允许在having中不使用聚合函数，但是放在where中更加高效","tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.lixf.io/tags/数据库/"},{"name":"postgresql","slug":"postgresql","permalink":"https://www.lixf.io/tags/postgresql/"}]},{"title":"linux禁止root用户远程登录，并修改ssh端口","date":"2021-05-09T09:52:36.000Z","path":"2021/05/09/Linux-forbids-remote-login-of-root/","text":"前言在创建一台新服务器以后，为了安全考虑，要修改ssh的端口为其它端口，同时禁止root用户远程登陆。 由于需要设置禁止root用户远程登陆，因此需要先创建一个普通用户，使用这个普通用户登陆以后，再使用su命令切换到root用户 创建新用户例如，我们使用下面的命令创建一个名为jerry的用户 1sudo adduser jerry 执行结果如下图所示，除了密码是必填的以外，其它的选项可以为空 创建了新用户以后，就可以使用这个用户来进行登陆了。如果不想要这个用户了，可以使用下面的命令来删除此用户 1sudo userdel -r jerry 禁止root用户远程登陆以及修改端口使用vim打开/etc/ssh/sshd_config文件后进入编辑模式 在配置文件中找到下面两项分别进行修改 12Port 22 # 将22修改为别的端口,例如修改成2222PermitRootLogin yes # 将yes修改为no 修改完成后保存并重启ssh服务 1sudo systemctl restart sshd 注意有些云服务(比如阿里云或者腾讯云)有安全组策略，需要在安全组策略里将上面修改后的端口添加到安全组中，否则将会无法登陆 测试修改完毕后，可以测试一下用root用户进行登录 1ssh -p 2222 root@***.***.***.*** #注意把端口换成修改后的端口 从下图可以看出,root用户已经无法登陆了 这时候我们尝试使用jerry用户进行登陆 1ssh -p 2222 jerry@***.***.***.*** jerry可以远程登陆到服务器上 然后切换到root用户即可 如果担心这样做还不安全的话，也可以彻底禁止使用用户名密码登陆，改用使用密钥文件登陆的方式，有兴趣的可以自己去搜索怎么做","tags":[{"name":"linux","slug":"linux","permalink":"https://www.lixf.io/tags/linux/"},{"name":"运维","slug":"运维","permalink":"https://www.lixf.io/tags/运维/"}]},{"title":"ios 微信自带浏览器上webrtc不能正常使用的解决方法","date":"2021-03-26T10:34:04.000Z","path":"2021/03/26/webrtc-in-ios-weixin-browser/","text":"以下内容只适用于 ios版本 &gt;= 14 微信版本 &gt;= 8.0，其余版本请自行测试 最近使用到了webrtc，在其它各端(包括safari浏览器、iOS企业微信)测试没问题后，唯独在ios版微信浏览器上不能正常使用，查看日志，发现webrtc各个流程都已正常建立，包括onHandleTrackd都已经触发，video.srcObject也已经执行，收集的统计信息也说明webrtc的视频流数据也在正常传输，就是没有显示画面。 百度和谷歌了一下，也不知道是不是因为iOS版微信浏览器刚刚支持webrtc的缘故，只有一则3月10多日的新闻说随着ios的更新，采用wkwebview的微信浏览器也已经支持webrtc，再没有其它有用的资料。 后来看了一个使用webrtc支持ios版微信浏览器的网站，发现玄机竟然是下面的代码 123document.addEventListener(\"WeixinJSBridgeReady\", function () &#123; document.getElementById(\"remoteVideo\").play();&#125;, false); 加上去以后，测试OK，可以不用加班了 值得注意的是，WeixinJSBridgeReady这个事件会在页面加载后马上触发，因此，上面的这个代码最好写在window.onload=&gt;(){}函数体中，所以video标签也要提前写在html网页中，不要等webrtc通道建立后再去动态创建video。 顺便贴一下我的video标签使用的属性 12&lt;video preload=\"auto\" autoplay=\"autoplay\" x-webkit-airplay=\"true\" playsinline =\"true\" webkit-playsinline =\"true\" x5-video-player-type=\"h5\" x5-video-player-fullscreen=\"true\" x5-video-orientation=\"portraint\"&gt;&lt;/video&gt; 业余前端，写的不对请见谅。","tags":[{"name":"webrtc","slug":"webrtc","permalink":"https://www.lixf.io/tags/webrtc/"},{"name":"微信浏览器","slug":"微信浏览器","permalink":"https://www.lixf.io/tags/微信浏览器/"}]},{"title":"解决mapbox中事件冲突的几种方法","date":"2020-06-21T07:25:19.000Z","path":"2020/06/21/mapbox-event-conflict2/","text":"最近在基于mapbox做项目，随着功能越来越多，mapbox上的事件冲突也越来越严重。比如说一个人需要实现在地图上点击一下出现一个弹窗显示当前地点的效果，另外一个人需要实现在地图上点击选中某片区域的功能，最终得到的效果是当用户在地图上点击以后既出现了弹窗又选中了某片区域。 例如下面的代码会导致点击地图后同时在控制台打印两条信息12345678map.on(\"load\", () =&gt; &#123; map.on(\"click\",() =&gt; &#123; console.log(\"click 1\") &#125;) map.on(\"click\",() =&gt; &#123; console.log(\"click 2\") &#125;) &#125;); 从下图中可以看出click事件被响应了两次 下面是解决这些问题的一些思路，仅供参考。 e.preventDefault e.preventDefault()本身是用来阻止事件发生后的默认行为的。例如下面的代码可以屏蔽掉mapbox的拖拽移动等功能 12345map.on(\"load\", () =&gt; &#123; map.on(\"mousedown\", e =&gt; &#123; e.preventDefault(); &#125;) &#125;); 但是默认情况下这个只会阻止mapbox上的一些默认行为，只在代码里加一个e.preventDefault并不能阻止我们自己代码里的一些冲突。所幸的是，在调用了e.preventDefault()之后，e.defaultPrevented会被修改为true，因此，我们的代码里可以通过判断这个值来避免事件的冲突。下面是示例代码:12345678910111213141516map.on(\"load\", () =&gt; &#123; map.on(\"click\",e =&gt; &#123; if(e.defaultPrevented)&#123; return; &#125; e.preventDefault(); console.log(\"click 1\") &#125;) map.on(\"click\",e =&gt; &#123; if(e.defaultPrevented)&#123; return; &#125; e.preventDefault(); console.log(\"click 2\") &#125;)&#125;); 从下图中可以看出click事件被响应了一次（实际上是两次，但是第二次直接返回了） 故意出错这个方案不太好，就是故意加一些出错的代码，这样js在执行到出错的代码后就不再往下执行了。12345678910map.on(\"load\", () =&gt; &#123; map.on(\"click\",e =&gt; &#123; console.log(\"click 1\") console.log(i) &#125;) map.on(\"click\",e =&gt; &#123; console.log(\"click 2\") console.log(i) &#125;)&#125;); 从下图中可以看出click事件被响应了一次但是相信这样的代码对于大多数人来说连编译都过不了 重写mapbox的on和off方法前面的方法1虽然可以避免部分的事件冲突，但是一方面我们的遗留代码比较多，一处一处的修改不太现实，另一方面除了解决冲突外，我们可能也会希望有些监听能够优先被响应（类似于css中的z-index）。熟悉面向对象的朋友都应该知道子类可以重写父类的方法。因此我们可以设计出一个子类来继承mapboxgl.Map，重写Map的on和off方法，同时也要考虑兼容以前的用法。 由于我的代码水平不高，下面的代码完全仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class iMap extends mapboxgl.Map &#123; constructor(options) &#123; super(options); &#125; off(type, arg1, arg2) &#123; let listener = typeof arg1 === \"function\" ? arg1 : arg2; if (this.listenerMap[type]) &#123; let index = this.listenerMap[type].findIndex( (l) =&gt; l.listener === listener ); if (index != -1) &#123; this.listenerMap[type].splice(index, 1); &#125; &#125; &#125; /** *支持两种调用形式 * on(type, layerId, listener, priority, forceCall) * on(type, listener, priority, forceCall) * priority为优先级，值越大在调用链中越靠前 * forceCall为强制调用，如果为true,则即使前面的事件屏蔽了事件的传播，仍然会被调用 * 由于priority和forceCall为可选属性，因此，新的on接口完全兼容原来的接口 */ on(type, arg1, arg2, arg3, arg4) &#123; this.listenerMap = this.listenerMap || &#123;&#125;; let listener = undefined; let priority = 0; let forceCall = false; let layerId; if (typeof arg1 === \"function\") &#123; // arg1 为listener arg2为优先级, arg3为是否强制调用 if (arg2 &amp;&amp; typeof arg2 === \"number\") &#123; priority = arg2; &#125; if (arg3 &amp;&amp; typeof arg3 === \"boolean\") &#123; forceCall = arg1; &#125; listener = arg1; &#125; else &#123; // arg1 为图层ID，arg2为listener, arg3为优先级，arg4为是否强制调用 layerId = arg1; if (arg3 &amp;&amp; typeof arg3 === \"number\") &#123; priority = arg3; &#125; if (arg4 &amp;&amp; typeof arg4 === \"boolean\") &#123; forceCall = arg4; &#125; listener = arg2; &#125; if (listener) &#123; if (this.listenerMap[type] === undefined) &#123; //注册事件 this.listenerMap[type] = []; super.on(type, (event) =&gt; &#123; let eventNotStop = true; let sortListeners = this.listenerMap[type].sort( (a, b) =&gt; b.priority - a.priority ); let filterLayers; if (event.point) &#123; //如果事件包含点事件的话需要进行过滤出哪些图层包含了这些点。如果事件是绑定在图层上的话，需要这个来判断是否需要被调用 filterLayers = this._whichLayerContainsGeometry( event.point, sortListeners .map((l) =&gt; l.layerId) .filter((item) =&gt; item !== undefined) ); &#125; for (let listener of sortListeners) &#123; if ( !filterLayers || !listener.layerId || filterLayers.findIndex((l) =&gt; l === listener.layerId) !== -1 ) &#123; if (eventNotStop) &#123; let executeResult = listener.listener(event); eventNotStop = executeResult === undefined ? true : executeResult; &#125; else &#123; //事件已经被终止，只允许forceCall的lisnten被调用 if (listener.forceCall) &#123; listener.listener(event); &#125; &#125; &#125; &#125; &#125;); &#125; this.listenerMap[type].push(&#123; priority: priority, layerId: layerId, forceCall: forceCall, listener: listener, &#125;); &#125; &#125; _whichLayerContainsGeometry(geometry, layers) &#123; let newlayers = []; for (let layer of layers) &#123; if (this.getLayer(layer)) &#123; newlayers.push(layer); &#125; &#125; let features = this.queryRenderedFeatures(geometry, &#123; layers: newlayers, &#125;); let targetLayers = features.map((f) =&gt; f.layer.id); return targetLayers; &#125;&#125; 使用的话，只需要把原来的new mapboxgl.Map() 换成 new iMap() 12345678mapboxgl.accessToken =\"&lt;your access token&gt;\";var map = new iMap(&#123; container: \"map\", style: \"mapbox://styles/mapbox/streets-v11\", center: [-74.5, 40], zoom: 9, &#125;); 下面是调用示例123456789101112131415map.on(\"load\", () =&gt; &#123; map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然我排在第一个，但是由于我的优先级低(默认为0)，而且前面的调用返回了false，所以我不会被调用\"); &#125;); map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然前面的调用返回了false，但是我的forceCall被设置为了true，所以仍然会被调用\"); &#125;,1,true); map.on(\"click\", (e) =&gt; &#123; console.log(\"我的优先级排第二，我要阻止事件的继续向下传播\"); return false; &#125;,7); map.on(\"click\", (e) =&gt; &#123; console.log(\"虽然我排在最后，但是由于我的优先级最高，会被第一个调用\"); &#125;,9);&#125;); 下面是执行结果 完整代码请参考这个地址 同时基于iMap，我们也可以重写mapbox.marker，来避免两个marker在重叠时点击其中一个marker会导致两个marker都响应点击事件的情况","tags":[{"name":"mapbox","slug":"mapbox","permalink":"https://www.lixf.io/tags/mapbox/"},{"name":"前端开发","slug":"前端开发","permalink":"https://www.lixf.io/tags/前端开发/"}]},{"title":"正则表达式在线匹配/替换测试","date":"2020-06-18T10:41:04.000Z","path":"2020/06/18/regex-online/","text":"本页面提供了在线测试正则表达式的功能。 请输入待匹配文本 请输入正则表达式 &nbsp;&nbsp;测试匹配&nbsp;&nbsp;测试替换 匹配结果 let matchBtn = document.getElementById(\"matchBtn\"); let replaceBtn = document.getElementById(\"replaceBtn\"); let matchContentInput = document.getElementById(\"matchContent\"); let regexStrInput = document.getElementById(\"regexStr\"); let replacewordInput = document.getElementById(\"replaceword\"); let resultArea = document.getElementById(\"result\"); matchBtn.onclick = function(){ let matchContent = matchContentInput.value; let regexStr = regexStrInput.value let regex = new RegExp(regexStr, \"g\"); let matches = [...matchContent.matchAll(regex)] resultArea.value = matches.length !== 0 ? JSON.stringify(matches,null, 4) : \"无匹配结果，请检查正则表达式是否正确\" } replaceBtn.onclick= function(){ let matchContent = matchContentInput.value; let regexStr = regexStrInput.value let rw = replacewordInput.value let regex = new RegExp(regexStr, \"g\"); matchContent = matchContent.replace(regex,rw) resultArea.value = matchContent }","tags":[{"name":"在线转换","slug":"在线转换","permalink":"https://www.lixf.io/tags/在线转换/"},{"name":"在线匹配","slug":"在线匹配","permalink":"https://www.lixf.io/tags/在线匹配/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.lixf.io/tags/正则表达式/"}]},{"title":"二维码在线生成","date":"2020-05-13T07:39:30.000Z","path":"2020/05/13/text-to-qrcode/","text":"在线生成二维码，也可以直接在本链接后面加入?text=要转换的文字，例如https://www.lixf.io/2020/05/13/text-to-qrcode/?text=hello 待转换的文字 二维码在下面，右键点击保存 let qrcodeImg = document.getElementById('qrcode'); let qrtext = document.getElementById(\"qrtext\") function generateQRcode() { qrcodeImg.innerHTML = \"\"; new QRCode(qrcodeImg, { text: qrtext.value, width: 200, height: 200 }); } function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(\"&\"); for (var i = 0; i < vars.length; i++) { var pair = vars[i].split(\"=\"); if (pair[0] == variable) { return pair[1]; } } return (false); } let text = getQueryVariable(\"text\") if(text){ qrtext.value = decodeURIComponent(text); } window.addEventListener(\"load\",function(){ generateQRcode() })","tags":[{"name":"在线工具","slug":"在线工具","permalink":"https://www.lixf.io/tags/在线工具/"},{"name":"二维码","slug":"二维码","permalink":"https://www.lixf.io/tags/二维码/"},{"name":"在线生成二维码","slug":"在线生成二维码","permalink":"https://www.lixf.io/tags/在线生成二维码/"}]},{"title":"文件在线转base64字符串和base64字符串在线转图片","date":"2020-05-12T08:16:10.000Z","path":"2020/05/12/file-to-base64-and-base64-to-img/","text":"本页面提供了文件转base64字符串以及base64字符串转图片的功能。你也可以直接在本文链接后面加入参数base64Str，值为图片的base64编码,例如https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/?base64Str=data:image/png;base64,xxxxxxxxx可直接打开上面链接查看示例 文件名:未知&nbsp;&nbsp;文件大小:未知&nbsp;&nbsp; 文件类型:未知&nbsp;&nbsp; 转图片&nbsp;&nbsp; 清空结果 let dropbox = document.getElementById(\"dropbox\"); let filename = document.getElementById(\"filename\"); let filetype = document.getElementById(\"filetype\"); let filesize = document.getElementById(\"filesize\"); let base64result = document.getElementById(\"result\"); let base64ToImgBtn = document.getElementById(\"base64ToImgBtn\") let clearBtn = document.getElementById(\"clearBtn\") dropbox.addEventListener(\"dragenter\", e => { e.stopPropagation(); e.preventDefault(); dropbox.style.border = \"2px solid green\" }, false); dropbox.addEventListener(\"dragleave\", e => { e.stopPropagation(); e.preventDefault(); dropbox.style.border = \"1px solid black\" }, false); dropbox.addEventListener(\"dragover\", e => { e.stopPropagation(); e.preventDefault(); }, false); dropbox.addEventListener(\"drop\", e => { e.stopPropagation(); e.preventDefault(); var dt = e.dataTransfer; let files = dt.files; handleFiles(files); }, false); clearBtn.addEventListener(\"click\",()=>{ base64result.value = \"\" }) base64ToImgBtn.addEventListener(\"click\",()=>{ let popup = document.getElementById('popup') if(popup){ popup.parentNode.remove(popup) } let base64Str = base64result.value showBase64Pic(base64Str) }) let base64Str = getQueryVariable(\"base64Str\") if(base64Str){ base64result.value = base64Str showBase64Pic(base64Str) } function handleFiles(files) { if (files.length > 0) { base64result.value = \"正在处理中，请稍后\" let file = files[0]; let fileSize = file.size; let fileName = file.name; let fileType = file.type; filename.innerText = fileName; filetype.innerText = fileType; filesize.innerText = wellFileSize(fileSize); if (fileSize { base64result.value = e.target.result; } reader.readAsDataURL(file); } else { base64result.value = \"文件太大了，请选择小于3M的文件\"; } }else{ base64result.value = \"请选择一个文件\"; } } function wellFileSize(size) { if (size","tags":[{"name":"在线转换","slug":"在线转换","permalink":"https://www.lixf.io/tags/在线转换/"},{"name":"base64编码","slug":"base64编码","permalink":"https://www.lixf.io/tags/base64编码/"},{"name":"文件转base64","slug":"文件转base64","permalink":"https://www.lixf.io/tags/文件转base64/"},{"name":"base64转图片","slug":"base64转图片","permalink":"https://www.lixf.io/tags/base64转图片/"}]},{"title":"利用阿里云的OSS将markdown中的本地路径的图片替换为网络图片","date":"2020-05-07T13:09:46.000Z","path":"2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/","text":"概述在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。 常见的有下面的方法来解决这个问题: 将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。 如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件(点击这里查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。 这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。 我们可以参考这篇博客，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。 解决方案综上，我写了一个小工具md-img-oss来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。如图，分别是替换前和替换后的效果 安装md-img-oss安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装1go get github.com/lixiaofei123/md-img-oss 如果本地没有golang环境，点击这里附件:md-img-oss下载对应平台的软件。 使用安装完毕后，执行下面的命令，即可自动替换图片链接 12md-img-oss -mddir \"C:\\Users\\Administrator\\Desktop\\lixiaofei123.github.io\\source\\_posts\" -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId &lt;替换成你的accesskeyId&gt; -accessKeySecret &lt;替换成你的accesskeySecret&gt; -bucketName &lt;替换成你的bucketName&gt; -ossDir lixfio/image -domain https://static.lixfio.huiyuanai.cn# ossDir 和 domain 是非必须的，可以不需要 如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令 也可以执行下面的命令查看各个参数的意思 1md-img-oss --help 下面是执行结果","tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.lixf.io/tags/markdown/"},{"name":"图床","slug":"图床","permalink":"https://www.lixf.io/tags/图床/"}]},{"title":"拓展nextcloud中ocdownloader的功能","date":"2020-05-06T08:32:03.000Z","path":"2020/05/06/Expand-the-function-of-ocdownloader/","text":"本文只针对不熟悉php的用户 经过上文的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。 首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点 其能够从指定的http链接上下载其对应的文件， 其大部分功能都是通过调用第三方工具实现 根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。 开发工具这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具 该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接 至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。 拓展代码一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。 为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。 下面是修改步骤 首先，将其插件代码克隆到本地 1https://github.com/e-alfred/ocdownloader.git 然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。 例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace OCA\\ocDownloader\\Controller\\Lib;class PBUtil&#123; private $PBDLBinary = null; private $URL = null; private $ProxyAddress = null; private $ProxyPort = 0; // 构造函数需要传入pbutil的执行文件路径，以及视频链接 // 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码 public function __construct($PBDLBinary, $URL)&#123; $this-&gt;PBDLBinary = $PBDLBinary; $this-&gt;URL = $URL; &#125; public function setProxy($ProxyAddress, $ProxyPort) &#123; $this-&gt;ProxyAddress = $ProxyAddress; $this-&gt;ProxyPort = $ProxyPort; &#125; // 这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。 public function getVideoUrl()&#123; $Proxy = null; if (!is_null($this-&gt;ProxyAddress) &amp;&amp; $this-&gt;ProxyPort &gt; 0 &amp;&amp; $this-&gt;ProxyPort &lt;= 65536) &#123; $Proxy = ' -proxy ' . rtrim($this-&gt;ProxyAddress, '/') . ':' . $this-&gt;ProxyPort; &#125; $Output = shell_exec( $this-&gt;PBDLBinary.' -videoUrl \\''.$this-&gt;URL.'\\' ' .(is_null($Proxy) ? '' : $Proxy) ); return $Output; &#125;&#125; 然后修改controller目录下的httpdownloader.php文件， 首先，在99行的上面，也就是 if($isMagnet)这个代码的上面，加入下面的代码片段 1234567891011$sourceUrl = $_POST['FILE'];if (strpos($sourceUrl, '******') !== false) &#123; //******换成视频网站的名字，例如 youku $pbUtil = new PBUtil('/usr/bin/pbutil', $sourceUrl); //传入执行文件路径以及视频链接 if (!is_null($this - &gt; ProxyAddress) &amp;&amp; $this - &gt; ProxyPort &gt; 0 &amp;&amp; $this - &gt; ProxyPort &lt;= 65536) &#123; $pbUtil - &gt; SetProxy($this - &gt; ProxyAddress, $this - &gt; ProxyPort); &#125; $respdata = $pbUtil - &gt; GetVideoUrl(); $jsondata = json_decode($respdata); //获取返回结果后调用json解析 $sourceUrl = $jsondata - &gt; url; // 获取资源链接 $videotitle = $jsondata - &gt; title.'.mp4'; //获取文件名称&#125; 接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl 然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码 123if (isset($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; 0) &#123; $OPTIONS['out'] = $videotitle;&#125; 部署插件将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!! 视频封面默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客Nextcloud: Install Preview Generator","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"开源网盘nextcloud使用介绍","date":"2020-04-29T07:31:52.000Z","path":"2020/04/29/nextcloud-in-docker/","text":"NextCloud是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。 预览登录 主页 文件列表 下载下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆 Docker部署部署的文档官网写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看官网说明，这里就不再详说了 1docker run -d -p 8080:80 nextcloud 离线下载这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。 离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问插件主页下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。 效果如图: 从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。 鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。 下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。 如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。 12docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli# 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错 启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如 1docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria 然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 http://proxy.com ，端口是 7777 设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。 HTTPS我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书 虽然简单，我们还是要做一些准备工作。 第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar 由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。 在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，点击这里参考官方文档进行配置。 1234proxy_connect_timeout 600;proxy_send_timeout 600;proxy_read_timeout 600;client_max_body_size 10000m; 这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器 1234567docker run --detach \\--restart=always --name nginx-proxy \\--publish 80:80 \\--volume /usr/share/nginx/html \\--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro \\--volume /var/run/docker.sock:/tmp/docker.sock:ro \\jwilder/nginx-proxy nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将me@foo.bar换成自己的邮箱 123456docker run --detach \\ --name nginx-proxy-letsencrypt \\ --volumes-from nginx-proxy \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ --env \"DEFAULT_EMAIL=me@foo.bar\" \\ jrcs/letsencrypt-nginx-proxy-companion 最后就可以启动nextcloud容器啦 12345678910docker run --detach \\ --name nextcloud \\ --restart always \\ --link proxy.com\\ --env \"VIRTUAL_HOST=pan.foo.bar\" \\ --env \"VIRTUAL_PORT=3000\" \\ --env \"LETSENCRYPT_HOST=pan.foo.bar\" \\ --env \"LETSENCRYPT_EMAIL=me@foo.bar\" \\ --v /data/nextcloud:/var/www/html \\ mrlee326/nextcloud-aria 启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。 值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。 最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。 必备的插件nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】 Mind Map用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制 Draw.io用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。 其它现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"GoLang 内存模型","date":"2019-09-20T07:34:41.000Z","path":"2019/09/20/The-Go-Memory-Model/","text":"Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。 Happens Before在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。 Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。 在单线程中，happens-before的顺序和代码表达的顺序是一致的。 现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。 读操作r不happen before写操作w (有可能是并发发生) 没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生) 如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。 写操作w happen before 读操作r 任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。 Synchronization初始化如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前 If a package p imports package q, the completion of q‘s init functions happens before the start of any of p‘s. main方法happen after所有的init方法结束之后 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程创建新启动一个协程happens before这个协程的执行 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程的销毁协程的结束不保证happen before于程序中的任何事件。 The exit of a goroutine is not guaranteed to happen before any event in the program 例如下面这个例子 123456var a stringfunc hello() &#123; go func() &#123; a = \"hello\" &#125;() print(a)&#125; 对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果 channel 通信golang里有一个很重要的思想不要通过共享内存来通信，而是通过通信来共享内存. Don’t communicate by sharing memory; share memory by communicating. 对应channel，也有几条重要的happens-before规则 对channel发送数据happens before于对于此channel相应的接收。 A send on a channel happens before the corresponding receive from that channel completes. 例如下面代码 12345678910111213var c = make(chan int, 10)var a stringfunc f() &#123; a = \"hello, world\" c &lt;- 0&#125;func main() &#123; go f() &lt;-c print(a)&#125; 能够确保输出 “hello world”。 a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。 关闭channel happens before 接收channel因关闭返回的０值 The closing of a channel happens before a receive that returns a zero value because the channel is closed. 从一个没有缓冲的channel里接收值happens before向这个channel发送值 A receive from an unbuffered channel happens before the send on that channel completes. 这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。 12345678910111213var c = make(chan int)var a stringfunc f() &#123; a = \"hello, world\" &lt;- c&#125;func main() &#123; go f() c &lt;- 0 print(a)&#125; 一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送 The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes. 例如下面这个例子，可以确保同时只有三个协程在执行w() 123456789101112var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func(w func()) &#123; limit &lt;- 1 w() &lt;-limit &#125;(w) &#125; select&#123;&#125;&#125; Locks对于sync.Mutex或者sync.RWMutex 变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁 For any sync.Mutex or sync.RWMutex variable l and n &lt; m**, call n of l.Unlock() happens before call m of l.Lock() returns. 例如 1234567891011121314var l sync.Mutexvar a stringfunc f() &#123; a = \"hello, world\" l.Unlock()&#125;func main() &#123; l.Lock() go f() l.Lock() print(a)&#125; 在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world” happens before print(a)，因此可以确保输出”hello, world” For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n**+1 to l.Lock. Oncegolang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。 once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。 A single call of f() from once.Do(f) happens (returns) before any call of once.Do(f) returns. 例如这个程序 12345678910111213141516var a stringvar once sync.Oncefunc setup() &#123; a = &quot;hello, world&quot;&#125;func doprint() &#123; once.Do(setup) print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 不正确的同步在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。 看下面的例子 12345678910111213141516var a, b intfunc f() &#123; a = 1 b = 2&#125;func g() &#123; print(b) print(a)&#125;func main() &#123; go f() g()&#125; 上面输出的结果有可能是２ 0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生） 还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。 12345678910111213141516171819var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func doprint() &#123; if !done &#123; once.Do(setup) &#125; print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。 1234567891011121314var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func main() &#123; go setup() for !done &#123; &#125; print(a)&#125;","tags":[{"name":"golang学习","slug":"golang学习","permalink":"https://www.lixf.io/tags/golang学习/"}]},{"title":"将网页转换成本地应用程序","date":"2019-08-14T06:05:37.000Z","path":"2019/08/14/create-native-app-from-web-url/","text":"微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。 这里使用在线制作的方式 打开网址 https://appmaker.xyz/web2desk ，如下图 根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。 邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。 然后根据我前面的ubuntu制作桌面图标制作成桌面图标就好","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"ubuntu制作桌面图标","date":"2019-08-14T05:54:09.000Z","path":"2019/08/14/ubuntu-create-desktop-icon/","text":"在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。 这里以typora为例说一下怎么制作，其实也很简单 进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容 12345678910[Desktop Entry]Encoding=UTF-8Name=TyporaComment=TyporaExec=/home/lixf/software/Typora/TyporaIcon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.pngTerminal=falsestarttupNotify=trueType=ApplicationCategories=Application;Development; 保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"我的私人书签记录","date":"2019-06-28T01:46:34.000Z","path":"2019/06/28/My-personal-bookmarks/","text":"保存一下工作中常用的网址 k8s相关 k8s官网文档 helm官方仓库 nginx-ingress 部署 operator-framework ambassador Istio文档 docker相关 Docker官方文档 Dockerfile文档 Docker官方仓库 常用镜像地址 阿里云镜像 清华镜像 中科大镜像 Azure中国镜像","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"}]},{"title":"临时复制粘贴处","date":"2019-06-17T07:05:19.000Z","path":"2019/06/17/textarea/","text":"粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地） Date.prototype.Format = function(fmt) { var o = { \"M+\" : this.getMonth() + 1, \"d+\" : this.getDate(), \"h+\" : this.getHours(), \"m+\" : this.getMinutes(), \"s+\" : this.getSeconds(), \"q+\" : Math.floor((this.getMonth() + 3) / 3), \"S\" : this.getMilliseconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt; } var editbox = document.getElementById(\"editbox\"); if(localStorage.autoSave == undefined){ localStorage.autoSave = \"\"; } editbox.value = localStorage.autoSave; setInterval(function(){ var value = editbox.value; var saveValue = localStorage.autoSave; if(value != saveValue){ localStorage.autoSave = value; document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\"; } },1000 * 3);","tags":[{"name":"在线工具","slug":"在线工具","permalink":"https://www.lixf.io/tags/在线工具/"},{"name":"临时保存","slug":"临时保存","permalink":"https://www.lixf.io/tags/临时保存/"}]},{"title":"docker下载镜像的时候出现handshake failure","date":"2019-06-13T11:38:59.000Z","path":"2019/06/13/docker-pull-remote-error-tls-handshake-failure/","text":"在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误 1Error response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure 在pod所运行的服务器上执行curl https://www.baidu.com也报了下面的错误 1234567891011121314[root@k8s-master ~]# curl https://www.baidu.comcurl: (60) Peer&apos;s Certificate issuer is not recognized.More details here: http://curl.haxx.se/docs/sslcerts.htmlcurl performs SSL certificate verification by default, using a &quot;bundle&quot; of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn&apos;t adequate, you can specify an alternate file using the --cacert option.If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL).If you&apos;d like to turn off curl&apos;s verification of the certificate, use the -k (or --insecure) option. 在stackoverflow上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。 1ntpdate ntp1.aliyun.com 同步之后问题解决。 当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。 为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下） 1crontab -e 在里面加上这么一行命令,让每隔1分钟同步一下时间。 1*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"},{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"}]},{"title":"k8s相关镜像源整理","date":"2019-06-13T03:30:32.000Z","path":"2019/06/13/k8s-docker-images-mirrors/","text":"现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代 gcr.io ==&gt; registry.aliyuncs.com k8s.gcr.io ==&gt; registry.aliyuncs.com/google-containers quay.io ==&gt; quay-mirror.qiniu.com 在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源 gcr.io、k8s.gcr.io镜像加速gcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用Azure中国镜像 gcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn 例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1 对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers 例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4 quay.io镜像加速有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用Azure中国镜像来加快拉取速度 quay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn 例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取 1docker pull quay.azk8s.cn/dexidp/dex:v2.10.0 补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速 例如 1docker pull dockerhub.azk8s.cn/library/nginx helm镜像仓库Azure中国 对于helm也提供了国内的镜像地址 如果是新安装的helm,可以使用下面的命令进行初始化 1helm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/ 对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库 12345helm repo remove stablehelm repo add stable http://mirror.azure.cn/kubernetes/charts/helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/helm repo updatehelm repo list 除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://www.lixf.io/tags/k8s/"},{"name":"helm","slug":"helm","permalink":"https://www.lixf.io/tags/helm/"}]},{"title":"MYSQL创建数据库和用户","date":"2019-05-07T12:49:24.000Z","path":"2019/05/07/mysql-create-user/","text":"创建UTF-8编码的数据库1create database testbase default character set utf8 collate utf8_general_ci; 创建用户1create user &apos;testuser&apos;@&apos;%&apos; identified by &apos;password&apos;; 创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录 授权数据库给用户1grant select,insert,update,delete,create,drop on test.* to testuser; 授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作 刷新权限1flush privileges 取消授权1revoke all on *.* from testuser 删除用户1delete from mysql.user where user=&apos;testuser&apos;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.lixf.io/tags/mysql/"}]},{"title":"欢迎访问我的博客","date":"2019-05-07T12:16:23.000Z","path":"2019/05/07/welcome-my-blog/","text":"欢迎访问李小飞的个人博客","tags":[{"name":"欢迎","slug":"欢迎","permalink":"https://www.lixf.io/tags/欢迎/"},{"name":"博客","slug":"博客","permalink":"https://www.lixf.io/tags/博客/"}]}]