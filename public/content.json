[{"title":"拓展nextcloud中ocdownloader的功能","date":"2020-05-06T08:32:03.000Z","path":"2020/05/06/Expand-the-function-of-ocdownloader/","text":"本文只针对不熟悉php的用户 经过上文的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。 首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点 其能够从指定的http链接上下载其对应的文件， 其大部分功能都是通过调用第三方工具实现 根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。 开发工具这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具 该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接 至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。 拓展代码一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。 为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。 下面是修改步骤 首先，将其插件代码克隆到本地 1https://github.com/e-alfred/ocdownloader.git 然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。 例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace OCA\\ocDownloader\\Controller\\Lib;class PBUtil&#123; private $PBDLBinary = null; private $URL = null; private $ProxyAddress = null; private $ProxyPort = 0; // 构造函数需要传入pbutil的执行文件路径，以及视频链接 // 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码 public function __construct($PBDLBinary, $URL)&#123; $this-&gt;PBDLBinary = $PBDLBinary; $this-&gt;URL = $URL; &#125; public function setProxy($ProxyAddress, $ProxyPort) &#123; $this-&gt;ProxyAddress = $ProxyAddress; $this-&gt;ProxyPort = $ProxyPort; &#125; // 这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。 public function getVideoUrl()&#123; $Proxy = null; if (!is_null($this-&gt;ProxyAddress) &amp;&amp; $this-&gt;ProxyPort &gt; 0 &amp;&amp; $this-&gt;ProxyPort &lt;= 65536) &#123; $Proxy = ' -proxy ' . rtrim($this-&gt;ProxyAddress, '/') . ':' . $this-&gt;ProxyPort; &#125; $Output = shell_exec( $this-&gt;PBDLBinary.' -videoUrl \\''.$this-&gt;URL.'\\' ' .(is_null($Proxy) ? '' : $Proxy) ); return $Output; &#125;&#125; 然后修改controller目录下的httpdownloader.php文件， 首先，在99行的上面，也就是 if($isMagnet)这个代码的上面，加入下面的代码片段 1234567891011$sourceUrl = $_POST['FILE'];if (strpos($sourceUrl, '******') !== false) &#123; //******换成视频网站的名字，例如 youku $pbUtil = new PBUtil('/usr/bin/pbutil', $sourceUrl); //传入执行文件路径以及视频链接 if (!is_null($this - &gt; ProxyAddress) &amp;&amp; $this - &gt; ProxyPort &gt; 0 &amp;&amp; $this - &gt; ProxyPort &lt;= 65536) &#123; $pbUtil - &gt; SetProxy($this - &gt; ProxyAddress, $this - &gt; ProxyPort); &#125; $respdata = $pbUtil - &gt; GetVideoUrl(); $jsondata = json_decode($respdata); //获取返回结果后调用json解析 $sourceUrl = $jsondata - &gt; url; // 获取资源链接 $videotitle = $jsondata - &gt; title.'.mp4'; //获取文件名称&#125; 接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl 然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码 123if (isset($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; 0) &#123; $OPTIONS['out'] = $videotitle;&#125; 部署插件将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!! 视频封面默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客Nextcloud: Install Preview Generator","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"开源网盘nextcloud使用介绍","date":"2020-04-29T07:31:52.000Z","path":"2020/04/29/nextcloud-in-docker/","text":"NextCloud是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。 预览登录 主页 文件列表 下载下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆 Docker部署部署的文档官网写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看官网说明，这里就不再详说了 1docker run -d -p 8080:80 nextcloud 离线下载这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。 离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问插件主页下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。 效果如图: 从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。 注意，要保证nextcloud对应的用户(nextcloud官方镜像中nextcloud对应的用户是www-data)对aria2有执行权限。 鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。 下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。 如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。 12docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli# 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错 启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如 1docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria 然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 http://proxy.com ，端口是 7777 设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。 HTTPS我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书 虽然简单，我们还是要做一些准备工作。 第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar 由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。 在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，点击这里参考官方文档进行配置。 1234proxy_connect_timeout 600;proxy_send_timeout 600;proxy_read_timeout 600;client_max_body_size 10000m; 这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器 1234567docker run --detach \\--restart=always --name nginx-proxy \\--publish 80:80 \\--volume /usr/share/nginx/html \\--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro \\--volume /var/run/docker.sock:/tmp/docker.sock:ro \\jwilder/nginx-proxy nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将me@foo.bar换成自己的邮箱 123456docker run --detach \\ --name nginx-proxy-letsencrypt \\ --volumes-from nginx-proxy \\ --volume /var/run/docker.sock:/var/run/docker.sock:ro \\ --env \"DEFAULT_EMAIL=me@foo.bar\" \\ jrcs/letsencrypt-nginx-proxy-companion 最后就可以启动nextcloud容器啦 12345678910docker run --detach \\ --name nextcloud \\ --restart always \\ --link proxy.com\\ --env \"VIRTUAL_HOST=pan.foo.bar\" \\ --env \"VIRTUAL_PORT=3000\" \\ --env \"LETSENCRYPT_HOST=pan.foo.bar\" \\ --env \"LETSENCRYPT_EMAIL=me@foo.bar\" \\ --v /data/nextcloud:/var/www/html \\ mrlee326/nextcloud-aria 启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。 值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。 最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。 必备的插件nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】 Mind Map用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制 Draw.io用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。 其它现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。","tags":[{"name":"nextcloud","slug":"nextcloud","permalink":"https://www.lixf.io/tags/nextcloud/"},{"name":"ocdownloader","slug":"ocdownloader","permalink":"https://www.lixf.io/tags/ocdownloader/"}]},{"title":"GoLang 内存模型","date":"2019-09-20T07:34:41.000Z","path":"2019/09/20/The-Go-Memory-Model/","text":"Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。 Happens Before在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。 Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。 在单线程中，happens-before的顺序和代码表达的顺序是一致的。 现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。 读操作r不happen before写操作w (有可能是并发发生) 没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生) 如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。 写操作w happen before 读操作r 任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。 Synchronization初始化如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前 If a package p imports package q, the completion of q‘s init functions happens before the start of any of p‘s. main方法happen after所有的init方法结束之后 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程创建新启动一个协程happens before这个协程的执行 The go statement that starts a new goroutine happens before the goroutine’s execution begins. 协程的销毁协程的结束不保证happen before于程序中的任何事件。 The exit of a goroutine is not guaranteed to happen before any event in the program 例如下面这个例子 123456var a stringfunc hello() &#123; go func() &#123; a = \"hello\" &#125;() print(a)&#125; 对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果 channel 通信golang里有一个很重要的思想不要通过共享内存来通信，而是通过通信来共享内存. Don’t communicate by sharing memory; share memory by communicating. 对应channel，也有几条重要的happens-before规则 对channel发送数据happens before于对于此channel相应的接收。 A send on a channel happens before the corresponding receive from that channel completes. 例如下面代码 12345678910111213var c = make(chan int, 10)var a stringfunc f() &#123; a = \"hello, world\" c &lt;- 0&#125;func main() &#123; go f() &lt;-c print(a)&#125; 能够确保输出 “hello world”。 a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。 关闭channel happens before 接收channel因关闭返回的０值 The closing of a channel happens before a receive that returns a zero value because the channel is closed. 从一个没有缓冲的channel里接收值happens before向这个channel发送值 A receive from an unbuffered channel happens before the send on that channel completes. 这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。 12345678910111213var c = make(chan int)var a stringfunc f() &#123; a = \"hello, world\" &lt;- c&#125;func main() &#123; go f() c &lt;- 0 print(a)&#125; 一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送 The kth receive on a channel with capacity C happens before the k+Cth send from that channel completes. 例如下面这个例子，可以确保同时只有三个协程在执行w() 123456789101112var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func(w func()) &#123; limit &lt;- 1 w() &lt;-limit &#125;(w) &#125; select&#123;&#125;&#125; Locks对于sync.Mutex或者sync.RWMutex 变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁 For any sync.Mutex or sync.RWMutex variable l and n &lt; m**, call n of l.Unlock() happens before call m of l.Lock() returns. 例如 1234567891011121314var l sync.Mutexvar a stringfunc f() &#123; a = \"hello, world\" l.Unlock()&#125;func main() &#123; l.Lock() go f() l.Lock() print(a)&#125; 在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world” happens before print(a)，因此可以确保输出”hello, world” For any call to l.RLock on a sync.RWMutex variable l, there is an n such that the l.RLock happens (returns) after call n to l.Unlock and the matching l.RUnlock happens before call n**+1 to l.Lock. Oncegolang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。 once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。 A single call of f() from once.Do(f) happens (returns) before any call of once.Do(f) returns. 例如这个程序 12345678910111213141516var a stringvar once sync.Oncefunc setup() &#123; a = &quot;hello, world&quot;&#125;func doprint() &#123; once.Do(setup) print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 不正确的同步在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。 看下面的例子 12345678910111213141516var a, b intfunc f() &#123; a = 1 b = 2&#125;func g() &#123; print(b) print(a)&#125;func main() &#123; go f() g()&#125; 上面输出的结果有可能是２ 0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生） 还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。 12345678910111213141516171819var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func doprint() &#123; if !done &#123; once.Do(setup) &#125; print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125; 另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。 1234567891011121314var a stringvar done boolfunc setup() &#123; a = \"hello, world\" done = true&#125;func main() &#123; go setup() for !done &#123; &#125; print(a)&#125;","tags":[{"name":"golang学习","slug":"golang学习","permalink":"https://www.lixf.io/tags/golang学习/"}]},{"title":"将网页转换成本地应用程序","date":"2019-08-14T06:05:37.000Z","path":"2019/08/14/create-native-app-from-web-url/","text":"微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。 这里使用在线制作的方式 打开网址 https://appmaker.xyz/web2desk ，如下图 根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。 邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。 然后根据我前面的ubuntu制作桌面图标制作成桌面图标就好","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"ubuntu制作桌面图标","date":"2019-08-14T05:54:09.000Z","path":"2019/08/14/ubuntu-create-desktop-icon/","text":"在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。 这里以typora为例说一下怎么制作，其实也很简单 进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容 12345678910[Desktop Entry]Encoding=UTF-8Name=TyporaComment=TyporaExec=/home/lixf/software/Typora/TyporaIcon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.pngTerminal=falsestarttupNotify=trueType=ApplicationCategories=Application;Development; 保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.lixf.io/tags/ubuntu/"}]},{"title":"我的私人书签记录","date":"2019-06-28T01:46:34.000Z","path":"2019/06/28/My-personal-bookmarks/","text":"保存一下工作中常用的网址 k8s相关 k8s官网文档 helm官方仓库 nginx-ingress 部署 operator-framework ambassador Istio文档 docker相关 Docker官方文档 Dockerfile文档 Docker官方仓库 常用镜像地址 阿里云镜像 清华镜像 中科大镜像 Azure中国镜像","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"}]},{"title":"临时复制粘贴处","date":"2019-06-17T07:05:19.000Z","path":"2019/06/17/textarea/","text":"粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地） Date.prototype.Format = function(fmt) { var o = { \"M+\" : this.getMonth() + 1, \"d+\" : this.getDate(), \"h+\" : this.getHours(), \"m+\" : this.getMinutes(), \"s+\" : this.getSeconds(), \"q+\" : Math.floor((this.getMonth() + 3) / 3), \"S\" : this.getMilliseconds() }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length))); return fmt; } var editbox = document.getElementById(\"editbox\"); if(localStorage.autoSave == undefined){ localStorage.autoSave = \"\"; } editbox.value = localStorage.autoSave; setInterval(function(){ var value = editbox.value; var saveValue = localStorage.autoSave; if(value != saveValue){ localStorage.autoSave = value; document.getElementById(\"tips\").innerText= \"内容已经在\"+new Date().Format(\"yyyy-MM-dd hh:mm:ss\")+\"时自动保存\"; } },1000 * 3);","tags":[{"name":"tools","slug":"tools","permalink":"https://www.lixf.io/tags/tools/"}]},{"title":"docker下载镜像的时候出现handshake failure","date":"2019-06-13T11:38:59.000Z","path":"2019/06/13/docker-pull-remote-error-tls-handshake-failure/","text":"在使用k8s的时候，发现pod的状态都是ImagePullError，查看pod的状态发现在pull镜像的时候，报下面的错误 1Error response from daemon: Get https://quay.io/v2/: remote error: tls: handshake failure 在pod所运行的服务器上执行curl https://www.baidu.com也报了下面的错误 1234567891011121314[root@k8s-master ~]# curl https://www.baidu.comcurl: (60) Peer&apos;s Certificate issuer is not recognized.More details here: http://curl.haxx.se/docs/sslcerts.htmlcurl performs SSL certificate verification by default, using a &quot;bundle&quot; of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn&apos;t adequate, you can specify an alternate file using the --cacert option.If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL).If you&apos;d like to turn off curl&apos;s verification of the certificate, use the -k (or --insecure) option. 在stackoverflow上找到了问题的答案（原网址忘记了保存），那就是当前服务器的时间不对，可能差个几秒或者几十秒，解决办法就是同步一下当前服务器的时间。 1ntpdate ntp1.aliyun.com 同步之后问题解决。 当然出现问题的原因可能有很多种，不一定能解决多有的此类问题。 为了防止后面出现同样的问题，可以将这条命令写到定时任务里。输入下面的命令打开定时任务的编辑窗口（如果没有安装crontab需要先安装一下） 1crontab -e 在里面加上这么一行命令,让每隔1分钟同步一下时间。 1*/1 * * * * /usr/sbin/ntpdate ntp1.aliyun.com &gt; /dev/null 2&gt;&amp;1; /sbin/hwclock -w","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://www.lixf.io/tags/kubernetes/"},{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"}]},{"title":"k8s相关镜像源整理","date":"2019-06-13T03:30:32.000Z","path":"2019/06/13/k8s-docker-images-mirrors/","text":"现在 azk8s.cn只允许azure的访问了，可以用下面的内容替代 gcr.io ==&gt; registry.aliyuncs.com k8s.gcr.io ==&gt; registry.aliyuncs.com/google-containers quay.io ==&gt; quay-mirror.qiniu.com 在使用k8s过程中，经常会因为国内恶劣的网络环境导致镜像下载慢甚至无法下载，因此，需要配置一下镜像源。这里整理一下我在网上找到的一些镜像源 gcr.io、k8s.gcr.io镜像加速gcr.io和k8s.gcr.io是k8s自身的一些组件以及第三方组件经常使用的仓库地址，这个地址在国内是无法直接访问的，因此需要使用到国内的一些镜像源来进行拉取。这里使用Azure中国镜像 gcr.io镜像仓库的镜像可以直接把gcr.io替换成gcr.azk8s.cn 例如，gcr.io/kubernetes-helm/tiller:v2.13.1镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.13.1 对于k8s.gcr.io镜像仓库，是将k8s.gcr.io替换成gcr.azk8s.cn/google-containers 例如，k8s.gcr.io/addon-resizer:1.8.4镜像，可以用下面的命令进行拉取 1docker pull gcr.azk8s.cn/google-containers/addon-resizer:1.8.4 quay.io镜像加速有些镜像存放在quay.io仓库里，这个镜像仓库在国内的拉取速度特别慢，因此也可以使用Azure中国镜像来加快拉取速度 quay.io镜像仓库是直接把quay.io替换成quay.azk8s.cn 例如quay.io/dexidp/dex:v2.10.0，可以用下面的命令进行拉取 1docker pull quay.azk8s.cn/dexidp/dex:v2.10.0 补充一下，对于dockerhub的仓库，也可以使用dockerhub.azk8s.cn进行加速 例如 1docker pull dockerhub.azk8s.cn/library/nginx helm镜像仓库Azure中国 对于helm也提供了国内的镜像地址 如果是新安装的helm,可以使用下面的命令进行初始化 1helm init --stable-repo-url http://mirror.azure.cn/kubernetes/charts/ 对于已经安装号helm，可以按照下面的命令替换成Azure中国的镜像仓库 12345helm repo remove stablehelm repo add stable http://mirror.azure.cn/kubernetes/charts/helm repo add incubator http://mirror.azure.cn/kubernetes/charts-incubator/helm repo updatehelm repo list 除了Azure中国以外，阿里云和中科大也提供了对应的镜像仓库地址","tags":[{"name":"docker","slug":"docker","permalink":"https://www.lixf.io/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://www.lixf.io/tags/k8s/"},{"name":"helm","slug":"helm","permalink":"https://www.lixf.io/tags/helm/"}]},{"title":"MYSQL创建数据库和用户","date":"2019-05-07T12:49:24.000Z","path":"2019/05/07/mysql-create-user/","text":"创建UTF-8编码的数据库1create database testbase default character set utf8 collate utf8_general_ci; 创建用户1create user &apos;testuser&apos;@&apos;%&apos; identified by &apos;password&apos;; 创建密码为 password 的 testuser 用户，%代表允许在所有地址上登陆，可以改成localhost或者127.0.0.1只允许本地登录 授权数据库给用户1grant select,insert,update,delete,create,drop on test.* to testuser; 授权testuser对test数据库下的所有表进行查询、插入、更新、删除、新建操作 刷新权限1flush privileges 取消授权1revoke all on *.* from testuser 删除用户1delete from mysql.user where user=&apos;testuser&apos;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.lixf.io/tags/mysql/"}]},{"title":"欢迎访问我的博客","date":"2019-05-07T12:16:23.000Z","path":"2019/05/07/welcome-my-blog/","text":"欢迎访问李小飞的个人博客","tags":[{"name":"欢迎","slug":"欢迎","permalink":"https://www.lixf.io/tags/欢迎/"},{"name":"博客","slug":"博客","permalink":"https://www.lixf.io/tags/博客/"}]}]