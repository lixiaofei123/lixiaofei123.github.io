<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李小飞</title>
  
  <subtitle>记录工作中遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lixf.io/"/>
  <updated>2021-06-26T14:52:34.405Z</updated>
  <id>https://www.lixf.io/</id>
  
  <author>
    <name>李小飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>很久没写博客了</title>
    <link href="https://www.lixf.io/2021/06/26/I-haven-t-write-blog-for-a-long-time/"/>
    <id>https://www.lixf.io/2021/06/26/I-haven-t-write-blog-for-a-long-time/</id>
    <published>2021-06-26T13:32:50.000Z</published>
    <updated>2021-06-26T14:52:34.405Z</updated>
    
    <content type="html"><![CDATA[<p>lalalala</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lalalala&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git和npm设置代理</title>
    <link href="https://www.lixf.io/2021/05/19/git-set-proxy/"/>
    <id>https://www.lixf.io/2021/05/19/git-set-proxy/</id>
    <published>2021-05-19T08:04:22.000Z</published>
    <updated>2021-05-19T08:07:21.684Z</updated>
    
    <content type="html"><![CDATA[<p>由于不知名的原因，现在github.com不设置代理的话几乎无法访问。如下图所示，从github上克隆一个postgres，每秒的速度只有3到4KB。</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/18/22/1621347934-git-clone-no-proxy.png" alt="不设置代理克隆"></p><p>下面分别提供通过https协议和ssh协议克隆仓库设置代理的方法</p><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p>如果我们本地有可以科学上网的http或者socket5代理的话，可以进行如下设置(只需要设置一个就行了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:10809 #走http代理</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:10808 #走socks5代理</span><br></pre></td></tr></table></figure><p>设置完后再克隆，就可以发现拉取仓库的速度有了明显的提升（具体取决于代理的速度和当前网络的速度）。</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/18/22/1621348089-git-clone-with-proxy.png" alt="设置代理克隆"></p><p>此时，如果我们通过ssh协议克隆仓库，会发现克隆速度还是很慢(几乎是0)。如下图所示</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/18/22/1621348677-git-clone-ssh-no-proxy.png" alt="不配置代理克隆ssh协议仓库"></p><p>这种情况下需要给ssh协议配置代理。</p><h3 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h3><p>配置通过ssh协议克隆仓库的话，需要socket5代理。windows用户在 C:\Users\用户名.ssh\config 文件中增加下面的内容 (没有的话自行创建)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">ProxyCommand connect -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><p>Linux在~/.ssh/config文件中增加下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">ProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><p>此时再克隆，可以看到速度明显有了提示</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/18/22/1621349149-git-clone-ssh-with-proxy.png" alt="设置代理克隆ssh仓库"></p><h3 id="npm设置代理"><a href="#npm设置代理" class="headerlink" title="npm设置代理"></a>npm设置代理</h3><p>npm在国内拉取仓库时，也会特别慢，可以参考下面的配置来设置代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> proxy http://127.0.0.1:10809</span><br><span class="line">npm config <span class="built_in">set</span> https-proxy http://127.0.0.1:10809</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于不知名的原因，现在github.com不设置代理的话几乎无法访问。如下图所示，从github上克隆一个postgres，每秒的速度只有3到4KB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static1.huiyuanai.cn/stroage/2021/05
      
    
    </summary>
    
      <category term="git" scheme="https://www.lixf.io/categories/git/"/>
    
    
      <category term="git" scheme="https://www.lixf.io/tags/git/"/>
    
      <category term="代理" scheme="https://www.lixf.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>表分区</title>
    <link href="https://www.lixf.io/2021/05/10/table-partitioning/"/>
    <id>https://www.lixf.io/2021/05/10/table-partitioning/</id>
    <published>2021-05-10T13:22:39.000Z</published>
    <updated>2021-05-10T13:26:43.672Z</updated>
    
    <content type="html"><![CDATA[<p>表分区是指将一个逻辑上的大表分成几个物理小块。表分区可以提供下面几个好处</p><ol><li>当要查询的数据在同一个分区或者少数几个分区的时候，可以显著提高查询性能。分区有效代替了索引树的上层部分，看起来就像重度使用的部分放在了内存中一样。个人理解是，如果使用索引，数据库每次要从磁盘中加载索引，由于索引从上到下扫描索引树来查找数据，所以对索引树的上层部分的查询是很频繁的。使用了分区以后，分区数据已经相当于索引树的上层部分了，相当于最经常使用的部分已经放在了内存中了(原因参考最佳实践第4条)。</li><li>当查询或者更新占据单独的一个分区的很大比例的时候，通过使用顺序扫描会比使用索引有性能提升。因为索引会在整个表上进行随机读取，随机读取比顺序读取慢得多。</li><li>如果使用了设计模式的话，批量加载和删除可以通过分区来完成。直接加载某个分区的数据或者直接删除某个分区的数据要比批量删除快得多。</li><li>很少使用的数据可以被迁移到便宜的介质上</li></ol><p>postgres支持的几个默认的分区方法</p><ol><li><p>Range Partitioning</p><p>范围分区是根据表中的某个或者某几个字段进行分区，例如 1-10 11-20</p></li><li><p>List Partitioning</p><p>通过显式的列出表中的键值对来进行分区</p></li><li><p>Hash Partitioning</p><p>通过为每个分区指定一个除数和余来进行分区。即每一行的hash值除以除数然后得到余，根据余值来放到对应的分区里</p></li></ol><p><strong>分区使用示例</strong></p><ol><li><p>通过指定partitioning by 创建分区表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> measurement (    </span><br><span class="line">    city_id         <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,    </span><br><span class="line">    logdate         <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,    </span><br><span class="line">    peaktemp        <span class="built_in">int</span>,    </span><br><span class="line">    unitsales       <span class="built_in">int</span>) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (logdate);</span><br></pre></td></tr></table></figure></li><li><p>分别创建每一个分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> measurement_y2006m02 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> measurement    <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2006-02-01'</span>) <span class="keyword">TO</span> (<span class="string">'2006-03-01'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> measurement_y2006m03 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> measurement    <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2006-03-01'</span>) <span class="keyword">TO</span> (<span class="string">'2006-04-01'</span>) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (peaktemp); <span class="comment">#创建分区表的分区表</span></span><br></pre></td></tr></table></figure></li></ol><p>如果插入一条不对应任何分区的数据，那么插入会报错，应该手动创建对应的分区</p><ol start="3"><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> measurement (logdate);</span><br></pre></td></tr></table></figure><p>创建索引是非必须的，分区表上的索引和约束条件都是虚拟的，实际上的索引位置和约束条件都在分区中</p></li><li><p>确定 数据库配置中 enable_partition_pruning 的值不是禁用状态</p></li></ol><p><strong>分区维护</strong></p><ol><li><p>删除某个分区的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> measurement_y2006m02; <span class="comment"># 快速删除数百万条数据，需要在主表上加ACCESS EXCLUSIVE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> measurement DETACH <span class="keyword">PARTITION</span> measurement_y2006m02; <span class="comment">#接触分区和分区表的关系，同时保留数据，数据可以做进一步的分析</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>增加新的分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE measurement_y2008m02 PARTITION OF measurement    FOR VALUES FROM (&apos;2008-02-01&apos;) TO (&apos;2008-03-01&apos;)    TABLESPACE fasttablespace;</span><br></pre></td></tr></table></figure></li><li><p>先创建表，再创建分区表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> measurement_y2008m02  (<span class="keyword">LIKE</span> measurement <span class="keyword">INCLUDING</span> <span class="keyword">DEFAULTS</span> <span class="keyword">INCLUDING</span> <span class="keyword">CONSTRAINTS</span>)  <span class="keyword">TABLESPACE</span> fasttablespace;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> measurement_y2008m02 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> y2008m02   <span class="keyword">CHECK</span> ( logdate &gt;= <span class="built_in">DATE</span> <span class="string">'2008-02-01'</span> <span class="keyword">AND</span> logdate &lt; <span class="built_in">DATE</span> <span class="string">'2008-03-01'</span> );</span><br><span class="line">\copy measurement_y2008m02 from 'measurement_y2008m02'</span><br><span class="line"><span class="comment">-- possibly some other data preparation work</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> measurement ATTACH <span class="keyword">PARTITION</span> measurement_y2008m02    <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2008-02-01'</span>) <span class="keyword">TO</span> (<span class="string">'2008-03-01'</span> );</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> measurement_usls_idx <span class="keyword">ON</span> <span class="keyword">ONLY</span> measurement (unitsales);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> measurement_usls_200602_idx    <span class="keyword">ON</span> measurement_y2006m02 (unitsales);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> measurement_usls_idx    ATTACH <span class="keyword">PARTITION</span> measurement_usls_200602_idx;</span><br></pre></td></tr></table></figure><p> 同样的方式可以用在primary和unique上    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">ONLY</span> measurement <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (city_id, logdate);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> measurement_y2006m02 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (city_id, logdate);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> measurement_city_id_logdate_key    ATTACH <span class="keyword">PARTITION</span> measurement_y2006m02_city_id_logdate_key</span><br></pre></td></tr></table></figure></li></ol><p><strong>分区表限制</strong></p><ol><li>分区表的唯一约束必须包含所有的分区键列。因为各个分区只能保证在自己表中的唯一约束性，保证不了全表的唯一约束性，因此分区表自身必须负责在不同的分区中没有重复。如果唯一约束包含了分区键，那么各个分区对应的唯一约束中的分区键都不同，因此也就保证了在所有分区中的唯一约束都成立</li><li>无法创建排除约束（exclusion constraint），原因同上，分区不能跨区排除</li><li>insert的BEFORE ROW 触发器不能更改新行的目标区。即 在BEFORE ROW触发器中修改了分区键的值，分区的结果也不会改变。</li><li>分区表 临时表和永久表不能混用。分区表是临时的，那么分区也是临时的，分区表是永久的，那么分区也是永久的。</li></ol><p>​    分区表的幕后是分区和分区表是继承关系，但并不是可以使用所有的继承特性。尤其是分区不能有分区表中不存在的字段，分区表和分区也并不能继承其它表。</p><p>​    不能使用的继承特性有</p><ol><li>分区不能有分区表中不存在的字段</li><li>分区表的CHECK和NOT NULL约束会被它的所有分区继承。不能在分区表上使用被标记了NO INHERIT的CHECK。如果分区表的字段上有NOT NULL的话，分区的字段上的NOT NULL不能被删除</li><li><p>当分区表上没有任何分区的时候可以使用ONLY来增加约束，当存在分区的时候，使用ONLY会报错。替代的可以在分区上添加和删除（如果父表中没有）约束  <span style="color:red">后续再看</span></p></li><li><p>分区表本身没有任何数据，使用TRUNCATE ONLY会报错</p><p><span style="color:red">跳过了使用继承的分区，后面再看</span></p><p><strong>分区修剪(Partition Pruning)</strong></p></li></ol><p>分区修剪是一种提高性能的查询优化技术。</p><p>例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> enable_partition_pruning = <span class="keyword">on</span>;                 <span class="comment">-- the default</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> measurement <span class="keyword">WHERE</span> logdate &gt;= <span class="built_in">DATE</span> <span class="string">'2008-01-01'</span>;</span><br></pre></td></tr></table></figure><p>如果没有分区修剪，那么pg会扫描分区表的所有的分区来计算数量。如果开启了分区修剪，计划器会查看每个分区的定义来提前排除掉不需要查询的分区。</p><p>分区修剪是基于分区键的而不是基于索引的，因此是否对分区键建立索引取决于你需要查询分区的一大部分还是一小部分，如果是一大部分，那么建立索引是没有用的。</p><p>分区修剪不仅在计划阶段有效，在执行阶段也有效</p><p><strong>分区约束排除(Constraint  exclusion)</strong></p><p>Constraint  exclusion是一种类似于分区修剪的查询优化技术。主要是利用CHECK约束实现，在计划阶段有效，比分区修剪慢</p><p>默认情况下constraint_exclusion的值是partition，这个值表示约束排除仅工作在继承分区表上，on代表在所有的查询上都检查check约束</p><p>注意点：</p><ol><li>约束排除仅在计划阶段有用</li><li>约束排除仅在查询的where条件包含常量的时候有用。</li><li>分区的约束应该简单，否则约束排除无法判断是否需要访问子表。</li></ol><p><strong>最佳实践</strong></p><ol><li><p>最关键一点是你选择的分区的列（或者多列）。通常最好的选择是那些经常出现在where中的列。与分区绑定约束兼容的where可以用来修剪不需要的分区。然而，由于primary key和 unique约束也可能做出其它选择。删除数据也是一个计划分区策略的一个考虑因素。</p></li><li><p>选择分区的数量也是一个重要的因素。分区太少导致索引仍然很大和数据的局部性仍然很低。分区太多，会导致更长的查询计划时间和查询计划和执行期间的更高的内存占用。同时，在设置分区的数目的时候，也需要为将来考虑。</p></li><li><p>当预期一个分区会变的很大的时候采用子分区是有用的。而如果采用多列范围分区会导致分区的数目变多，因此要加以限制</p></li><li><p>考虑查询计划和执行阶段的开销是重要的。如果查询能够允许查询计划器修剪大部分分区，那个查询计划器能够处理几千个分区的查询，否则的话，计划时间就会变长内存消耗也会变高，对UPDATE和DELETE同样如此。另一个原因是，服务器的内存消耗会随着时间的推移而显著增长，尤其是大量会话都涉及到分区的情况，这是因为每一个涉及到分区查询的会话都会把分区元数据信息加载到自己的本地内存中</p></li><li><p>数据库负载类型，warehouse(数据仓库 OLAP On-line Analytical Processing)类型使用大量分区要比OLTP(On-line Transaction Processing 在线事务交易)更有意义。因为，在数据仓库类型中，查询计划时间不重要，因为大部分时间都在查询执行时间。根据数据库的负载类型早做决定。</p><p>OLAP 在线分析处理，查询一般都非常复杂，因此执行时间会比较长，主要是提供报表之类的功能</p><p>OLTP 在线事务处理，短时间内会有大量的插入、删除、更新语句，要求非常快的查询处理，</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;表分区是指将一个逻辑上的大表分成几个物理小块。表分区可以提供下面几个好处&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当要查询的数据在同一个分区或者少数几个分区的时候，可以显著提高查询性能。分区有效代替了索引树的上层部分，看起来就像重度使用的部分放在了内存中一样。个人理解是，如果使用索引，数
      
    
    </summary>
    
      <category term="postgresql" scheme="https://www.lixf.io/categories/postgresql/"/>
    
    
      <category term="数据库" scheme="https://www.lixf.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="postgresql" scheme="https://www.lixf.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>schema 和 search_path</title>
    <link href="https://www.lixf.io/2021/05/10/schema-and-search-path/"/>
    <id>https://www.lixf.io/2021/05/10/schema-and-search-path/</id>
    <published>2021-05-10T13:11:37.000Z</published>
    <updated>2021-05-10T13:26:59.766Z</updated>
    
    <content type="html"><![CDATA[<p>一个postgres集群中可以包含多个database，每个database包含了一个或者多个schema,schema包含了表、数据类型、函数以及操作符，不同的schema可以包含相同的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> myschema; <span class="comment">#创建一个新的schema</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">schema</span> mychema;  <span class="comment"># 删除一个空的的schema</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">schema</span> mychema <span class="keyword">cascade</span>; <span class="comment"># 删除一个非空的schema</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> schema_name AUTHORIZATION user_name;  <span class="comment">#创建一个属于某用户的schema</span></span><br></pre></td></tr></table></figure><p>在写sql语句的时候，可以通过schema.table来区分对应的schema里的表</p><p>查看schema</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> nspname <span class="keyword">from</span> pg_catalog.pg_namespace; </span><br><span class="line"><span class="keyword">SELECT</span> schema_name <span class="keyword">FROM</span> information_schema.schemata;</span><br><span class="line"><span class="comment"># 参考地址 https://soft-builder.com/how-to-list-all-schemas-in-postgresql/</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\dn   #在psql中执行，但是看不到系统级别的schema</span><br></pre></td></tr></table></figure><p>一般在写sql语句的时候不会特意指定schema，如果没有指定schema的话，数据库会根据search_path的值来查找schema里的表</p><p>查看search_path的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> search_path;   <span class="comment">#默认值为 $user,public</span></span><br></pre></td></tr></table></figure><p>修改search_path</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> search_path <span class="keyword">to</span> myschema,<span class="keyword">public</span> <span class="comment">#将search_path的值设置成mychema和public</span></span><br></pre></td></tr></table></figure><p>此时，如果用如下sql语句创建表(没有指定schema)，pg数据库会在search_path中第一个存在的schema创建对应的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> testdb(<span class="keyword">id</span> <span class="built_in">int</span>);   <span class="comment">#由于search_path的值是myschema,public 所以此时表被创建在myschema中</span></span><br></pre></td></tr></table></figure><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/21/1620652352-create_table_no_schema.png" alt="不指定schema"></p><p>可以直接指定schema让表创建在指定的schema中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> public.testdb1(<span class="keyword">id</span> <span class="built_in">int</span>);  <span class="comment">#直接在pubic中创建testdb1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> public.testdb(<span class="keyword">id</span> <span class="built_in">int</span>);   <span class="comment">#直接在pubic中创建testdb,由于在不同的schema中，所以table的名字可以重复</span></span><br></pre></td></tr></table></figure><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/21/1620652362-create_table_with_schema.png" alt></p><p>此时如果用 \d 查看当前数据的表，可以看出testdb1在public中，但是没有看见public下有testdb，这是因为pg已经在位置靠前的schema中发现testdb了，会忽略靠后的schema中相同名字的表。但是这个表是真实存在的，可以通过在表名前面加scheme前缀来进行查询和更改。</p><p>安全策略</p><ol><li><p>约束每个用户只使用自己私有的schema，先使用下面语句禁止别的用户操作public schema，然后为每个用户创建和用户名同名的schema</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span> ONSCHEMA <span class="keyword">public</span> <span class="keyword">FROM</span> <span class="keyword">PUBLIC</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>通过设置 ALTER  ROLE  ALL  SET  search_path  =  “$user” 将所有用户的search_path设置成$user</p></li><li><p>保持默认 仅数据库只有一个用户或者少数几个受信任的用户的时候使用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个postgres集群中可以包含多个database，每个database包含了一个或者多个schema,schema包含了表、数据类型、函数以及操作符，不同的schema可以包含相同的表。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="postgresql" scheme="https://www.lixf.io/categories/postgresql/"/>
    
    
      <category term="数据库" scheme="https://www.lixf.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="postgresql" scheme="https://www.lixf.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>窗口函数</title>
    <link href="https://www.lixf.io/2021/05/10/windows-function/"/>
    <id>https://www.lixf.io/2021/05/10/windows-function/</id>
    <published>2021-05-10T12:27:12.000Z</published>
    <updated>2021-05-10T13:11:05.502Z</updated>
    
    <content type="html"><![CDATA[<p>窗口函数在一组与当前行有某种联系的表行上进行计算。这个看起来和聚集函数有些相似，但是不同的是，不像聚集函数那样将结果输出为一条，而是每行保留自己的标识。这一点看下面的例子来说明：</p><p>用聚集函数来计算各地区的员工工资总和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">sum</span>(salary) <span class="keyword">from</span> empsalary <span class="keyword">group</span> <span class="keyword">by</span> city;</span><br></pre></td></tr></table></figure><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/20/1620651418-jujihanshu-example.png" alt="聚集函数例子"></p><p>用窗口函数来计算工资总和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,city,salary, <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">partition</span> <span class="keyword">by</span> city) <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/20/1620651482-window-function-example.png" alt="窗口函数例子"></p><blockquote><p>值得注意的是，在聚集函数中，SELECL后面不能有<em>没有出现在ORDER BY后面的属性</em>，而窗口函数是可以的</p></blockquote><p>窗口函数的调用会始终在窗口函数和参数的后面加一个OVER，在语法上就将窗口函数和其它函数区分开来。OVER子句决定了如何分割查询后的行以便于窗口函数来处理。其中，OVER中的 PARTITION BY子句决定了如何将数据分区，ORDER BY子句则可以控制窗口函数处理行的顺序</p><p>例如下面的例子是根据工资进行排名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name,salary,rank() OVER (ORDER BY salary desc) FROM empsalary;</span><br></pre></td></tr></table></figure><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/21/1620651741-window-function-order-by-example.png" alt="工资排名"></p><blockquote><p>使用rank()函数时，排名会出现终端，例如，存在两个第一名，那么加下来的名次就是第三名，如果需要连续的名次，可以使用dense_rank()</p></blockquote><p>分区函数的几个特性</p><ol><li><p>和聚合函数相比，聚合函数只能输出每组的单一行，而窗口函数可以输出每一行包含其它属性的结果</p></li><li><p>聚合函数操作的对象是 query查询（where、group by、having之后）的结果，例如如果一行记录不满足where条件，那么这条记录对窗口函数不可见</p></li><li><p>如果顺序不重要，可以省略order by，如果分区不重要，可以省略partition by，相当于全表了</p></li><li><p>另外一个关于窗口函数重要的事情是，对于每一行，在其分区内都有一组叫做window frame的行。有一些窗口函数（例如sum）仅在window frame的行上起作用，而不是整个分区。默认情况下，如果指定了order by，那么frame是由从分区开始到当前行，然后加上根据order by指定的顺序和当前行相等的行。如果order by是空的，默认的frame由分区内的所有行组成。(这个是postgres的默认设置，可以更改window frame的行为)</p></li></ol><p>第4条我们来看例子来理解</p><p>如果OVER子句中没有指定ORDER BY</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> () <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure><p>查询的结果是</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/21/1620652133-no-order-by.png" alt="没有order by"></p><p>因为此时没有指定order by，所以每一行在分区内对应的window frame包含了当前分区的所有行，然后对于sum的计算，就是当前分区内所有行的salary的总和。（因为也没有指定partition by，所以window frame包含了整张表）</p><p>如果OVER子句中指定了ORDER BY</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure><p>查询的结果是</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/10/21/1620652206-order-by.png" alt></p><p>这时候因为指定了order by,所以每一行在分区内对应的windows frame是不一样的。例如，第3、4行在分区内对应的window frame就应该是（1，2，3，3），所以其sum的值是9</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;窗口函数在一组与当前行有某种联系的表行上进行计算。这个看起来和聚集函数有些相似，但是不同的是，不像聚集函数那样将结果输出为一条，而是每行保留自己的标识。这一点看下面的例子来说明：&lt;/p&gt;
&lt;p&gt;用聚集函数来计算各地区的员工工资总和&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="postgresql" scheme="https://www.lixf.io/categories/postgresql/"/>
    
    
      <category term="数据库" scheme="https://www.lixf.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="postgresql" scheme="https://www.lixf.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>聚集函数</title>
    <link href="https://www.lixf.io/2021/05/10/aggregate-function/"/>
    <id>https://www.lixf.io/2021/05/10/aggregate-function/</id>
    <published>2021-05-10T12:15:02.000Z</published>
    <updated>2021-05-10T12:26:49.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近工作和数据库有关，就借着这个机会好好学一下postgresql。</p></blockquote><p>像其它的大多数关系型数据库一样，postgresql支持聚集函数(aggregate function).聚集函数从多行记录中计算出一个单一的结果。例如count,sum,avg.max,min等等</p><p>下面的例子是查询最高温度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">max</span>(temp_lo) <span class="keyword">FROM</span> weather;</span><br></pre></td></tr></table></figure><p>如果需要知道最高温度对应的城市，也许会尝试下面的查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> temp_lo = <span class="keyword">max</span>(temp_lo)</span><br></pre></td></tr></table></figure><p>但是这个查询是错误的，因为聚集函数是在where之后才执行的。但是我们可以通过子查询来实现这样的要求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> temp_lo = (<span class="keyword">SELECT</span> <span class="keyword">max</span>(temp_lo) <span class="keyword">FROM</span> weather)</span><br></pre></td></tr></table></figure><p>聚集函数通常和GROUP BY一起使用，例如下面的例子，可以查询每个城市的最高温度</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city, <span class="keyword">max</span>(temp_lo)    <span class="keyword">FROM</span> weather    <span class="keyword">GROUP</span> <span class="keyword">BY</span> city</span><br></pre></td></tr></table></figure><p>可以通过HAVING来过滤结果,例如下面的查询最高气温小于40度的城市</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city, <span class="keyword">max</span>(temp_lo)    <span class="keyword">FROM</span> weather    <span class="keyword">GROUP</span> <span class="keyword">BY</span> city    <span class="keyword">HAVING</span> <span class="keyword">max</span>(temp_lo) &lt; <span class="number">40</span></span><br></pre></td></tr></table></figure><p><strong>聚合函数中 where 和 having 区别</strong><br>    where发生在分组和聚合之前，控制了哪些数据需要分组和聚合，这也是为什么where条件中不能使用聚合函数的原因<br>    having则相反，发生在分组和聚合之后，所以having一般都包含了聚合函数。虽然也允许在having中不使用聚合函数，但是放在where中更加高效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近工作和数据库有关，就借着这个机会好好学一下postgresql。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像其它的大多数关系型数据库一样，postgresql支持聚集函数(aggregate function).聚集函数从多行记录中计算出一个
      
    
    </summary>
    
      <category term="postgresql" scheme="https://www.lixf.io/categories/postgresql/"/>
    
    
      <category term="数据库" scheme="https://www.lixf.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="postgresql" scheme="https://www.lixf.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title>linux禁止root用户远程登录，并修改ssh端口</title>
    <link href="https://www.lixf.io/2021/05/09/Linux-forbids-remote-login-of-root/"/>
    <id>https://www.lixf.io/2021/05/09/Linux-forbids-remote-login-of-root/</id>
    <published>2021-05-09T09:52:36.000Z</published>
    <updated>2021-05-09T10:21:25.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在创建一台新服务器以后，为了安全考虑，要修改ssh的端口为其它端口，同时禁止root用户远程登陆。</p><p>由于需要设置禁止root用户远程登陆，因此需要先创建一个普通用户，使用这个普通用户登陆以后，再使用su命令切换到root用户</p><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><p>例如，我们使用下面的命令创建一个名为jerry的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser jerry</span><br></pre></td></tr></table></figure><p>执行结果如下图所示，除了密码是必填的以外，其它的选项可以为空</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/09/17/1620554393-add-new-user.png" alt="创建一个新用户"></p><p>创建了新用户以后，就可以使用这个用户来进行登陆了。如果不想要这个用户了，可以使用下面的命令来删除此用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel -r jerry</span><br></pre></td></tr></table></figure><h3 id="禁止root用户远程登陆以及修改端口"><a href="#禁止root用户远程登陆以及修改端口" class="headerlink" title="禁止root用户远程登陆以及修改端口"></a>禁止root用户远程登陆以及修改端口</h3><p>使用vim打开/etc/ssh/sshd_config文件后进入编辑模式</p><p>在配置文件中找到下面两项分别进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Port 22    <span class="comment"># 将22修改为别的端口,例如修改成2222</span></span><br><span class="line">PermitRootLogin yes    <span class="comment"># 将yes修改为no</span></span><br></pre></td></tr></table></figure><p>修改完成后保存并重启ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><blockquote><p>注意有些云服务(比如阿里云或者腾讯云)有安全组策略，需要在安全组策略里将上面修改后的端口添加到安全组中，否则将会无法登陆</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>修改完毕后，可以测试一下用root用户进行登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 root@***.***.***.***   <span class="comment">#注意把端口换成修改后的端口</span></span><br></pre></td></tr></table></figure><p>从下图可以看出,root用户已经无法登陆了</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/09/18/1620555148-root-can-not-login.png" alt="root用户无法登陆"></p><p>这时候我们尝试使用jerry用户进行登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 jerry@***.***.***.***</span><br></pre></td></tr></table></figure><p>jerry可以远程登陆到服务器上</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/09/18/1620555347-jerry-can-login.png" alt="jerry用户可以远程登陆"></p><p>然后切换到root用户即可</p><p><img src="https://static1.huiyuanai.cn/stroage/2021/05/09/18/1620555442-change-root-user.png" alt="切换到root用户"></p><blockquote><p>如果担心这样做还不安全的话，也可以彻底禁止使用用户名密码登陆，改用使用密钥文件登陆的方式，有兴趣的可以自己去搜索怎么做</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在创建一台新服务器以后，为了安全考虑，要修改ssh的端口为其它端口，同时禁止root用户远程登陆。&lt;/p&gt;
&lt;p&gt;由于需要设置禁止root用
      
    
    </summary>
    
      <category term="linux" scheme="https://www.lixf.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.lixf.io/tags/linux/"/>
    
      <category term="运维" scheme="https://www.lixf.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ios 微信自带浏览器上webrtc不能正常使用的解决方法</title>
    <link href="https://www.lixf.io/2021/03/26/webrtc-in-ios-weixin-browser/"/>
    <id>https://www.lixf.io/2021/03/26/webrtc-in-ios-weixin-browser/</id>
    <published>2021-03-26T10:34:04.000Z</published>
    <updated>2021-03-29T02:59:04.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容只适用于 ios版本 &gt;= 14 微信版本 &gt;= 8.0，其余版本请自行测试</p></blockquote><p>最近使用到了webrtc，在其它各端(包括safari浏览器、iOS企业微信)测试没问题后，唯独在ios版微信浏览器上不能正常使用，查看日志，发现webrtc各个流程都已正常建立，包括onHandleTrackd都已经触发，video.srcObject也已经执行，收集的统计信息也说明webrtc的视频流数据也在正常传输，就是没有显示画面。</p><p>百度和谷歌了一下，也不知道是不是因为iOS版微信浏览器刚刚支持webrtc的缘故，只有一则3月10多日的新闻说随着ios的更新，采用wkwebview的微信浏览器也已经支持webrtc，再没有其它有用的资料。</p><p>后来看了一个使用webrtc支持ios版微信浏览器的网站，发现玄机竟然是下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"WeixinJSBridgeReady"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"remoteVideo"</span>).play();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>加上去以后，测试OK，可以不用加班了</p><p>值得注意的是，WeixinJSBridgeReady这个事件会在页面加载后马上触发，因此，上面的这个代码最好写在window.onload=&gt;(){}函数体中，所以video标签也要提前写在html网页中，不要等webrtc通道建立后再去动态创建video。</p><p>顺便贴一下我的video标签使用的属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">preload</span>=<span class="string">"auto"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">x-webkit-airplay</span>=<span class="string">"true"</span> <span class="attr">playsinline</span> =<span class="string">"true"</span> <span class="attr">webkit-playsinline</span> =<span class="string">"true"</span> <span class="attr">x5-video-player-type</span>=<span class="string">"h5"</span> <span class="attr">x5-video-player-fullscreen</span>=<span class="string">"true"</span> <span class="attr">x5-video-orientation</span>=<span class="string">"portraint"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>业余前端，写的不对请见谅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下内容只适用于 ios版本 &amp;gt;= 14 微信版本 &amp;gt;= 8.0，其余版本请自行测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近使用到了webrtc，在其它各端(包括safari浏览器、iOS企业微信)测试没问题后，唯独在ios版微
      
    
    </summary>
    
      <category term="webrtc" scheme="https://www.lixf.io/categories/webrtc/"/>
    
    
      <category term="webrtc" scheme="https://www.lixf.io/tags/webrtc/"/>
    
      <category term="微信浏览器" scheme="https://www.lixf.io/tags/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决mapbox中事件冲突的几种方法</title>
    <link href="https://www.lixf.io/2020/06/21/mapbox-event-conflict2/"/>
    <id>https://www.lixf.io/2020/06/21/mapbox-event-conflict2/</id>
    <published>2020-06-21T07:25:19.000Z</published>
    <updated>2021-05-09T09:11:08.873Z</updated>
    
    <content type="html"><![CDATA[<p>最近在基于mapbox做项目，随着功能越来越多，mapbox上的事件冲突也越来越严重。比如说一个人需要实现在地图上点击一下出现一个弹窗显示当前地点的效果，另外一个人需要实现在地图上点击选中某片区域的功能，最终得到的效果是当用户在地图上点击以后既出现了弹窗又选中了某片区域。</p><p>例如下面的代码会导致点击地图后同时在控制台打印两条信息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.on(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">      map.on(<span class="string">"click"</span>,() =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"click 1"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      map.on(<span class="string">"click"</span>,() =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"click 2"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>从下图中可以看出click事件被响应了两次<br><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/mapbox-event-conflict/pic1.png" alt="信息打印了两次"></p><p>下面是解决这些问题的一些思路，仅供参考。</p><ol><li>e.preventDefault</li></ol><p>e.preventDefault()本身是用来阻止事件发生后的默认行为的。例如下面的代码可以屏蔽掉mapbox的拖拽移动等功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.on(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">      map.on(<span class="string">"mousedown"</span>, e =&gt; &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>但是默认情况下这个只会阻止mapbox上的一些默认行为，只在代码里加一个e.preventDefault并不能阻止我们自己代码里的一些冲突。所幸的是，在调用了e.preventDefault()之后，e.defaultPrevented会被修改为true，因此，我们的代码里可以通过判断这个值来避免事件的冲突。下面是示例代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map.on(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">    map.on(<span class="string">"click"</span>,e =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(e.defaultPrevented)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click 1"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    map.on(<span class="string">"click"</span>,e =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(e.defaultPrevented)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click 2"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>从下图中可以看出click事件被响应了一次（实际上是两次，但是第二次直接返回了）<br><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/mapbox-event-conflict/pic2.png" alt="信息只打印了一次"></p><ol start="2"><li>故意出错<br>这个方案不太好，就是故意加一些出错的代码，这样js在执行到出错的代码后就不再往下执行了。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map.on(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">    map.on(<span class="string">"click"</span>,e =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click 1"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">    map.on(<span class="string">"click"</span>,e =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click 2"</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>从下图中可以看出click事件被响应了一次<br><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/mapbox-event-conflict/pic3.png" alt="代码出错后不再往下执行"><br>但是相信这样的代码对于大多数人来说连编译都过不了</p><ol start="3"><li>重写mapbox的on和off方法<br>前面的方法1虽然可以避免部分的事件冲突，但是一方面我们的遗留代码比较多，一处一处的修改不太现实，另一方面除了解决冲突外，我们可能也会希望有些监听能够优先被响应（类似于css中的z-index）。<br>熟悉面向对象的朋友都应该知道子类可以重写父类的方法。因此我们可以设计出一个子类来继承mapboxgl.Map，重写Map的on和off方法，同时也要考虑兼容以前的用法。</li></ol><p>由于我的代码水平不高，下面的代码完全仅供参考</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iMap</span> <span class="keyword">extends</span> <span class="title">mapboxgl</span>.<span class="title">Map</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">super</span>(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off(type, arg1, arg2) &#123;</span><br><span class="line">        <span class="keyword">let</span> listener = <span class="keyword">typeof</span> arg1 === <span class="string">"function"</span> ? arg1 : arg2;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.listenerMap[type]) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="keyword">this</span>.listenerMap[type].findIndex(</span><br><span class="line">            (l) =&gt; l.listener === listener</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listenerMap[type].splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *支持两种调用形式</span></span><br><span class="line"><span class="comment">        * on(type, layerId, listener, priority, forceCall)</span></span><br><span class="line"><span class="comment">        * on(type, listener, priority, forceCall)</span></span><br><span class="line"><span class="comment">        * priority为优先级，值越大在调用链中越靠前</span></span><br><span class="line"><span class="comment">        * forceCall为强制调用，如果为true,则即使前面的事件屏蔽了事件的传播，仍然会被调用</span></span><br><span class="line"><span class="comment">        * 由于priority和forceCall为可选属性，因此，新的on接口完全兼容原来的接口</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    on(type, arg1, arg2, arg3, arg4) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listenerMap = <span class="keyword">this</span>.listenerMap || &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> listener = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">let</span> priority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> forceCall = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> layerId;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">"function"</span>) &#123;</span><br><span class="line">            <span class="comment">// arg1 为listener  arg2为优先级, arg3为是否强制调用</span></span><br><span class="line">            <span class="keyword">if</span> (arg2 &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">"number"</span>) &#123;</span><br><span class="line">                priority = arg2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arg3 &amp;&amp; <span class="keyword">typeof</span> arg3 === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">                forceCall = arg1;</span><br><span class="line">            &#125;</span><br><span class="line">            listener = arg1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// arg1 为图层ID，arg2为listener, arg3为优先级，arg4为是否强制调用</span></span><br><span class="line">            layerId = arg1;</span><br><span class="line">            <span class="keyword">if</span> (arg3 &amp;&amp; <span class="keyword">typeof</span> arg3 === <span class="string">"number"</span>) &#123;</span><br><span class="line">                priority = arg3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arg4 &amp;&amp; <span class="keyword">typeof</span> arg4 === <span class="string">"boolean"</span>) &#123;</span><br><span class="line">                forceCall = arg4;</span><br><span class="line">            &#125;</span><br><span class="line">            listener = arg2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.listenerMap[type] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="comment">//注册事件</span></span><br><span class="line">            <span class="keyword">this</span>.listenerMap[type] = [];</span><br><span class="line">            <span class="keyword">super</span>.on(type, (event) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> eventNotStop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">let</span> sortListeners = <span class="keyword">this</span>.listenerMap[type].sort(</span><br><span class="line">                (a, b) =&gt; b.priority - a.priority</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">let</span> filterLayers;</span><br><span class="line">            <span class="keyword">if</span> (event.point) &#123;</span><br><span class="line">                <span class="comment">//如果事件包含点事件的话需要进行过滤出哪些图层包含了这些点。如果事件是绑定在图层上的话，需要这个来判断是否需要被调用</span></span><br><span class="line">                filterLayers = <span class="keyword">this</span>._whichLayerContainsGeometry(</span><br><span class="line">                event.point,</span><br><span class="line">                sortListeners</span><br><span class="line">                    .map(<span class="function">(<span class="params">l</span>) =&gt;</span> l.layerId)</span><br><span class="line">                    .filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== <span class="literal">undefined</span>)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> listener <span class="keyword">of</span> sortListeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                !filterLayers ||</span><br><span class="line">                !listener.layerId ||</span><br><span class="line">                filterLayers.findIndex(<span class="function">(<span class="params">l</span>) =&gt;</span> l === listener.layerId) !== <span class="number">-1</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (eventNotStop) &#123;</span><br><span class="line">                        <span class="keyword">let</span> executeResult = listener.listener(event);</span><br><span class="line">                        eventNotStop =</span><br><span class="line">                        executeResult === <span class="literal">undefined</span> ? <span class="literal">true</span> : executeResult;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//事件已经被终止，只允许forceCall的lisnten被调用</span></span><br><span class="line">                        <span class="keyword">if</span> (listener.forceCall) &#123;</span><br><span class="line">                        listener.listener(event);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listenerMap[type].push(&#123;</span><br><span class="line">                priority: priority,</span><br><span class="line">                layerId: layerId,</span><br><span class="line">                forceCall: forceCall,</span><br><span class="line">                listener: listener,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _whichLayerContainsGeometry(geometry, layers) &#123;</span><br><span class="line">        <span class="keyword">let</span> newlayers = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> layer <span class="keyword">of</span> layers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getLayer(layer)) &#123;</span><br><span class="line">                newlayers.push(layer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> features = <span class="keyword">this</span>.queryRenderedFeatures(geometry, &#123;</span><br><span class="line">            layers: newlayers,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> targetLayers = features.map(<span class="function">(<span class="params">f</span>) =&gt;</span> f.layer.id);</span><br><span class="line">        <span class="keyword">return</span> targetLayers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的话，只需要把原来的new mapboxgl.Map() 换成 new iMap()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mapboxgl.accessToken =</span><br><span class="line"><span class="string">"&lt;your access token&gt;"</span>;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> iMap(&#123;</span><br><span class="line">    container: <span class="string">"map"</span>,</span><br><span class="line">    style: <span class="string">"mapbox://styles/mapbox/streets-v11"</span>,</span><br><span class="line">    center: [<span class="number">-74.5</span>, <span class="number">40</span>],</span><br><span class="line">    zoom: <span class="number">9</span>, </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是调用示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map.on(<span class="string">"load"</span>, () =&gt; &#123;</span><br><span class="line">    map.on(<span class="string">"click"</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"虽然我排在第一个，但是由于我的优先级低(默认为0)，而且前面的调用返回了false，所以我不会被调用"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    map.on(<span class="string">"click"</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"虽然前面的调用返回了false，但是我的forceCall被设置为了true，所以仍然会被调用"</span>);</span><br><span class="line">    &#125;,<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    map.on(<span class="string">"click"</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我的优先级排第二，我要阻止事件的继续向下传播"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,<span class="number">7</span>);</span><br><span class="line">    map.on(<span class="string">"click"</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"虽然我排在最后，但是由于我的优先级最高，会被第一个调用"</span>);</span><br><span class="line">    &#125;,<span class="number">9</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>下面是执行结果<br><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/mapbox-event-conflict/pic4.png" alt="执行结果"></p><p>完整代码请参考<a href="https://raw.githubusercontent.com/lixiaofei123/lixiaofei123.github.io/master/2020/06/21/mapbox-event-conflict2/demo" target="_blank" rel="noopener">这个地址</a></p><blockquote><p>同时基于iMap，我们也可以重写mapbox.marker，来避免两个marker在重叠时点击其中一个marker会导致两个marker都响应点击事件的情况</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在基于mapbox做项目，随着功能越来越多，mapbox上的事件冲突也越来越严重。比如说一个人需要实现在地图上点击一下出现一个弹窗显示当前地点的效果，另外一个人需要实现在地图上点击选中某片区域的功能，最终得到的效果是当用户在地图上点击以后既出现了弹窗又选中了某片区域。&lt;
      
    
    </summary>
    
      <category term="mapbox" scheme="https://www.lixf.io/categories/mapbox/"/>
    
    
      <category term="mapbox" scheme="https://www.lixf.io/tags/mapbox/"/>
    
      <category term="前端开发" scheme="https://www.lixf.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式在线匹配/替换测试</title>
    <link href="https://www.lixf.io/2020/06/18/regex-online/"/>
    <id>https://www.lixf.io/2020/06/18/regex-online/</id>
    <published>2020-06-18T10:41:04.000Z</published>
    <updated>2021-03-26T10:30:58.146Z</updated>
    
    <content type="html"><![CDATA[<p>本页面提供了在线测试正则表达式的功能。</p><p><div><h3>请输入待匹配文本</h3></div></p><p><textarea style="width:100%;height:300px" id="matchContent"></textarea></p><p><div><h3>请输入正则表达式</h3></div></p><p><textarea style="width:100%;height:100px" id="regexStr"></textarea></p><p><div><textarea type="text" id="replaceword" style="border:1px solid black;width:calc(100% - 200px);height:60px;" placeholder="请输入替换字符串"></textarea>&nbsp;&nbsp;<button style="padding: 1px 6px;" id="matchBtn">测试匹配</button>&nbsp;&nbsp;<button style="padding: 1px 6px;" id="replaceBtn">测试替换</button></div></p><p><div><h3>匹配结果</h3></div></p><p><textarea style="width:100%;height:200px" id="result" disabled></textarea></p><script>    let matchBtn = document.getElementById("matchBtn");    let replaceBtn = document.getElementById("replaceBtn");    let matchContentInput = document.getElementById("matchContent");    let regexStrInput = document.getElementById("regexStr");    let replacewordInput = document.getElementById("replaceword");     let resultArea = document.getElementById("result");    matchBtn.onclick = function(){      let matchContent = matchContentInput.value;      let regexStr = regexStrInput.value      let regex = new RegExp(regexStr, "g");      let matches = [...matchContent.matchAll(regex)]      resultArea.value = matches.length !== 0 ? JSON.stringify(matches,null, 4) : "无匹配结果，请检查正则表达式是否正确"     }    replaceBtn.onclick= function(){        let matchContent = matchContentInput.value;        let regexStr = regexStrInput.value        let rw = replacewordInput.value        let regex = new RegExp(regexStr, "g");        matchContent = matchContent.replace(regex,rw)        resultArea.value = matchContent        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本页面提供了在线测试正则表达式的功能。&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;h3&gt;请输入待匹配文本&lt;/h3&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;textarea style=&quot;width:100%;height:300px&quot; id=&quot;matchContent&quot;&gt;&lt;/textarea&gt;&lt;/p
      
    
    </summary>
    
      <category term="在线工具" scheme="https://www.lixf.io/categories/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="在线转换" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="在线匹配" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E5%8C%B9%E9%85%8D/"/>
    
      <category term="正则表达式" scheme="https://www.lixf.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>二维码在线生成</title>
    <link href="https://www.lixf.io/2020/05/13/text-to-qrcode/"/>
    <id>https://www.lixf.io/2020/05/13/text-to-qrcode/</id>
    <published>2020-05-13T07:39:30.000Z</published>
    <updated>2021-03-26T10:30:58.147Z</updated>
    
    <content type="html"><![CDATA[<p>在线生成二维码，也可以直接在本链接后面加入?text=要转换的文字，例如<br><a href="https://www.lixf.io/2020/05/13/text-to-qrcode/?text=hello">https://www.lixf.io/2020/05/13/text-to-qrcode/?text=hello</a></p><p><div><br>    <textarea id="qrtext" style="width:100%;height:60px" oninput="generateQRcode()">待转换的文字</textarea><br>    <div style="margin-top: 15px;text-align: center;"><p>二维码在下面，右键点击保存</p> <div id="qrcode" style="width:200px;height:200px;margin-left:auto;margin-right:auto"></div><br></div></div></p><script>    let qrcodeImg = document.getElementById('qrcode');    let qrtext = document.getElementById("qrtext")    function generateQRcode() {        qrcodeImg.innerHTML = "";        new QRCode(qrcodeImg, { text: qrtext.value, width: 200, height: 200 });    }    function getQueryVariable(variable) {        var query = window.location.search.substring(1);        var vars = query.split("&");        for (var i = 0; i < vars.length; i++) {            var pair = vars[i].split("=");            if (pair[0] == variable) { return pair[1]; }        }        return (false);    }    let text = getQueryVariable("text")    if(text){        qrtext.value = decodeURIComponent(text);    }    window.addEventListener("load",function(){        generateQRcode()    })</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在线生成二维码，也可以直接在本链接后面加入?text=要转换的文字，例如&lt;br&gt;&lt;a href=&quot;https://www.lixf.io/2020/05/13/text-to-qrcode/?text=hello&quot;&gt;https://www.lixf.io/2020/05/1
      
    
    </summary>
    
      <category term="在线工具" scheme="https://www.lixf.io/categories/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="在线工具" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="二维码" scheme="https://www.lixf.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="在线生成二维码" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>文件在线转base64字符串和base64字符串在线转图片</title>
    <link href="https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/"/>
    <id>https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/</id>
    <published>2020-05-12T08:16:10.000Z</published>
    <updated>2021-03-26T10:30:58.127Z</updated>
    
    <content type="html"><![CDATA[<p>本页面提供了文件转base64字符串以及base64字符串转图片的功能。<br>你也可以直接在本文链接后面加入参数base64Str，值为图片的base64编码,例如<br><a href="https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/?base64Str=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI8AAACOCAIAAACHXcxhAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGGUlEQVR4nO2d3W4rMQiEk6N9/1fOuYiUVPYC48EbaVbzXVVZ/9AQKAbcPB/rvF6v4ZXn80k8KkeWcz8DZtmGuYiEM8Ng5HeJ9uUYNvrXWcv8mKP8yP+l80kZ5i7tO6zwmbtkKDizgfa32/I+27aUsLaUOD4/4X9sE5K/w3ik0AlMZif2/gEJf4YpjylSQIKaks77bNtSwtpS4qiHUJSeAXEIg0dCzmGJs4oGbPFv0XZ7sW0pYW0p0fKEXDonmpKMiVZDPFUUEyK7lF40GnkRti0lrC0lvp6QsGUkSLsi9Y4sHi2CuERcQlxURIAS25YS1pYSx5YiSOLE8KpgSRK84XVLXNTHFE8mU0pJtpRybFtKrFUjI4hzTyf1PoOEGwRRhIIYWSkYgW1LCWtLiawaieeTOvbeSXgjU4gcPN5CgufvidPkjG1LCWtLiRNPQjRfdpo+M+GqsxoemyHgnSPzlPKYtSU4tG0pYW0pcZKD79QYkwFEoEVkgDpufEsFFS+cOia8OdaWEsfSqS265UIEh51Aa8tJMyHywDM/7t61bSlhbSnx3HsFCncaXIBXbtcpBm6pZEZrIlNKD2/bUsLaUuKkL6N0L1x6kLg1TewbgXgk/EAdSbgkEoFtS4nNmaeZ6FYPQnnu2dKXmcztgNcNEpEGbFtKWFtKQNXI4dHeFPi8bzJmdWQyF099cdt1Kqj2hHfA2lLiuWShEXhpsZN6n9dMBNjSIFbm4OftOjKXq9m2lLC2lDiWHODGWy6dHgdiCtIwQrSbcYffUpII25YS1pYS2f2tKIH2eZ0wf+SkWTb+I+vj+fsOUanhAbg1QiTblhLWlhInMeEMHgqWj64+aeIhLu6IloqQHcHK1WxbSlhbSmRxSxS/7bXuYXFk33lKQunGiQoRInMJsaxtSwmoGoknYBLKRU6Ea1zRwYVPtiNkjlYjtpuxbSlhbSlxUo3sgJ9dLmqI2yLS8OiicgERmNi2lLC2lDi5EfR9tp4BmsE97ZaTWSnbkgfGe0lw2ZZWG7BtKWFtKQF9o9MwZimYwT1SMrf0SOVNJGRkJFuniY9LTTnzdAesLSWyaiSeyMJvVnUaGRLK4HApehwaTy4SzPe3bo61pcTJNzolbQgd8Kogvu/e7FwU+3GdcYTwPh3fCmtLiey77cpM15YSajllCcKd4mFqpzd5y5VW25YSWV/Gd1AjexTR+dB16pb40fB0cLRd+VZ0elg+2LaUsLaUOPlPrR/KJq+OE1tynlEGiGigXMq09Suo3AUk5+DvgLWlBHTeKuMcfAoystMpFq0/pNURCfHFk0d4mfQvkWy2LSWsLSXW/nNQJxeFu1P8cLrlPFvuy93SiODqom9sW0pYW0pA97ciOlevku3wmBDpe8WLAOXdyGSXaDXkzcT9uW1LCWtLiSxPOEP0vZbg+87b4W5tqZA4PFqqoJaydco9ti0lrC0lsu9aiB4lOTfk0QBx1EUWKT08kZ/seH4i5zBj21Iiuxv5HQR/psoPzlL9EL8RFG2XCJZM6Rj3sOxS8TMR6Y1tSwlrSwnoRhBRluwQibR3F1wSLvVezl3q0Xtj21LC2lICMu0orosGgGOGkXg+O+GKPt+lgm2yUbRIIok9oTDWlhJf0+u0VOytCuL7liMfK6fUTnZ8lo2IJ8v3xLalhLWlRGaenZzbFc4TkbDTI4ysT0Pc8JgFsG0pYW0pcXJr4aKuK4IyviJ6OraIiiT98LnzIhG2LSWsLSWg2nE4eUcDxdKsAeRE3++3nUduueGRSOKKyR04iCiAy9C8Z3HZ69I+Otmj8vri0slsGLzUbFpuZNtSwtpSIvsG3Rm8sod7JOQUVXpR/LdAWjnL4AKHC+LcoXYHrC0loP/eT7ToRotwPbMb9yVuBP2sklkua9tSwtpSIvvPQSWci8hfP52Ld6hxefpo32hAsl0pc3kYT2S2bSlhbSnR8oQzswkPhk+06kdLrb5CQHSZbalL+HR8B6wtJU5uieNwLgLfjggsS79KOEaul61z9yvCtqWEtaUEY55LF4+i/giiiLxlbjnydKP89dUxpUiRbLYtJawtJVodaubH2LaU+A878XBLxw2oFAAAAABJRU5ErkJggg==">https://www.lixf.io/2020/05/12/file-to-base64-and-base64-to-img/?base64Str=data:image/png;base64,xxxxxxxxx</a><br>可直接打开上面链接查看示例</p><p><div><br>        <div id="dropbox" style="width:100%;padding: 40px 0px;border:1px solid black;text-align: center;"><input type="file" id="input" onchange="handleFiles(this.files)"></div><br>        <div id="fileinfo" style="ont-size: 14px;">文件名:<span id="filename">未知</span>&nbsp;&nbsp;文件大小:<span id="filesize">未知</span>&nbsp;&nbsp; 文件类型:<span id="filetype">未知</span>&nbsp;&nbsp; <button style="padding: 1px 6px;" id="base64ToImgBtn">转图片</button>&nbsp;&nbsp; <button style="padding: 1px 6px;" id="clearBtn">清空结果</button></div></div><br>        <div><textarea id="result" style="width:100%;height: 600px;"></textarea></div><br></p><script>    let dropbox = document.getElementById("dropbox");    let filename = document.getElementById("filename");    let filetype = document.getElementById("filetype");    let filesize = document.getElementById("filesize");    let base64result = document.getElementById("result");    let base64ToImgBtn = document.getElementById("base64ToImgBtn")    let clearBtn = document.getElementById("clearBtn")    dropbox.addEventListener("dragenter", e => {        e.stopPropagation();        e.preventDefault();        dropbox.style.border = "2px solid green"    }, false);    dropbox.addEventListener("dragleave", e => {        e.stopPropagation();        e.preventDefault();        dropbox.style.border = "1px solid black"    }, false);    dropbox.addEventListener("dragover", e => {        e.stopPropagation();        e.preventDefault();    }, false);    dropbox.addEventListener("drop", e => {        e.stopPropagation();        e.preventDefault();        var dt = e.dataTransfer;        let files = dt.files;        handleFiles(files);    }, false);    clearBtn.addEventListener("click",()=>{        base64result.value = ""    })    base64ToImgBtn.addEventListener("click",()=>{        let popup = document.getElementById('popup')        if(popup){            popup.parentNode.remove(popup)        }        let base64Str = base64result.value            showBase64Pic(base64Str)    })    let base64Str = getQueryVariable("base64Str")    if(base64Str){         base64result.value = base64Str        showBase64Pic(base64Str)    }    function handleFiles(files) {        if (files.length > 0) {            base64result.value = "正在处理中，请稍后"            let file = files[0];            let fileSize = file.size;            let fileName = file.name;            let fileType = file.type;            filename.innerText = fileName;            filetype.innerText = fileType;            filesize.innerText = wellFileSize(fileSize);            if (fileSize <= 1024 * 1024 * 3) {                let reader = new FileReader();                reader.onload = e => {                    base64result.value = e.target.result;                }                reader.readAsDataURL(file);            } else {                base64result.value = "文件太大了，请选择小于3M的文件";            }        }else{            base64result.value = "请选择一个文件";        }    }    function wellFileSize(size) {        if (size <= 1024) {   // byte            return size + "byte";        } else if (size <= 1024 * 1024) {   //kb            return (size / 1024).toFixed(2) + "kb";        } else if (size <= 1024 * 1024 * 1024) {  // mb            return (size / (1024 * 1024)).toFixed(2) + "mb";        } else { //gb            return (size / (1024 * 1024 * 1024)).toFixed(2) + "gb";        }    }    function showBase64Pic(base64Str){            let pop = document.createElement("div")                pop.innerHTML = `                <div id="popup" style="position:fixed;top:0px;right:0px;left:0px;bottom:0px;background:rgba(0,0,0,0.8);z-index:99999" onclick="let popup=document.getElementById('popup');popup.parentNode.remove(popup);">            <div id="popup" style="position:relative;width:80%;margin-left:10%;margin-right:10%;text-align:center;margin-top:80px;background:white;border:1px solid #adc2d7;box-shadow: 1px 2px 3px #adc2d7;padding:20px 0px;" onclick="var event = arguments[0] || window.event;event.stopPropagation()">                <button style="position:absolute;right:0px;top:0px;padding:5px 15px" onclick="let popup=document.getElementById('popup');popup.parentNode.remove(popup);">关闭</button><br>                <span id="loaderror" style="color:red"></span>                <img id="base64img" style="max-width:80%;max-height:calc(100vh - 200px);" src="${base64Str}" onerror="document.getElementById('loaderror').innerHTML='这不是一个有效的图片的Base64字符串';document.getElementById('base64img').style.display='none'">                </div>                </div>            `                document.body.appendChild(pop)        }        function getQueryVariable(variable) {            var query = window.location.search.substring(1);            var vars = query.split("&");            for (var i = 0; i < vars.length; i++) {                var pair = vars[i].split("=");                if (pair[0] == variable) { return pair[1]; }            }            return (false);        }</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本页面提供了文件转base64字符串以及base64字符串转图片的功能。&lt;br&gt;你也可以直接在本文链接后面加入参数base64Str，值为图片的base64编码,例如&lt;br&gt;&lt;a href=&quot;https://www.lixf.io/2020/05/12/file-to-ba
      
    
    </summary>
    
      <category term="在线工具" scheme="https://www.lixf.io/categories/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="在线转换" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="base64编码" scheme="https://www.lixf.io/tags/base64%E7%BC%96%E7%A0%81/"/>
    
      <category term="文件转base64" scheme="https://www.lixf.io/tags/%E6%96%87%E4%BB%B6%E8%BD%ACbase64/"/>
    
      <category term="base64转图片" scheme="https://www.lixf.io/tags/base64%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>利用阿里云的OSS将markdown中的本地路径的图片替换为网络图片</title>
    <link href="https://www.lixf.io/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/"/>
    <id>https://www.lixf.io/2020/05/07/Replace-the-local-path-pictures-in-markdown-with-network-pictures/</id>
    <published>2020-05-07T13:09:46.000Z</published>
    <updated>2021-05-09T09:11:08.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这样就影响了我们把自己的博客发布到互联网上。</p><p>常见的有下面的方法来解决这个问题:</p><ol><li><p>将我们的图片存放到图床里，然后获取到一个互联网上的链接，然后在我们的markdown中使用这个互联网链接。</p></li><li><p>如果我们使用的hexo+github page的话，可以使用hexo-asset-image插件(<a href="https://whisperchi.com/posts/62275/" target="_blank" rel="noopener">点击这里</a>查看使用方法)，这个插件会把我们的本地图片资源一起打包发布到github上，从而可以在互联网上正常访问我们的博客。</p></li></ol><p>这两种方法各有缺点，第一种方法的缺点是如果我们图片很多的话，每个图片都需要上传到图床，操作是非常麻烦的。第二种方法的缺点是github在国内访问速度比较慢，如果博客引用的github的资源比较多而且比较大的话，会导致页面加载时间严重变长，另外这也不是通用的解决方案。</p><blockquote><p>我们可以参考<a href="https://whisperchi.com/posts/35930/" target="_blank" rel="noopener">这篇博客</a>，分别将博客托管到国内的仓库和github上，再利用阿里云的DNS的双线解析功能，针对不同的线路解析到不同的仓库上。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>综上，我写了一个小工具<a href="https://github.com/lixiaofei123/md-img-oss" target="_blank" rel="noopener">md-img-oss</a>来处理这个问题。这个工具的作用是检测markdown文件中的图片，如果发现图片的路径是本地文件路径，就将这个图片上传到阿里云OSS上,并将原文中的本地图片路径替换为阿里云OSS提供的路径。<br>如图，分别是替换前和替换后的效果</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/localpath.png" alt="替换前"></p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/networkpath.png" alt="替换后"></p><h3 id="安装md-img-oss"><a href="#安装md-img-oss" class="headerlink" title="安装md-img-oss"></a>安装md-img-oss</h3><p>安装md-img-oss，如果你本地有golang环境的话，只需要一行命令，就可以安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/lixiaofei123/md-img-oss</span><br></pre></td></tr></table></figure></p><p>如果本地没有golang环境，点击这里<a href="https://github.com/lixiaofei123/md-img-oss/releases" target="_blank" rel="noopener">附件:md-img-oss</a>下载对应平台的软件。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装完毕后，执行下面的命令，即可自动替换图片链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md-img-oss -mddir <span class="string">"C:\Users\Administrator\Desktop\lixiaofei123.github.io\source\_posts"</span> -endpoint oss-cn-shenzhen.aliyuncs.com -accesskeyId &lt;替换成你的accesskeyId&gt; -accessKeySecret &lt;替换成你的accesskeySecret&gt; -bucketName &lt;替换成你的bucketName&gt; -ossDir lixfio/image -domain https://static.lixfio.huiyuanai.cn</span><br><span class="line"><span class="comment"># ossDir 和 domain 是非必须的，可以不需要</span></span><br></pre></td></tr></table></figure><p>如果觉得每次都执行这么长的命令不方便的话，可以把这个命令写到脚本里，然后通过执行脚本来运行这条命令</p><p>也可以执行下面的命令查看各个参数的意思</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md-img-oss --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>下面是执行结果<br><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/Replace-the-local-path-pictures-in-markdown-with-network-pictures/output.png" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在写markdown的时候,有时候为了更加清楚表示我们的观点,我们需要在md中插入一些图片资源。这些图片可能只存在我们本地的文件系统中，但这
      
    
    </summary>
    
      <category term="实用" scheme="https://www.lixf.io/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="markdown" scheme="https://www.lixf.io/tags/markdown/"/>
    
      <category term="图床" scheme="https://www.lixf.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>拓展nextcloud中ocdownloader的功能</title>
    <link href="https://www.lixf.io/2020/05/06/Expand-the-function-of-ocdownloader/"/>
    <id>https://www.lixf.io/2020/05/06/Expand-the-function-of-ocdownloader/</id>
    <published>2020-05-06T08:32:03.000Z</published>
    <updated>2021-05-09T09:11:08.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文只针对不熟悉php的用户</strong></p><p>经过<a href="https://www.lixf.io/2020/04/29/nextcloud-in-docker/">上文</a>的步骤在成功部署了一个nextcloud服务以及安装了nextcloud插件以后，便想自己扩展一下ocdownloader的功能，让其能够从我指定的一个视频网站（非Youtube）的某个视频链接上自动下载其对应的视频。 比较尴尬的是我虽然有一点点其它语言开发的经验，但是并不会php开发（上次接触php语言已经是6年前的事情了），但是，这个并不能难倒我，在几番尝试中，最终还是实现了自己想要的功能。</p><p>首先，我们简单看一下ocdownloader的功能，然后根据其中两个特点</p><ol><li>其能够从指定的http链接上下载其对应的文件，</li><li>其大部分功能都是通过调用第三方工具实现</li></ol><p>根据这两个特点，很容易降低我们的开发难度。我们可以使用我们自己擅长的语言来开发一个工具，这个工具可以从视频链接中提取出对应的资源链接。然后，修改ocdownloader的代码，调用我们自己的工具将视频链接处理成对应的资源链接，将这个资源链接作为参数传递给ocdownloader自己的http下载接口。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>这一步，可以使用自己擅长的语言进行开发。如下图所示，是我自己写的一个根据某网站视频链接提取资源链接以及标题的一个小工具</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/Expand-the-function-of-ocdownloader/tool-example.png" alt="工具例子"></p><p>该工具支持两个参数，proxy参数可以指定代理，videoUrl则是网站视频链接，执行命令后返回的json字符串中包含两个字段，title为标题，url则是提取出的视频链接</p><blockquote><p>至于怎么从视频链接中提取出视频对应的资源链接，这个需要具体网站具体分析。以上面的视频网站为例，是将资源的链接拆散后再用js拼在一起的，虽然解析的代码工作量稍微大一点，但是难度并不大。</p></blockquote><h3 id="拓展代码"><a href="#拓展代码" class="headerlink" title="拓展代码"></a>拓展代码</h3><p>一旦我们开发出来上面的工具以后，后面的工作就简单了，虽然不懂PHP语言，但是可以比葫芦画瓢的修改原ocDownloader的代码，来实现我们的功能。</p><p>为了简单，我是这样实现我的功能的，用户在新HTTP下载任务中填入下载链接，然后我在代码中判断这个链接是不是指定的视频网站的链接，如果是的话，就调用工具获取这个视频链接所对应的资源链接。然后将用户填写的下载链接替换成工具所获取的资源链接，同时将输出文件名修改为工具所获取的视频的名称。</p><p>下面是修改步骤</p><p>首先，将其插件代码克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/e-alfred/ocdownloader.git</span><br></pre></td></tr></table></figure><p>然后，进入到controller/lib目录下，新建一个php文件，我这里叫做pbutil.php，其所对应的类的功能就是调用我们上面的工具并获取对应的返回内容。</p><p>例如，下面是实现的代码。实际上，下面的代码完全是模仿同目录下youtube.php文件修改来的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OCA</span>\<span class="title">ocDownloader</span>\<span class="title">Controller</span>\<span class="title">Lib</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PBUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $PBDLBinary = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> $URL = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> $ProxyAddress = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> $ProxyPort = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数需要传入pbutil的执行文件路径，以及视频链接</span></span><br><span class="line">    <span class="comment">// 当然这里也可以不需要传入pbutil的路径，而是直接在这里硬编码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($PBDLBinary, $URL)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;PBDLBinary = $PBDLBinary;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;URL = $URL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setProxy</span><span class="params">($ProxyAddress, $ProxyPort)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ProxyAddress = $ProxyAddress;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ProxyPort = $ProxyPort;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  这个叫做getVideoUrl()是因为我写的pbutil工具的第一个版本就是只返回了一个资源链接。因为后面在使用过程中发现，下载的时候可以指定一个输出文件名，因此修改了pbutil的代码，使其返回了一个包含了视频标题和资源链接的json字符串。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getVideoUrl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $Proxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_null(<span class="keyword">$this</span>-&gt;ProxyAddress) &amp;&amp; <span class="keyword">$this</span>-&gt;ProxyPort &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">$this</span>-&gt;ProxyPort &lt;= <span class="number">65536</span>) &#123;</span><br><span class="line">            $Proxy = <span class="string">' -proxy '</span> . rtrim(<span class="keyword">$this</span>-&gt;ProxyAddress, <span class="string">'/'</span>) . <span class="string">':'</span> . <span class="keyword">$this</span>-&gt;ProxyPort;</span><br><span class="line">        &#125;</span><br><span class="line">        $Output = shell_exec(</span><br><span class="line">            <span class="keyword">$this</span>-&gt;PBDLBinary.<span class="string">' -videoUrl \''</span>.<span class="keyword">$this</span>-&gt;URL.<span class="string">'\' '</span></span><br><span class="line">            .(is_null($Proxy) ? <span class="string">''</span> : $Proxy)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> $Output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改controller目录下的httpdownloader.php文件，</p><p>首先，在99行的上面，也就是  if($isMagnet)这个代码的上面，加入下面的代码片段</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$sourceUrl = $_POST[<span class="string">'FILE'</span>];</span><br><span class="line"><span class="keyword">if</span> (strpos($sourceUrl, <span class="string">'******'</span>) !== <span class="keyword">false</span>) &#123; <span class="comment">//******换成视频网站的名字，例如 youku</span></span><br><span class="line">    $pbUtil = <span class="keyword">new</span> PBUtil(<span class="string">'/usr/bin/pbutil'</span>, $sourceUrl); <span class="comment">//传入执行文件路径以及视频链接</span></span><br><span class="line">    <span class="keyword">if</span> (!is_null(<span class="keyword">$this</span> - &gt; ProxyAddress) &amp;&amp; <span class="keyword">$this</span> - &gt; ProxyPort &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">$this</span> - &gt; ProxyPort &lt;= <span class="number">65536</span>) &#123;</span><br><span class="line">        $pbUtil - &gt; SetProxy(<span class="keyword">$this</span> - &gt; ProxyAddress, <span class="keyword">$this</span> - &gt; ProxyPort);</span><br><span class="line">    &#125;</span><br><span class="line">    $respdata = $pbUtil - &gt; GetVideoUrl();</span><br><span class="line">    $jsondata = json_decode($respdata); <span class="comment">//获取返回结果后调用json解析</span></span><br><span class="line">    $sourceUrl = $jsondata - &gt; url; <span class="comment">// 获取资源链接</span></span><br><span class="line">    $videotitle = $jsondata - &gt; title.<span class="string">'.mp4'</span>; <span class="comment">//获取文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，将 if($isMagnet)后面出现的$_POST[‘FILE’]全部替换为$sourceUrl</p><p>然后，在114行的下面，也就是 $OPTIONS = array(‘dir’ =&gt; $this-&gt;AbsoluteDownloadsFolder, ‘out’ =&gt; $Target, ‘follow-torrent’ =&gt; $isMagnet);这一行的代码下面，加入下面的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($videotitle) &amp;&amp; strlen(trim($videotitle)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $OPTIONS[<span class="string">'out'</span>] = $videotitle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h3><p>将我们修改后的ocdownloader复制到nextcloud的app/custom_apps目录下，然后到应用里启用改插件，就可以使用我们自己写的功能了!!!</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/Expand-the-function-of-ocdownloader/downloadpage.png" alt="下载页面"></p><h3 id="视频封面"><a href="#视频封面" class="headerlink" title="视频封面"></a>视频封面</h3><p>默认情况下，nextcloud并不会为我们的视频生成封面，而是使用默认的向右三角形的封面。我们可以使用 Preview Generator插件来为我们的视频生成封面。具体使用方法可以参考这篇博客<a href="https://www.allerstorfer.at/nextcloud-install-preview-generator/" target="_blank" rel="noopener">Nextcloud: Install Preview Generator</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文只针对不熟悉php的用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过&lt;a href=&quot;https://www.lixf.io/2020/04/29/nextcloud-in-docker/&quot;&gt;上文&lt;/a&gt;的步骤在成功部署了一个nextcloud服务以及安装了n
      
    
    </summary>
    
      <category term="实用" scheme="https://www.lixf.io/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="nextcloud" scheme="https://www.lixf.io/tags/nextcloud/"/>
    
      <category term="ocdownloader" scheme="https://www.lixf.io/tags/ocdownloader/"/>
    
  </entry>
  
  <entry>
    <title>开源网盘nextcloud使用介绍</title>
    <link href="https://www.lixf.io/2020/04/29/nextcloud-in-docker/"/>
    <id>https://www.lixf.io/2020/04/29/nextcloud-in-docker/</id>
    <published>2020-04-29T07:31:52.000Z</published>
    <updated>2021-05-09T09:11:08.876Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nextcloud.com/" target="_blank" rel="noopener">NextCloud</a>是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端，功能十分强大。</p><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/login.png" alt="登录页面"></p><h4 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h4><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/main.png" alt="主页"></p><h4 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h4><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/files.png" alt="文件列表"></p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>下载速度因个人网络不同而不同。我这里是因为电信的上传带宽只有30M，因此在公网的速度只能达到每秒2兆多。如果在内网访问，速度能达到每秒近百兆</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/downloader.png" alt="下载"></p><h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><p>部署的文档<a href="https://hub.docker.com/_/nextcloud" target="_blank" rel="noopener">官网</a>写的很详细了，最简单可以用下面一条命令就可以启动。当然实际使用要做各种配置(录例如数据库、存储)，可以去看<a href="https://hub.docker.com/_/nextcloud" target="_blank" rel="noopener">官网</a>说明，这里就不再详说了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 nextcloud</span><br></pre></td></tr></table></figure><h3 id="离线下载"><a href="#离线下载" class="headerlink" title="离线下载"></a>离线下载</h3><p>这个是一个重点要宣传的功能，其作用与百度网盘的离线下载一样，可以将指定链接下载到自己的服务器上。</p><p>离线下载并不是nextcloud自带的功能（实际上nextcloud大部分的功能都是通过插件实现），而是借助一个叫做ocDownloader的插件实现。用管理员账户点击主页右上角的头像，在下拉菜单中选择【应用】，然后搜索ocDownloader安装即可。由于国内访问nextcloud自己的网站很慢，因此这里耐心等待一会。实在下载不下来的，可以找个能科学上网的机器，直接访问<a href="https://apps.nextcloud.com/apps/ocdownloader" target="_blank" rel="noopener">插件主页</a>下载安装包，然后解压到nextcloud的/var/www/html/custom_apps目录下，然后在应用页面启用该插件。</p><p>效果如图:</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/ocdownloader.png" alt="ocDownloader"></p><p>从图中可以看出，离线下载功能支持HTTP、FTP、Bittorrent协议，以及支持YOUTUBE链接。不过在使用前需要安装Aria2（也可以用curl,但是aria2功能更强大）、以及youtube-dl(如果需要下载youtube视频)。</p><p>鉴于我们使用的是Docker部署，我这里封了一个安装好aria2和youtube-dl的Docker镜像【mrlee326/nextcloud-aria】，已经上传到dockerhub，可以下载安装使用。</p><p>下载youtube视频需要能够科学上网，如果nextcloud部署的宿主机网络环境不是很自由的话，可以在【设置】-&gt; 【其它设置】-&gt; 【ocDownloader】中配置一下代理。</p><p>如果有v2ray的服务器的话，可以使用【mrlee326/v2raycli】镜像在宿主机上启动一个容器来提供代理，并链接到nextcloud容器上来使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name proxy.com -p 7777:6666 -v /root/v2ray/config.json:/etc/v2ray/config.json:ro mrlee326/v2raycli</span><br><span class="line"># 容器的名字本来是可以随便取的，但是如果不设置这种url形式的，后面在ocdownloader的配置中会出错</span><br></pre></td></tr></table></figure><p>启动代理容器后，在启动nextcloud的时候加上 –link proxy.cn参数，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --link proxy.com -p 8080:80 mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure><p>然后在【其它设置】-&gt; 【ocDownloader】中可以指定代理地址为 <a href="http://proxy.com" target="_blank" rel="noopener">http://proxy.com</a> ，端口是 7777</p><p>设置代理的作用不仅仅是为了下载youtube视频，用国内的网络直接访问外国的一些资源的时候，往往速度不是很理想，甚至可能必须配置代理才能使用。如果我们nextcloud的离线下载可以自由访问外网的话，就可以先利用离线下载功能将资源下载到我们的nextcloud里，再从nextcloud下载到我们本地，十分方便。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>我们也可以为我们的云盘启用HTTPS，感谢Docker容器，让这一切变的如此简单。这里主要使用两个容器，【jwilder/nginx-proxy】和【jrcs/letsencrypt-nginx-proxy-companion】。我们也可以用这两个容器为其它任意服务签发证书</p><p>虽然简单，我们还是要做一些准备工作。</p><ol><li><p>第一步当然是将域名解析到宿主机的公网IP上了，这里假设域名是pan.foo.bar</p></li><li><p>由于nextcloud主要是为了下载上传一些文件，因此，必须调整nginx配置中的client_max_body_size参数为一个较大的值。jwilder/nginx-proxy提供了两种修改方式，全局的和指定某域名的。这里为了方便，我们直接配置全局的方式。</p><p>在任意目录下创建一个my_proxy.conf文件（我这里是在/data/nginx/conf.d/目录下创建的），然后写入下面的内容。前三行是设置超时时间的，根据自己的需要进行设置。如果只想修改某域名的此项配置，<a href="https://github.com/nginx-proxy/nginx-proxy" target="_blank" rel="noopener">点击这里</a>参考官方文档进行配置。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_connect_timeout 600;</span><br><span class="line">proxy_send_timeout 600;</span><br><span class="line">proxy_read_timeout 600;</span><br><span class="line">client_max_body_size 10000m;</span><br></pre></td></tr></table></figure><p>这样准备工作就做完了，下一步是启动jwilder/nginx-proxy容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach   \</span><br><span class="line">--restart=always  --name nginx-proxy   \</span><br><span class="line">--publish 80:80    \</span><br><span class="line">--volume /usr/share/nginx/html    \</span><br><span class="line">--volume /data/nginx/conf.d/my_proxy.conf:/etc/nginx/conf.d/my_proxy.conf:ro  \</span><br><span class="line">--volume /var/run/docker.sock:/tmp/docker.sock:ro  \</span><br><span class="line">jwilder/nginx-proxy</span><br></pre></td></tr></table></figure><p>nginx-proxy容器启动完成后，用下面的命令启动letsencrypt-nginx-proxy-companion容器。将<a href="mailto:me@foo.bar" target="_blank" rel="noopener">me@foo.bar</a>换成自己的邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">   --name nginx-proxy-letsencrypt \</span><br><span class="line">   --volumes-from nginx-proxy \</span><br><span class="line">   --volume /var/run/docker.sock:/var/run/docker.sock:ro \</span><br><span class="line">   --env <span class="string">"DEFAULT_EMAIL=me@foo.bar"</span> \</span><br><span class="line">   jrcs/letsencrypt-nginx-proxy-companion</span><br></pre></td></tr></table></figure><p>最后就可以启动nextcloud容器啦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach \</span><br><span class="line">    --name nextcloud \</span><br><span class="line">    --restart always \</span><br><span class="line">    --link proxy.com\</span><br><span class="line">    --env <span class="string">"VIRTUAL_HOST=pan.foo.bar"</span> \</span><br><span class="line">    --env <span class="string">"VIRTUAL_PORT=3000"</span> \</span><br><span class="line">    --env <span class="string">"LETSENCRYPT_HOST=pan.foo.bar"</span> \</span><br><span class="line">    --env <span class="string">"LETSENCRYPT_EMAIL=me@foo.bar"</span> \</span><br><span class="line">    --v /data/nextcloud:/var/www/html \</span><br><span class="line">     mrlee326/nextcloud-aria</span><br></pre></td></tr></table></figure><p>启动完成稍等一下，letsencrypt-nginx-proxy-companion会自动为你签发证书，等证书签发完成后，就可以通过<a href="https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。" target="_blank" rel="noopener">https://pan.foo.bar访问网盘了。如果直接输入pan.foo.bar，也会自动跳转到https://pan.foo.bar的。</a></p><p>值得注意的是，每次重新启动容器，letsencrypt-nginx-proxy-companion都会重新签发证书，可能一不小心就会超过letsencrypt的配额限制，这样的话，得等一周后才能释放配额。因此如果在配置阶段，可以先不加LETSENCRYPT的两个环境变量，避免自动签发证书，等调试好了，再加上这两个环境变量。</p><p>最终效果如图所示，在域名的左边出现了一个代表启用了https的小锁的标志。</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/httttttps.png" alt="https"></p><h3 id="必备的插件"><a href="#必备的插件" class="headerlink" title="必备的插件"></a>必备的插件</h3><p>nextcloud还有很多其它有用的插件，这里介绍两个十分有用的插件【Mind Map】和 【Draw.io】</p><h4 id="Mind-Map"><a href="#Mind-Map" class="headerlink" title="Mind Map"></a>Mind Map</h4><p>用来画思维导图，启用了这个插件以后，我们就可以直接创建思维导图，并进行绘制</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/mindmap.png" alt></p><h4 id="Draw-io"><a href="#Draw-io" class="headerlink" title="Draw.io"></a>Draw.io</h4><p>用来画流程图，作用十分类似于国内的在线的ProcessOn。安装了Draw.io后，我们就可以将流程图文件保存在我们自己的服务器上，并且没有数量限制。不过，不像【Mind Map】，这个插件依赖外部的Drawio服务，我们可以选择自行部署，也可以选择直接使用公网的。如果使用公网的Drawio，除了打开的时候速度慢一点，别的和自己搭建的效果是一模一样的。当然，drawio也有对应的docker镜像，就算自己部署，也是特别的容易。</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/nextcloud-in-docker/drawio.png" alt></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>现在的云服务器的存储空间都不是很大，而且要不就是不支持增加存储，要不就是增加存储特别的贵。因此，我目前采用的是，将nextcloud部署到树莓派上，再购买一台搬瓦工GIA线路的服务器，然后通过内网穿透将服务暴露在公网上。这样，一方面解决了存储的问题，一方面在内网的时候可以直接通过内网访问nextcloud，最后公网服务器也可以做别的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://nextcloud.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NextCloud&lt;/a&gt;是老外开源的一个用PHP开发的有丰富插件的网盘，针对各个平台（安卓、ios、linux、mac、win）都有对应的客户端
      
    
    </summary>
    
      <category term="实用" scheme="https://www.lixf.io/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="nextcloud" scheme="https://www.lixf.io/tags/nextcloud/"/>
    
      <category term="ocdownloader" scheme="https://www.lixf.io/tags/ocdownloader/"/>
    
  </entry>
  
  <entry>
    <title>GoLang 内存模型</title>
    <link href="https://www.lixf.io/2019/09/20/The-Go-Memory-Model/"/>
    <id>https://www.lixf.io/2019/09/20/The-Go-Memory-Model/</id>
    <published>2019-09-20T07:34:41.000Z</published>
    <updated>2021-03-26T10:30:58.123Z</updated>
    
    <content type="html"><![CDATA[<p>Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。</p><h1 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h1><p>在同一个协程中，读和写的行为必须表现的和代码中指定的一致。虽然编译器以及处理器可能会对我们的代码进行重排序从而来加快程序的执行速度，但是这种重排序不会改变代码中定义的行为。但是这种重排序可能会影响多协程下的可见性。例如，在一个协程中执行了 a=1;b=2，另外一个协程可能读取到更新后的b值和更新前的a值。</p><p>Happens before定义了Golang程序中读写操作在内存中执行的顺序。如果事件e1 happens before 事件e2，那么可以说事件e2 happens after 事件e2，如果事件e1既没有happens before 事件e2，又没有happens after时间e2之后，那么可以说是e1和e2是并行的。</p><p><strong>在单线程中，<em>happens-before</em>的顺序和代码表达的顺序是一致的。</strong></p><p>现在有一个变量v，有一个对变量v的写操作w，和对变量v的读操作r。如果需要让读操作r能(但不一定)观察到写操作w的结果，需要满足下面两个条件。</p><ol><li>读操作r不happen before写操作w (有可能是并发发生)</li><li>没有另外一个写操作发生在w之后r之前。(还是有可能是并发发生)</li></ol><p>如果想要确保读操作r一定能观察到写操作w的结果，则需要满足下面两个条件。</p><ol><li>写操作w happen before 读操作r</li><li>任何另外一个写操作都 happen before写操作w之前，happen after读操作r之后。</li></ol><h1 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><em>如果package p引入了package q，那么package q的init方法的完成happens before package p的任何方法之前</em></p><blockquote><p><em>If a package</em> <code>p</code> <em>imports package</em> <code>q</code><em>, the completion of</em> <code>q</code><em>‘s</em> <code>init</code> <em>functions happens before the start of any of</em> <code>p</code><em>‘s.</em></p></blockquote><p><strong>main方法happen after所有的init方法结束之后</strong></p><blockquote><p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p></blockquote><h2 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h2><p><em>新启动一个协程happens before这个协程的执行</em></p><blockquote><p><em>The</em> <code>go</code> <em>statement that starts a new goroutine happens before the goroutine’s execution begins.</em></p></blockquote><h2 id="协程的销毁"><a href="#协程的销毁" class="headerlink" title="协程的销毁"></a>协程的销毁</h2><p>协程的结束不保证happen before于程序中的任何事件。</p><blockquote><p>The exit of a goroutine is not guaranteed to happen before any event in the program</p></blockquote><p>例如下面这个例子</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">"hello"</span> &#125;()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对a的赋值操作可能发生在任意一个事件点，因此不能确保另外一个协程能到看到赋值后的a的结果</p><h2 id="channel-通信"><a href="#channel-通信" class="headerlink" title="channel 通信"></a>channel 通信</h2><p>golang里有一个很重要的思想<em>不要通过共享内存来通信，而是通过通信来共享内存</em>.</p><blockquote><p>Don’t communicate by sharing memory; share memory by communicating.</p></blockquote><p>对应channel，也有几条重要的happens-before规则</p><p>对channel发送数据happens before于对于此channel相应的接收。</p><blockquote><p> A send on a channel happens before the corresponding receive from that channel completes.</p></blockquote><p>例如下面代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">c &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&lt;-c</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够确保输出 “hello world”。　a=”hello, world” happens before c &lt;- 0,c &lt;- 0 happens before &lt;-c，&lt;-c happens before print(a)，根据happens-before的传递性，a=”hello, world” happens before print(a)。</p><p><em>关闭channel happens before 接收channel因关闭返回的０值</em></p><blockquote><p>The closing of a channel happens before a receive that returns a zero value because the channel is closed.</p></blockquote><p><em>从一个没有缓冲的channel里接收值happens before向这个channel发送值</em></p><blockquote><p>A receive from an unbuffered channel happens before the send on that channel completes.</p></blockquote><p>这个和上面是刚好相反的。区别在于这个是一个没有缓冲的channel，即通过make(chan int)构造的通道。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">&lt;- c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">c &lt;- <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>一个容量为c的通过的第k个值的接收happens before与这个通道第k+c个值的发送</em></p><blockquote><p>The<em> </em>k<strong>th receive on a channel with capacity<em> </em>C<em> </em>happens before the<em> </em>k</strong>+<strong>C</strong>th send from that channel completes.</p></blockquote><p>例如下面这个例子，可以确保同时只有三个协程在执行w()</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(w <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">limit &lt;- <span class="number">1</span></span><br><span class="line">w()</span><br><span class="line">&lt;-limit</span><br><span class="line">&#125;(w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h2><p><em>对于sync.Mutex或者sync.RWMutex　变量，如果n &lt; m，那么第n次解锁happens before与第m次加锁</em></p><blockquote><p><em>For any</em> <code>sync.Mutex</code> <em>or</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code> <em>and</em> <em>n</em> <em>&lt;</em> <em>m**, call</em> <em>n</em> <em>of</em> <code>l.Unlock()</code> <em>happens before call</em> <em>m</em> <em>of</em> <code>l.Lock()</code> <em>returns.</em></p></blockquote><p>例如</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">l.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，l.Unlock() happens before 第二次l.Lock()，根据传递性，a = “hello, world”　happens before　print(a)，因此可以确保输出”hello, world”</p><blockquote><p><em>For any call to</em> <code>l.RLock</code> <em>on a</em> <code>sync.RWMutex</code> <em>variable</em> <code>l</code><em>, there is an</em> <em>n</em> <em>such that the</em> <code>l.RLock</code> <em>happens (returns) after call</em> <em>n</em> <em>to</em> <code>l.Unlock</code> <em>and the matching</em> <code>l.RUnlock</code> <em>happens before call</em> <em>n**+1 to</em> <code>l.Lock</code><em>.</em></p></blockquote><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>golang的sync中提供了一个安全的机制来确保多个协程的初始化方法只执行一次。它就是Once。如果多个协程同时调用了once.Do(f)，函数f()只会被执行一次，对once.Do(f)的调用将会等待f()执行结束后返回。</p><p><em>once.Do(f)中f()的执行返回happens before任何一个once.Do(f)的调用返回。</em></p><blockquote><p><em>A single call of</em> <code>f()</code> <em>from</em> <code>once.Do(f)</code> <em>happens (returns) before any call of</em> <code>once.Do(f)</code> <em>returns.</em></p></blockquote><p>例如这个程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a string</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func setup() &#123;</span><br><span class="line">a = &quot;hello, world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func doprint() &#123;</span><br><span class="line">once.Do(setup)</span><br><span class="line">print(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func twoprint() &#123;</span><br><span class="line">go doprint()</span><br><span class="line">go doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不正确的同步"><a href="#不正确的同步" class="headerlink" title="不正确的同步"></a>不正确的同步</h1><p>在并发情况中，即使读操作r观察到了写操作w的写入的值，也不意味happening after读操作r的能够观察到happened before写操作w的写。</p><p>看下面的例子</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出的结果有可能是２　0，即使print(b)输出了２，print(a)仍可能输出0。（当然这只是一种可能，这种可能性有可能永远不会发生）</p><p>还有一种是双重检查锁的代码。例如下面这段代码。第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !done &#123;</span><br><span class="line">once.Do(setup)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个不正确的写法是循环等待一个值。不正确的原因和上面差不多，也是第二个协程有可能只观察到了done=true，但是没有观察到ａ=”hello, world”，然后输出一个空字符串。另外，main方法也不保证协程setup()会被完成。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Golang的内存模型主要解决的是多协程下的对同一个变量的内存可见性的问题。&lt;/p&gt;
&lt;h1 id=&quot;Happens-Before&quot;&gt;&lt;a href=&quot;#Happens-Before&quot; class=&quot;headerlink&quot; title=&quot;Happens Before&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="golang学习" scheme="https://www.lixf.io/tags/golang%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>将网页转换成本地应用程序</title>
    <link href="https://www.lixf.io/2019/08/14/create-native-app-from-web-url/"/>
    <id>https://www.lixf.io/2019/08/14/create-native-app-from-web-url/</id>
    <published>2019-08-14T06:05:37.000Z</published>
    <updated>2021-05-09T09:11:08.873Z</updated>
    
    <content type="html"><![CDATA[<p>微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。</p><p>这里使用在线制作的方式</p><p>打开网址 <a href="https://appmaker.xyz/web2desk" target="_blank" rel="noopener">https://appmaker.xyz/web2desk</a> ，如下图</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/create-native-app-from-web-url/appmaker.png" alt></p><p>根据提示输入对应的信息，然后点击Create Now按钮，静静等待2分钟，就会跳转到一个制作成功的页面，再静静等待一会，就可以下载了。</p><blockquote><p>邮箱地址的话，我刚开始填的QQ邮箱，没有收到邮件，后面填写的谷歌邮箱，收到了邮件，也可能是我自己网络的问题导致的。</p></blockquote><p>然后根据我前面的<a href="https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/">ubuntu制作桌面图标</a>制作成桌面图标就好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微信没有linux客户端，只有网页版，每次使用都要打开一个浏览器而且比较麻烦，需要制作成一个本地应用来方便使用。&lt;/p&gt;
&lt;p&gt;这里使用在线制作的方式&lt;/p&gt;
&lt;p&gt;打开网址 &lt;a href=&quot;https://appmaker.xyz/web2desk&quot; target=&quot;_
      
    
    </summary>
    
      <category term="实用" scheme="https://www.lixf.io/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="ubuntu" scheme="https://www.lixf.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu制作桌面图标</title>
    <link href="https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/"/>
    <id>https://www.lixf.io/2019/08/14/ubuntu-create-desktop-icon/</id>
    <published>2019-08-14T05:54:09.000Z</published>
    <updated>2021-05-09T09:11:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。</p><p>这里以typora为例说一下怎么制作，其实也很简单</p><p>进入到/usr/share/applications目录后,用你自己喜欢的文件编辑器创建一个Typora.desktop的文件，然后里面写入下面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Typora</span><br><span class="line">Comment=Typora</span><br><span class="line">Exec=/home/lixf/software/Typora/Typora</span><br><span class="line">Icon=/home/lixf/software/Typora/resources/app/asserts/icon/icon_32x32@2x.png</span><br><span class="line">Terminal=false</span><br><span class="line">starttupNotify=true</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Application;Development;</span><br></pre></td></tr></table></figure><p>保存以后，进入到ubuntu的应用程序列表里就可以看到typora了，是不是很简单呢??</p><p><img src="https://static.lixfio.huiyuanai.cn/lixfio/image/ubuntu-create-desktop-icon/typora.png" alt="图标已经出来了"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用ubuntu系统的时候，有些软件是直接从网上下载的安装包，为了方便启动这些软件，需要做成桌面图标的形式。&lt;/p&gt;
&lt;p&gt;这里以typora为例说一下怎么制作，其实也很简单&lt;/p&gt;
&lt;p&gt;进入到/usr/share/applications目录后,用你自己喜欢的文件编辑
      
    
    </summary>
    
      <category term="实用" scheme="https://www.lixf.io/categories/%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="ubuntu" scheme="https://www.lixf.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>我的私人书签记录</title>
    <link href="https://www.lixf.io/2019/06/28/My-personal-bookmarks/"/>
    <id>https://www.lixf.io/2019/06/28/My-personal-bookmarks/</id>
    <published>2019-06-28T01:46:34.000Z</published>
    <updated>2021-03-26T10:30:58.119Z</updated>
    
    <content type="html"><![CDATA[<p>保存一下工作中常用的网址</p><p><strong>k8s</strong>相关</p><p><a href="https://kubernetes.io/docs" target="_blank" rel="noopener">k8s官网文档</a>   <a href="https://hub.helm.sh" target="_blank" rel="noopener">helm官方仓库</a> <a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener">nginx-ingress 部署</a>  <a href="https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md" target="_blank" rel="noopener">operator-framework</a></p><p><a href="https://www.getambassador.io/" target="_blank" rel="noopener">ambassador</a>  <a href="https://istio.io" target="_blank" rel="noopener">Istio文档</a></p><p><strong>docker</strong>相关</p><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档</a>   <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile文档</a>   <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker官方仓库</a></p><p><strong>常用镜像</strong>地址</p><p><a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">阿里云镜像</a>  <a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华镜像</a>  <a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中科大镜像</a>  <a href="http://mirror.azure.cn" target="_blank" rel="noopener">Azure中国镜像</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保存一下工作中常用的网址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;k8s&lt;/strong&gt;相关&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s官网文档&lt;/a&gt;   &lt;a hr
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://www.lixf.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>临时复制粘贴处</title>
    <link href="https://www.lixf.io/2019/06/17/textarea/"/>
    <id>https://www.lixf.io/2019/06/17/textarea/</id>
    <published>2019-06-17T07:05:19.000Z</published>
    <updated>2021-03-26T10:30:58.148Z</updated>
    
    <content type="html"><![CDATA[<p>粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）</p><p><textarea id="editbox" style="padding:10px;width:80%;margin-left:auto;margin-right:auto;height:350px"> </textarea><br><span id="tips" style="color:red;font-size:12px"></span></p><script>    Date.prototype.Format = function(fmt) {            var o = {                "M+" : this.getMonth() + 1,                "d+" : this.getDate(),                "h+" : this.getHours(),                "m+" : this.getMinutes(),                "s+" : this.getSeconds(),                "q+" : Math.floor((this.getMonth() + 3) / 3),                "S" : this.getMilliseconds()            };            if (/(y+)/.test(fmt))                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));            for (var k in o)            if (new RegExp("(" + k + ")").test(fmt))                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));            return fmt;        }      var editbox =  document.getElementById("editbox");      if(localStorage.autoSave == undefined){        localStorage.autoSave = "";      }    editbox.value = localStorage.autoSave;      setInterval(function(){         var value = editbox.value;         var saveValue = localStorage.autoSave;         if(value != saveValue){             localStorage.autoSave = value;             document.getElementById("tips").innerText= "内容已经在"+new Date().Format("yyyy-MM-dd hh:mm:ss")+"时自动保存";         }      },1000 * 3);</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;粘贴的东西暂时没地方放？？先保存到这里吧。（您的数据只保存在浏览器本地）&lt;/p&gt;
&lt;p&gt;&lt;textarea id=&quot;editbox&quot; style=&quot;padding:10px;width:80%;margin-left:auto;margin-right:auto;heigh
      
    
    </summary>
    
      <category term="在线工具" scheme="https://www.lixf.io/categories/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="在线工具" scheme="https://www.lixf.io/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="临时保存" scheme="https://www.lixf.io/tags/%E4%B8%B4%E6%97%B6%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
</feed>
